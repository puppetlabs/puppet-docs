---
layout: default
built_from_commit: edcda126535bd31439280bcf21402a4a4f126f71
title: 'Man Page: puppet epp'
canonical: "/puppet/latest/man/epp.html"
---

<div class='mp'>
<h2 id="NAME">NAME</h2>
<p class="man-name">
  <code>puppet-epp</code> - <span class="man-whatis">Interact directly with the EPP template parser/renderer.</span>
</p>

<h2 id="SYNOPSIS">SYNOPSIS</h2>

<p>puppet epp <var>action</var></p>

<h2 id="OPTIONS">OPTIONS</h2>

<p>Note that any setting that's valid in the configuration
file is also a valid long argument, although it may or may not be
relevant to the present action. For example, <code>server</code> and <code>run_mode</code> are valid
settings, so you can specify <code>--server &lt;servername></code>, or
<code>--run_mode &lt;runmode></code> as an argument.</p>

<p>See the configuration file documentation at
<a href="https://docs.puppetlabs.com/puppet/latest/reference/configuration.html" data-bare-link="true">https://docs.puppetlabs.com/puppet/latest/reference/configuration.html</a> for the
full list of acceptable parameters. A commented list of all
configuration options can also be generated by running puppet with
<code>--genconfig</code>.</p>

<dl>
<dt>--render-as FORMAT</dt><dd>The format in which to render output. The most common formats are <code>json</code>,
<code>s</code> (string), <code>yaml</code>, and <code>console</code>, but other options such as <code>dot</code> are
sometimes available.</dd>
<dt>--verbose</dt><dd>Whether to log verbosely.</dd>
<dt class="flush">--debug</dt><dd>Whether to log debug information.</dd>
</dl>


<h2 id="ACTIONS">ACTIONS</h2>

<dl>
<dt><code>dump</code> - Outputs a dump of the internal template parse tree for debugging</dt><dd><p><code>SYNOPSIS</code></p>

<p>puppet epp dump [--e <var>source</var>]
[--[no-]validate]
[--[no-]header]
-e <var>source</var> | [<var>templates</var> ...]</p>

<p><code>DESCRIPTION</code></p>

<p>The dump action parses and validates the EPP syntax and dumps the resulting AST model
in a human readable (but not necessarily an easy to understand) format.
The output format of the dumped tree is intended for epp parser debugging purposes
and is not API, and may thus change between versions without deprecation warnings.</p>

<p>The command accepts one or more templates (.epp) files, or an -e followed by the template
source text. The given templates can be paths to template files, or references
to templates in modules when given on the form <var>modulename</var>/<var>template-name</var>.epp.
If no arguments are given, the stdin is read (unless it is attached to a terminal)</p>

<p>If multiple templates are given, they are separated with a header indicating the
name of the template. This can be suppressed with the option --no-header.
The option --[no-]header has no effect when a single template is dumped.</p>

<p>When debugging the epp parser itself, it may be useful to suppress the validation
step with the <code>--no-validate</code> option to observe what the parser produced from the
given source.</p>

<p>This command ignores the --render-as setting/option.</p>

<p><code>OPTIONS</code>
<var>--e &lt;source</var>> -
Dump one epp source expression given on the command line.</p>

<p><var>--[no-]header</var> -
Whether or not to show a file name header between files.</p>

<p><var>--[no-]validate</var> -
Whether or not to validate the parsed result, if no-validate only syntax errors are reported.</p>

<p><code>RETURNS</code></p>

<p>A dump of the resulting AST model unless there are syntax or validation errors.</p></dd>
<dt><code>render</code> - Renders an epp template as text</dt><dd><p><code>SYNOPSIS</code></p>

<p>puppet epp render [--node <var>node_name</var>]
[--e <var>source</var>]
[--values <var>values_hash</var>]
[--values_file <var>pp_or_yaml_file</var>]
[--facts <var>facts_file</var>]
[--[no-]header]
-e <var>source</var> | [<var>templates</var> ...]</p>

<p><code>DESCRIPTION</code></p>

<p>This action renders one or more EPP templates.</p>

<p>The command accepts one or more templates (.epp files), given the same way as templates
are given to the puppet <code>epp</code> function (a full path, or a relative reference
on the form '<var>modulename</var>/<var>template-name</var>.epp'), or as a relative path.args In case
the given path matches both a modulename/template and a file, the template from
the module is used.</p>

<p>An inline_epp equivalent can also be performed by giving the template after
an -e, or by piping the EPP source text to the command.</p>

<p>Values to the template can be defined using the Puppet Language on the command
line with <code>--values</code> or in a .pp or .yaml file referenced with <code>--values_file</code>. If
specifying both the result is merged with --values having higher precedence.</p>

<p>The --values option allows a Puppet Language sequence of expressions to be defined on the
command line the same way as it may be given in a .pp file referenced with <code>--values_file</code>.
It may set variable values (that become available in the template), and must produce
either <code>undef</code> or a <code>Hash</code> of values (the hash may be empty). Producing <code>undef</code> simulates
that the template is called without an arguments hash and thus only references
variables in its outer scope. When a hash is given, a template is limited to seeing
only the global scope. It is thus possible to simulate the different types of
calls to the <code>epp</code> and <code>inline_epp</code> functions, with or without a given hash. Note that if
variables are given, they are always available in this simulation - to test that the
template only references variables given as arguments, produce a hash in --values or
the --values_file, do not specify any variables that are not global, and
turn on --strict_variables setting.</p>

<p>If multiple templates are given, the same set of values are given to each template.
If both --values and --value_file are used, the --values are merged on top of those given
in the file.</p>

<p>When multiple templates are rendered, a separating header is output between the templates
showing the name of the template before the output. The header output can be turned off with
<code>--no-header</code>. This also concatenates the template results without any added newline separators.</p>

<p>Facts from the node where the command is being run are used by default.args Facts can be obtained
for other nodes if they have called in, and reported their facts by using the <code>--node &lt;nodename></code>
flag.</p>

<p>Overriding node facts as well as additional facts can be given in a .yaml or .json file and referencing
it with the --facts option. (Values can be obtained in yaml format directly from
<code>facter</code>, or from puppet for a given node). Note that it is not possible to simulate the
reserved variable name <code>$facts</code> in any other way.</p>

<p>Note that it is not possible to set variables using the Puppet Language that have the same
names as facts as this result in an error; "attempt to redefine a variable" since facts
are set first.</p>

<p>Exits with 0 if there were no validation errors. On errors, no rendered output is produced for
that template file.</p>

<p>When designing EPP templates, it is strongly recommended to define all template arguments
in the template, and to give them in a hash when calling <code>epp</code> or <code>inline_epp</code> and to use
as few global variables as possible, preferably only the $facts hash. This makes templates
more free standing and are easier to reuse, and to test.</p>

<p><code>OPTIONS</code>
<var>--e &lt;source</var>> -
Render one inline epp template given on the command line.</p>

<p><var>--facts &lt;facts_file</var>> -
A .yaml or .json file containing a hash of facts made available in $facts and $trusted</p>

<p><var>--[no-]header</var> -
Whether or not to show a file name header between rendered results.</p>

<p><var>--node &lt;node_name</var>> -
The name of the node for which facts are obtained. Defaults to facts for the local node.</p>

<p><var>--values &lt;values_hash</var>> -
A Hash in Puppet DSL form given as arguments to the template being rendered.</p>

<p><var>--values_file &lt;pp_or_yaml_file</var>> -
A .pp or .yaml file that is processed to produce a hash of values for the template.</p>

<p><code>RETURNS</code></p>

<p>A rendered result of one or more given templates.</p></dd>
<dt><code>validate</code> - Validate the syntax of one or more EPP templates.</dt><dd><p><code>SYNOPSIS</code></p>

<p>puppet epp validate [--[no-]continue_on_error] [<var>template</var>] [<var>template</var> ...]</p>

<p><code>DESCRIPTION</code></p>

<p>This action validates EPP syntax without producing any output.</p>

<p>When validating, multiple issues per file are reported up
to the settings of max_error, and max_warnings. The processing
stops after having reported issues for the first encountered file with errors
unless the option --continue_on_error is given.</p>

<p>Files can be given using the <code>modulename/template.epp</code> style to lookup the
template from a module, or be given as a reference to a file. If the reference
to a file can be resolved against a template in a module, the module version
wins - in this case use an absolute path to reference the template file
if the module version is not wanted.</p>

<p>Exits with 0 if there were no validation errors.</p>

<p><code>OPTIONS</code>
<var>--[no-]continue_on_error</var> -
Whether or not to continue after errors are reported for a template.</p>

<p><code>RETURNS</code></p>

<p>Nothing, or encountered syntax errors.</p></dd>
</dl>


<h2 id="EXAMPLES">EXAMPLES</h2>

<p><code>render</code></p>

<p>Render the template in module 'mymodule' called 'mytemplate.epp', and give it two arguments
<code>a</code> and <code>b</code>:</p>

<pre><code>$ puppet epp render mymodule/mytemplate.epp --values '{a =&gt; 10, b =&gt; 20}'
</code></pre>

<p>Render a template using an absolute path:</p>

<pre><code>$ puppet epp render /tmp/testing/mytemplate.epp --values '{a =&gt; 10, b =&gt; 20}'
</code></pre>

<p>Render a template with data from a .pp file:</p>

<pre><code>$ puppet epp render /tmp/testing/mytemplate.epp --values_file mydata.pp
</code></pre>

<p>Render a template with data from a .pp file and override one value on the command line:</p>

<pre><code>$ puppet epp render /tmp/testing/mytemplate.epp --values_file mydata.pp --values '{a=&gt;10}'
</code></pre>

<p>Render from STDIN:</p>

<pre><code>$ cat template.epp | puppet epp render --values '{a =&gt; 10, b =&gt; 20}'
</code></pre>

<p>Set variables in a .pp file and render a template that uses variable references:</p>

<pre><code># data.pp file
$greeted = 'a global var'
undef

$ puppet epp render -e 'hello &lt;%= $greeted %>' --values_file data.pp
</code></pre>

<p>Render a template that outputs a fact:</p>

<pre><code>$ facter --yaml &gt; data.yaml
$ puppet epp render -e '&lt;% $facts[osfamily] %>' --facts data.yaml
</code></pre>

<p><code>validate</code></p>

<p>Validate the template 'template.epp' in module 'mymodule':</p>

<pre><code>$ puppet epp validate mymodule/template.epp
</code></pre>

<p>Validate two arbitrary template files:</p>

<pre><code>$ puppet epp validate mymodule/template1.epp yourmodule/something.epp
</code></pre>

<p>  Validate a template somewhere in the file system:</p>

<pre><code>  $ puppet epp validate /tmp/testing/template1.epp
</code></pre>

<p>   Validate a template against a file relative to the current directory:</p>

<pre><code> $ puppet epp validate template1.epp
 $ puppet epp validate ./template1.epp
</code></pre>

<p>Validate from STDIN:</p>

<pre><code>$ cat template.epp | puppet epp validate
</code></pre>

<p>Continue on error to see errors for all templates:</p>

<pre><code>$ puppet epp validate mymodule/template1.epp mymodule/template2.epp --continue_on_error
</code></pre>

<h2 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h2>

<p>Copyright 2014 by Puppet Inc.
Apache 2 license; see COPYING</p>

</div>
