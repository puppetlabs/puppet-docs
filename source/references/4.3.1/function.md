---
layout: default
built_from_commit: f223e717763aa79a28314425fa6917eb57ec3af8
title: Function Reference
toc: columns
canonical: /references/latest/function.html
---





**This page is autogenerated; any changes will get overwritten** *(last generated on 2016-01-14 14:50:46 -0800)*


There are two types of functions in Puppet: Statements and rvalues.
Statements stand on their own and do not return arguments; they are used for
performing stand-alone work like importing.  Rvalues return values and can
only be used in a statement requiring a value, such as an assignment or a case
statement.

Functions execute on the Puppet master.  They do not execute on the Puppet agent.
Hence they only have access to the commands and data available on the Puppet master
host.

Here are the functions available in Puppet:

abs
---
Returns the absolute value of a number, for example -34.56 becomes
34.56. Takes a single integer and float value as an argument.

- *Type*: rvalue

alert
-----
Log a message on the server at level alert.

- *Type*: statement

any2array
---------
This converts any object to an array containing that object. Empty argument
lists are converted to an empty array. Arrays are left untouched. Hashes are
converted to arrays of alternating keys and values.

- *Type*: rvalue

assert_private
--------------
Sets the current class or definition as private.
Calling the class or definition from outside the current module will fail.

- *Type*: statement

assert_type
-----------
Returns the given value if it is of the given
[data type](https://docs.puppetlabs.com/puppet/latest/reference/lang_data.html), or
otherwise either raises an error or executes an optional two-parameter
[lambda](https://docs.puppetlabs.com/puppet/latest/reference/lang_lambdas.html).

The function takes two mandatory arguments, in this order:

1. The expected data type.
2. A value to compare against the expected data type.

**Example**: Using `assert_type`

~~~ puppet
$raw_username = 'Amy Berry'

# Assert that $raw_username is a non-empty string and assign it to $valid_username.
$valid_username = assert_type(String[1], $raw_username)

# $valid_username contains "Amy Berry".
# If $raw_username was an empty string or a different data type, the Puppet run would
# fail with an "Expected type does not match actual" error.
~~~

You can use an optional lambda to provide enhanced feedback. The lambda takes two
mandatory parameters, in this order:

1. The expected data type as described in the function's first argument.
2. The actual data type of the value.

**Example**: Using `assert_type` with a warning and default value

~~~ puppet
$raw_username = 'Amy Berry'

# Assert that $raw_username is a non-empty string and assign it to $valid_username.
# If it isn't, output a warning describing the problem and use a default value.
$valid_username = assert_type(String[1], $raw_username) |$expected, $actual| {
  warning( "The username should be '${expected}', not '${actual}'. Using 'anonymous'." )
  'anonymous'
}

# $valid_username contains "Amy Berry".
# If $raw_username was an empty string, the Puppet run would set $valid_username to
# "anonymous" and output a warning: "The username should be 'String[1, default]', not
# 'String[0, 0]'. Using 'anonymous'."
~~~

For more information about data types, see the
[documentation](https://docs.puppetlabs.com/puppet/latest/reference/lang_data.html).

- Since 4.0.0

- *Type*: rvalue

base64
------

Base64 encode or decode a string based on the command and the string submitted

Usage:

  $encodestring = base64('encode','thestring')
  $decodestring = base64('decode','dGhlc3RyaW5n')

- *Type*: rvalue

basename
--------
Strips directory (and optional suffix) from a filename

- *Type*: rvalue

bool2httpd
----------
Transform a supposed boolean to On or Off. Pass all other values through.
Given a nil value (undef), bool2httpd will return 'Off'

Example:

    $trace_enable     = false
    $server_signature = 'mail'

    bool2httpd($trace_enable)
    # => 'Off'
    bool2httpd($server_signature)
    # => 'mail'
    bool2httpd(undef)
    # => 'Off'

- *Type*: rvalue

bool2num
--------
Converts a boolean to a number. Converts the values:
  false, f, 0, n, and no to 0
  true, t, 1, y, and yes to 1
Requires a single boolean or string as an input.

- *Type*: rvalue

bool2str
--------
Converts a boolean to a string.
Requires a single boolean as an input.

- *Type*: rvalue

camelcase
---------
Converts the case of a string or all strings in an array to camel case.

- *Type*: rvalue

capitalize
----------
Capitalizes the first letter of a string or array of strings.
Requires either a single string or an array as an input.

- *Type*: rvalue

ceiling
-------
Returns the smallest integer greater or equal to the argument.
Takes a single numeric value as an argument.

- *Type*: rvalue

chomp
-----
Removes the record separator from the end of a string or an array of
strings, for example `hello\n` becomes `hello`.
Requires a single string or array as an input.

- *Type*: rvalue

chop
----
Returns a new string with the last character removed. If the string ends
with `\r\n`, both characters are removed. Applying chop to an empty
string returns an empty string. If you wish to merely remove record
separators then you should use the `chomp` function.
Requires a string or array of strings as input.

- *Type*: rvalue

concat
------
Appends the contents of multiple arrays into array 1.

*Example:*

    concat(['1','2','3'],['4','5','6'],['7','8','9'])

Would result in:

  ['1','2','3','4','5','6','7','8','9']

- *Type*: rvalue

concat_getparam
---------------
Takes a resource reference and name of the parameter and
returns value of resource's parameter.

*Examples:*

    define example_resource($param) {
    }

    example_resource { "example_resource_instance":
        param => "param_value"
    }

    concat_getparam(Example_resource["example_resource_instance"], "param")

Would return: param_value

- *Type*: rvalue

concat_is_bool
--------------
Returns true if the variable passed to this function is a boolean.

- *Type*: rvalue

contain
-------
Contain one or more classes inside the current class. If any of
these classes are undeclared, they will be declared as if called with the
`include` function. Accepts a class name, an array of class names, or a
comma-separated list of class names.

A contained class will not be applied before the containing class is
begun, and will be finished before the containing class is finished.

You must use the class's full name;
relative names are not allowed. In addition to names in string form,
you may also directly use Class and Resource Type values that are produced by
evaluating resource and relationship expressions.

- Since 4.0.0 support for Class and Resource Type values, absolute names

- *Type*: statement

convert_base
------------

Converts a given integer or base 10 string representing an integer to a specified base, as a string.

Usage:

  $binary_repr = convert_base(5, 2)  # $binary_repr is now set to "101"
  $hex_repr = convert_base("254", "16")  # $hex_repr is now set to "fe"

- *Type*: rvalue

count
-----
Takes an array as first argument and an optional second argument.
Count the number of elements in array that matches second argument.
If called with only an array it counts the number of elements that are not nil/undef.

- *Type*: rvalue

create_resources
----------------
Converts a hash into a set of resources and adds them to the catalog.

This function takes two mandatory arguments: a resource type, and a hash describing
a set of resources. The hash should be in the form `{title => {parameters} }`:

    # A hash of user resources:
    $myusers = {
      'nick' => { uid    => '1330',
                  gid    => allstaff,
                  groups => ['developers', 'operations', 'release'], },
      'dan'  => { uid    => '1308',
                  gid    => allstaff,
                  groups => ['developers', 'prosvc', 'release'], },
    }

    create_resources(user, $myusers)

A third, optional parameter may be given, also as a hash:

    $defaults = {
      'ensure'   => present,
      'provider' => 'ldap',
    }

    create_resources(user, $myusers, $defaults)

The values given on the third argument are added to the parameters of each resource
present in the set given on the second argument. If a parameter is present on both
the second and third arguments, the one on the second argument takes precedence.

This function can be used to create defined resources and classes, as well
as native resources.

Virtual and Exported resources may be created by prefixing the type name
with @ or @@ respectively.  For example, the $myusers hash may be exported
in the following manner:

    create_resources("@@user", $myusers)

The $myusers may be declared as virtual resources using:

    create_resources("@user", $myusers)

- *Type*: statement

crit
----
Log a message on the server at level crit.

- *Type*: statement

debug
-----
Log a message on the server at level debug.

- *Type*: statement

deep_merge
----------
Recursively merges two or more hashes together and returns the resulting hash.

For example:

    $hash1 = {'one' => 1, 'two' => 2, 'three' => { 'four' => 4 } }
    $hash2 = {'two' => 'dos', 'three' => { 'five' => 5 } }
    $merged_hash = deep_merge($hash1, $hash2)
    # The resulting hash is equivalent to:
    # $merged_hash = { 'one' => 1, 'two' => 'dos', 'three' => { 'four' => 4, 'five' => 5 } }

When there is a duplicate key that is a hash, they are recursively merged.
When there is a duplicate key that is not a hash, the key in the rightmost hash will "win."

- *Type*: rvalue

defined
-------
Determines whether a given class or resource type is defined and returns a Boolean
value. You can also use `defined` to determine whether a specific resource is defined,
or whether a variable has a value (including `undef`, as opposed to the variable never
being declared or assigned).

This function takes at least one string argument, which can be a class name, type name,
resource reference, or variable reference of the form `'$name'`.

The `defined` function checks both native and defined types, including types
provided by modules. Types and classes are matched by their names. The function matches
resource declarations by using resource references.

**Examples**: Different types of `defined` function matches

~~~ puppet
# Matching resource types
defined("file")
defined("customtype")

# Matching defines and classes
defined("foo")
defined("foo::bar")

# Matching variables
defined('$name')

# Matching declared resources
defined(File['/tmp/file'])
~~~

Puppet depends on the configuration's evaluation order when checking whether a resource
is declared.

**Example**: Importance of evaluation order when using `defined`

~~~ puppet
# Assign values to $is_defined_before and $is_defined_after using identical `defined`
# functions.

$is_defined_before = defined(File['/tmp/file'])

file { "/tmp/file":
  ensure => present,
}

$is_defined_after = defined(File['/tmp/file'])

# $is_defined_before returns false, but $is_defined_after returns true.
~~~

This order requirement only refers to evaluation order. The order of resources in the
configuration graph (e.g. with `before` or `require`) does not affect the `defined`
function's behavior.

> **Warning:** Avoid relying on the result of the `defined` function in modules, as you
> might not be able to guarantee the evaluation order well enough to produce consistent
> results. This can cause other code that relies on the function's result to behave
> inconsistently or fail.

If you pass more than one argument to `defined`, the function returns `true` if _any_
of the arguments are defined. You can also match resources by type, allowing you to
match conditions of different levels of specificity, such as whether a specific resource
is of a specific data type.

**Example**: Matching multiple resources and resources by different types with `defined`

~~~ puppet
file { "/tmp/file1":
  ensure => file,
}

$tmp_file = file { "/tmp/file2":
  ensure => file,
}

# Each of these statements return `true` ...
defined(File['/tmp/file1'])
defined(File['/tmp/file1'],File['/tmp/file2'])
defined(File['/tmp/file1'],File['/tmp/file2'],File['/tmp/file3'])
# ... but this returns `false`.
defined(File['/tmp/file3'])

# Each of these statements returns `true` ...
defined(Type[Resource['file','/tmp/file2']])
defined(Resource['file','/tmp/file2'])
defined(File['/tmp/file2'])
defined('$tmp_file')
# ... but each of these returns `false`.
defined(Type[Resource['exec','/tmp/file2']])
defined(Resource['exec','/tmp/file2'])
defined(File['/tmp/file3'])
defined('$tmp_file2')
~~~

- Since 2.7.0
- Since 3.6.0 variable reference and future parser types
- Since 3.8.1 type specific requests with future parser
- Since 4.0.0

- *Type*: rvalue

defined_with_params
-------------------
Takes a resource reference and an optional hash of attributes.

Returns true if a resource with the specified attributes has already been added
to the catalog, and false otherwise.

    user { 'dan':
      ensure => present,
    }

    if ! defined_with_params(User[dan], {'ensure' => 'present' }) {
      user { 'dan': ensure => present, }
    }

- *Type*: rvalue

delete
------
Deletes all instances of a given element from an array, substring from a
string, or key from a hash.

*Examples:*

    delete(['a','b','c','b'], 'b')
    Would return: ['a','c']

    delete({'a'=>1,'b'=>2,'c'=>3}, 'b')
    Would return: {'a'=>1,'c'=>3}

    delete({'a'=>1,'b'=>2,'c'=>3}, ['b','c'])
    Would return: {'a'=>1}

    delete('abracadabra', 'bra')
    Would return: 'acada'

- *Type*: rvalue

delete_at
---------
Deletes a determined indexed value from an array.

*Examples:*

    delete_at(['a','b','c'], 1)

Would return: ['a','c']

- *Type*: rvalue

delete_undef_values
-------------------
Returns a copy of input hash or array with all undefs deleted.

*Examples:*

    $hash = delete_undef_values({a=>'A', b=>'', c=>undef, d => false})

Would return: {a => 'A', b => '', d => false}

    $array = delete_undef_values(['A','',undef,false])

Would return: ['A','',false]

- *Type*: rvalue

delete_values
-------------
Deletes all instances of a given value from a hash.

*Examples:*

    delete_values({'a'=>'A','b'=>'B','c'=>'C','B'=>'D'}, 'B')

Would return: {'a'=>'A','c'=>'C','B'=>'D'}

- *Type*: rvalue

difference
----------
This function returns the difference between two arrays.
The returned array is a copy of the original array, removing any items that
also appear in the second array.

*Examples:*

    difference(["a","b","c"],["b","c","d"])

Would return: ["a"]

- *Type*: rvalue

digest
------
Returns a hash value from a provided string using the digest_algorithm setting from the Puppet config file.

- *Type*: rvalue

dirname
-------
Returns the dirname of a path.

- *Type*: rvalue

dos2unix
--------
Returns the Unix version of the given string.
Takes a single string argument.

- *Type*: rvalue

downcase
--------
Converts the case of a string or all strings in an array to lower case.

- *Type*: rvalue

each
----
Runs a [lambda](http://docs.puppetlabs.com/puppet/latest/reference/lang_lambdas.html)
repeatedly using each value in a data structure, then returns the values unchanged.

This function takes two mandatory arguments, in this order:

1. An array or hash the function will iterate over.
2. A lambda, which the function calls for each element in the first argument. It can
request one or two parameters.

**Example**: Using the `each` function

`$data.each |$parameter| { <PUPPET CODE BLOCK> }`

or

`each($data) |$parameter| { <PUPPET CODE BLOCK> }`

When the first argument (`$data` in the above example) is an array, Puppet passes each
value in turn to the lambda, then returns the original values.

**Example**: Using the `each` function with an array and a one-parameter lambda

~~~ puppet
# For the array $data, run a lambda that creates a resource for each item.
$data = ["routers", "servers", "workstations"]
$data.each |$item| {
 notify { $item:
   message => $item
 }
}
# Puppet creates one resource for each of the three items in $data. Each resource is
# named after the item's value and uses the item's value in a parameter.
~~~

When the first argument is a hash, Puppet passes each key and value pair to the lambda
as an array in the form `[key, value]` and returns the original hash.

**Example**: Using the `each` function with a hash and a one-parameter lambda

~~~ puppet
# For the hash $data, run a lambda using each item as a key-value array that creates a
# resource for each item.
$data = {"rtr" => "Router", "svr" => "Server", "wks" => "Workstation"}
$data.each |$items| {
 notify { $items[0]:
   message => $items[1]
 }
}
# Puppet creates one resource for each of the three items in $data, each named after the
# item's key and containing a parameter using the item's value.
~~~

When the first argument is an array and the lambda has two parameters, Puppet passes the
array's indexes (enumerated from 0) in the first parameter and its values in the second
parameter.

**Example**: Using the `each` function with an array and a two-parameter lambda

~~~ puppet
# For the array $data, run a lambda using each item's index and value that creates a
# resource for each item.
$data = ["routers", "servers", "workstations"]
$data.each |$index, $value| {
 notify { $value:
   message => $index
 }
}
# Puppet creates one resource for each of the three items in $data, each named after the
# item's value and containing a parameter using the item's index.
~~~

When the first argument is a hash, Puppet passes its keys to the first parameter and its
values to the second parameter.

**Example**: Using the `each` function with a hash and a two-parameter lambda

~~~ puppet
# For the hash $data, run a lambda using each item's key and value to create a resource
# for each item.
$data = {"rtr" => "Router", "svr" => "Server", "wks" => "Workstation"}
$data.each |$key, $value| {
 notify { $key:
   message => $value
 }
}
# Puppet creates one resource for each of the three items in $data, each named after the
# item's key and containing a parameter using the item's value.
~~~

For an example that demonstrates how to create multiple `file` resources using `each`,
see the Puppet
[iteration](https://docs.puppetlabs.com/puppet/latest/reference/lang_iteration.html)
documentation.

- Since 4.0.0

- *Type*: rvalue

emerg
-----
Log a message on the server at level emerg.

- *Type*: statement

empty
-----
Returns true if the variable is empty.

- *Type*: rvalue

ensure_packages
---------------
Takes a list of packages and only installs them if they don't already exist.
It optionally takes a hash as a second parameter that will be passed as the
third argument to the ensure_resource() function.

- *Type*: statement

ensure_resource
---------------
Takes a resource type, title, and a list of attributes that describe a
resource.

    user { 'dan':
      ensure => present,
    }

This example only creates the resource if it does not already exist:

    ensure_resource('user', 'dan', {'ensure' => 'present' })

If the resource already exists but does not match the specified parameters,
this function will attempt to recreate the resource leading to a duplicate
resource definition error.

An array of resources can also be passed in and each will be created with
the type and parameters specified if it doesn't already exist.

    ensure_resource('user', ['dan','alex'], {'ensure' => 'present'})

- *Type*: statement

epp
---
Evaluates an Embedded Puppet (EPP) template file and returns the rendered text
result as a String.

`epp('<MODULE NAME>/<TEMPLATE FILE>', <PARAMETER HASH>)`

The first argument to this function should be a `<MODULE NAME>/<TEMPLATE FILE>`
reference, which loads `<TEMPLATE FILE>` from `<MODULE NAME>`'s `templates`
directory. In most cases, the last argument is optional; if used, it should be a
[hash](/puppet/latest/reference/lang_data_hash.html) that contains parameters to
pass to the template.

- See the [template](/puppet/latest/reference/lang_template.html) documentation
for general template usage information.
- See the [EPP syntax](/puppet/latest/reference/lang_template_epp.html)
documentation for examples of EPP.

For example, to call the apache module's `templates/vhost/_docroot.epp`
template and pass the `docroot` and `virtual_docroot` parameters, call the `epp`
function like this:

`epp('apache/templates/vhost/_docroot.epp', { 'docroot' => '/var/www/html',
'virtual_docroot' => '/var/www/example' })`

Puppet produces a syntax error if you pass more parameters than are declared in
the template's parameter tag. When passing parameters to a template that
contains a parameter tag, use the same names as the tag's declared parameters.

Parameters are required only if they are declared in the called template's
parameter tag without default values. Puppet produces an error if the `epp`
function fails to pass any required parameter.

- Since 4.0.0

- *Type*: rvalue

err
---
Log a message on the server at level err.

- *Type*: statement

fail
----
Fail with a parse error.

- *Type*: statement

file
----
Loads a file from a module and returns its contents as a string.

The argument to this function should be a `<MODULE NAME>/<FILE>`
reference, which will load `<FILE>` from a module's `files`
directory. (For example, the reference `mysql/mysqltuner.pl` will load the
file `<MODULES DIRECTORY>/mysql/files/mysqltuner.pl`.)

This function can also accept:

* An absolute path, which can load a file from anywhere on disk.
* Multiple arguments, which will return the contents of the **first** file
found, skipping any files that don't exist.

- *Type*: rvalue

filter
------
Applies a [lambda](http://docs.puppetlabs.com/puppet/latest/reference/lang_lambdas.html)
to every value in a data structure and returns an array or hash containing any elements
for which the lambda evaluates to `true`.

This function takes two mandatory arguments, in this order:

1. An array or hash the function will iterate over.
2. A lambda, which the function calls for each element in the first argument. It can
request one or two parameters.

**Example**: Using the `filter` function

`$filtered_data = $data.filter |$parameter| { <PUPPET CODE BLOCK> }`

or

`$filtered_data = filter($data) |$parameter| { <PUPPET CODE BLOCK> }`

When the first argument (`$data` in the above example) is an array, Puppet passes each
value in turn to the lambda and returns an array containing the results.

**Example**: Using the `filter` function with an array and a one-parameter lambda

~~~ puppet
# For the array $data, return an array containing the values that end with "berry"
$data = ["orange", "blueberry", "raspberry"]
$filtered_data = $data.filter |$items| { $items =~ /berry$/ }
# $filtered_data = [blueberry, raspberry]
~~~

When the first argument is a hash, Puppet passes each key and value pair to the lambda
as an array in the form `[key, value]` and returns a hash containing the results.

**Example**: Using the `filter` function with a hash and a one-parameter lambda

~~~ puppet
# For the hash $data, return a hash containing all values of keys that end with "berry"
$data = { "orange" => 0, "blueberry" => 1, "raspberry" => 2 }
$filtered_data = $data.filter |$items| { $items[0] =~ /berry$/ }
# $filtered_data = {blueberry => 1, raspberry => 2}

When the first argument is an array and the lambda has two parameters, Puppet passes the
array's indexes (enumerated from 0) in the first parameter and its values in the second
parameter.

**Example**: Using the `filter` function with an array and a two-parameter lambda

~~~ puppet
# For the array $data, return an array of all keys that both end with "berry" and have
# an even-numbered index
$data = ["orange", "blueberry", "raspberry"]
$filtered_data = $data.filter |$indexes, $values| { $indexes % 2 == 0 and $values =~ /berry$/ }
# $filtered_data = [raspberry]
~~~

When the first argument is a hash, Puppet passes its keys to the first parameter and its
values to the second parameter.

**Example**: Using the `filter` function with a hash and a two-parameter lambda

~~~ puppet
# For the hash $data, return a hash of all keys that both end with "berry" and have
# values less than or equal to 1
$data = { "orange" => 0, "blueberry" => 1, "raspberry" => 2 }
$filtered_data = $data.filter |$keys, $values| { $keys =~ /berry$/ and $values <= 1 }
# $filtered_data = {blueberry => 1}
~~~

- Since 4.0.0

- *Type*: rvalue

flatten
-------
This function flattens any deeply nested arrays and returns a single flat array
as a result.

*Examples:*

    flatten(['a', ['b', ['c']]])

Would return: ['a','b','c']

- *Type*: rvalue

floor
-----
Returns the largest integer less or equal to the argument.
Takes a single numeric value as an argument.

- *Type*: rvalue

fqdn_rand
---------
Usage: `fqdn_rand(MAX, [SEED])`. MAX is required and must be a positive
integer; SEED is optional and may be any number or string.

Generates a random Integer number greater than or equal to 0 and less than MAX,
combining the `$fqdn` fact and the value of SEED for repeatable randomness.
(That is, each node will get a different random number from this function, but
a given node's result will be the same every time unless its hostname changes.)

This function is usually used for spacing out runs of resource-intensive cron
tasks that run on many nodes, which could cause a thundering herd or degrade
other services if they all fire at once. Adding a SEED can be useful when you
have more than one such task and need several unrelated random numbers per
node. (For example, `fqdn_rand(30)`, `fqdn_rand(30, 'expensive job 1')`, and
`fqdn_rand(30, 'expensive job 2')` will produce totally different numbers.)

- *Type*: rvalue

fqdn_rand_string
----------------
Usage: `fqdn_rand_string(LENGTH, [CHARSET], [SEED])`. LENGTH is
required and must be a positive integer. CHARSET is optional and may be
`undef` or a string. SEED is optional and may be any number or string.

Generates a random string LENGTH characters long using the character set
provided by CHARSET, combining the `$fqdn` fact and the value of SEED for
repeatable randomness. (That is, each node will get a different random
string from this function, but a given node's result will be the same every
time unless its hostname changes.) Adding a SEED can be useful if you need
more than one unrelated string. CHARSET will default to alphanumeric if
`undef` or an empty string.

- *Type*: rvalue

fqdn_rotate
-----------
Usage: `fqdn_rotate(VALUE, [SEED])`. VALUE is required and
must be an array or a string. SEED is optional and may be any number
or string.

Rotates VALUE a random number of times, combining the `$fqdn` fact and
the value of SEED for repeatable randomness. (That is, each node will
get a different random rotation from this function, but a given node's
result will be the same every time unless its hostname changes.) Adding
a SEED can be useful if you need more than one unrelated rotation.

- *Type*: rvalue

generate
--------
Calls an external command on the Puppet master and returns
the results of the command.  Any arguments are passed to the external command as
arguments.  If the generator does not exit with return code of 0,
the generator is considered to have failed and a parse error is
thrown.  Generators can only have file separators, alphanumerics, dashes,
and periods in them.  This function will attempt to protect you from
malicious generator calls (e.g., those with '..' in them), but it can
never be entirely safe.  No subshell is used to execute
generators, so all shell metacharacters are passed directly to
the generator.

- *Type*: rvalue

get_module_path
---------------
Returns the absolute path of the specified module for the current
environment.

Example:
  $module_path = get_module_path('stdlib')

- *Type*: rvalue

getparam
--------
Takes a resource reference and name of the parameter and
returns value of resource's parameter.

*Examples:*

    define example_resource($param) {
    }

    example_resource { "example_resource_instance":
        param => "param_value"
    }

    getparam(Example_resource["example_resource_instance"], "param")

Would return: param_value

- *Type*: rvalue

getvar
------
Lookup a variable in a remote namespace.

For example:

    $foo = getvar('site::data::foo')
    # Equivalent to $foo = $site::data::foo

This is useful if the namespace itself is stored in a string:

    $datalocation = 'site::data'
    $bar = getvar("${datalocation}::bar")
    # Equivalent to $bar = $site::data::bar

- *Type*: rvalue

grep
----
This function searches through an array and returns any elements that match
the provided regular expression.

*Examples:*

    grep(['aaa','bbb','ccc','aaaddd'], 'aaa')

Would return:

    ['aaa','aaaddd']

- *Type*: rvalue

has_interface_with
------------------
Returns boolean based on kind and value:
  * macaddress
  * netmask
  * ipaddress
  * network

has_interface_with("macaddress", "x:x:x:x:x:x")
has_interface_with("ipaddress", "127.0.0.1")    => true
etc.

If no "kind" is given, then the presence of the interface is checked:
has_interface_with("lo")                        => true

- *Type*: rvalue

has_ip_address
--------------
Returns true if the client has the requested IP address on some interface.

This function iterates through the 'interfaces' fact and checks the
'ipaddress_IFACE' facts, performing a simple string comparison.

- *Type*: rvalue

has_ip_network
--------------
Returns true if the client has an IP address within the requested network.

This function iterates through the 'interfaces' fact and checks the
'network_IFACE' facts, performing a simple string comparision.

- *Type*: rvalue

has_key
-------
Determine if a hash has a certain key value.

Example:

    $my_hash = {'key_one' => 'value_one'}
    if has_key($my_hash, 'key_two') {
      notice('we will not reach here')
    }
    if has_key($my_hash, 'key_one') {
      notice('this will be printed')
    }

- *Type*: rvalue

hash
----
This function converts an array into a hash.

*Examples:*

    hash(['a',1,'b',2,'c',3])

Would return: {'a'=>1,'b'=>2,'c'=>3}

- *Type*: rvalue

hiera
-----
Performs a standard priority lookup of the hierarchy and returns the most specific value
for a given key. The returned value can be any type of data.

The function takes up to three arguments, in this order:

1. A string key that Hiera searches for in the hierarchy. **Required**.
2. An optional default value to return if Hiera doesn't find anything matching the key.
    * If this argument isn't provided and this function results in a lookup failure, Puppet
    fails with a compilation error.
3. The optional name of an arbitrary
[hierarchy level](https://docs.puppetlabs.com/hiera/latest/hierarchy.html) to insert at the
top of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.
    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues
    searching the rest of the hierarchy.

The `hiera` function does **not** find all matches throughout a hierarchy, instead
returining the first specific value starting at the top of the hierarchy. To search
throughout a hierarchy, use the `hiera_array` or `hiera_hash` functions.

**Example**: Using `hiera`

~~~ yaml
# Assuming hiera.yaml
# :hierarchy:
#   - web01.example.com
#   - common

# Assuming web01.example.com.yaml:
# users:
#   - "Amy Barry"
#   - "Carrie Douglas"

# Assuming common.yaml:
users:
  admins:
    - "Edith Franklin"
    - "Ginny Hamilton"
  regular:
    - "Iris Jackson"
    - "Kelly Lambert"
~~~

~~~ puppet
# Assuming we are not web01.example.com:

$users = hiera('users', undef)

# $users contains {admins  => ["Edith Franklin", "Ginny Hamilton"],
#                  regular => ["Iris Jackson", "Kelly Lambert"]}
~~~

You can optionally generate the default value with a
[lambda](https://docs.puppetlabs.com/puppet/latest/reference/lang_lambdas.html) that
takes one parameter.

**Example**: Using `hiera` with a lambda

~~~ puppet
# Assuming the same Hiera data as the previous example:

$users = hiera('users') | $key | { "Key '${key}' not found" }

# $users contains {admins  => ["Edith Franklin", "Ginny Hamilton"],
#                  regular => ["Iris Jackson", "Kelly Lambert"]}
# If hiera couldn't match its key, it would return the lambda result,
# "Key 'users' not found".
~~~

The returned value's data type depends on the types of the results. In the example
above, Hiera matches the 'users' key and returns it as a hash.

See
[the documentation](https://docs.puppetlabs.com/hiera/latest/puppet.html#hiera-lookup-functions)
for more information about Hiera lookup functions.

- Since 4.0.0

- *Type*: rvalue

hiera_array
-----------
Finds all matches of a key throughout the hierarchy and returns them as a single flattened
array of unique values. If any of the matched values are arrays, they're flattened and
included in the results. This is called an
[array merge lookup](https://docs.puppetlabs.com/hiera/latest/lookup_types.html#array-merge).

The `hiera_array` function takes up to three arguments, in this order:

1. A string key that Hiera searches for in the hierarchy. **Required**.
2. An optional default value to return if Hiera doesn't find anything matching the key.
    * If this argument isn't provided and this function results in a lookup failure, Puppet
    fails with a compilation error.
3. The optional name of an arbitrary
[hierarchy level](https://docs.puppetlabs.com/hiera/latest/hierarchy.html) to insert at the
top of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.
    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues
    searching the rest of the hierarchy.

**Example**: Using `hiera_array`

~~~ yaml
# Assuming hiera.yaml
# :hierarchy:
#   - web01.example.com
#   - common

# Assuming common.yaml:
# users:
#   - 'cdouglas = regular'
#   - 'efranklin = regular'

# Assuming web01.example.com.yaml:
# users: 'abarry = admin'
~~~

~~~ puppet
$allusers = hiera_array('users', undef)

# $allusers contains ["cdouglas = regular", "efranklin = regular", "abarry = admin"].
~~~

You can optionally generate the default value with a
[lambda](https://docs.puppetlabs.com/puppet/latest/reference/lang_lambdas.html) that
takes one parameter.

**Example**: Using `hiera_array` with a lambda

~~~ puppet
# Assuming the same Hiera data as the previous example:

$allusers = hiera_array('users') | $key | { "Key '${key}' not found" }

# $allusers contains ["cdouglas = regular", "efranklin = regular", "abarry = admin"].
# If hiera_array couldn't match its key, it would return the lambda result,
# "Key 'users' not found".
~~~

`hiera_array` expects that all values returned will be strings or arrays. If any matched
value is a hash, Puppet raises a type mismatch error.

See
[the documentation](https://docs.puppetlabs.com/hiera/latest/puppet.html#hiera-lookup-functions)
for more information about Hiera lookup functions.

- Since 4.0.0

- *Type*: rvalue

hiera_hash
----------
Finds all matches of a key throughout the hierarchy and returns them in a merged hash.
If any of the matched hashes share keys, the final hash uses the value from the
highest priority match. This is called a
[hash merge lookup](https://docs.puppetlabs.com/hiera/latest/lookup_types.html#hash-merge).

The merge strategy is determined by Hiera's
[`:merge_behavior`](https://docs.puppetlabs.com/hiera/latest/configuring.html#mergebehavior)
setting.

The `hiera_hash` function takes up to three arguments, in this order:

1. A string key that Hiera searches for in the hierarchy. **Required**.
2. An optional default value to return if Hiera doesn't find anything matching the key.
    * If this argument isn't provided and this function results in a lookup failure, Puppet
    fails with a compilation error.
3. The optional name of an arbitrary
[hierarchy level](https://docs.puppetlabs.com/hiera/latest/hierarchy.html) to insert at the
top of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.
    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues
    searching the rest of the hierarchy.

**Example**: Using `hiera_hash`

~~~ yaml
# Assuming hiera.yaml
# :hierarchy:
#   - web01.example.com
#   - common

# Assuming common.yaml:
# users:
#   regular:
#     'cdouglas': 'Carrie Douglas'

# Assuming web01.example.com.yaml:
# users:
#   administrators:
#     'aberry': 'Amy Berry'
~~~

~~~ puppet
# Assuming we are not web01.example.com:

$allusers = hiera_hash('users', undef)

# $allusers contains {regular => {"cdouglas" => "Carrie Douglas"},
#                     administrators => {"aberry" => "Amy Berry"}}
~~~

You can optionally generate the default value with a
[lambda](https://docs.puppetlabs.com/puppet/latest/reference/lang_lambdas.html) that
takes one parameter.

**Example**: Using `hiera_hash` with a lambda

~~~ puppet
# Assuming the same Hiera data as the previous example:

$allusers = hiera_hash('users') | $key | { "Key '${key}' not found" }

# $allusers contains {regular => {"cdouglas" => "Carrie Douglas"},
#                     administrators => {"aberry" => "Amy Berry"}}
# If hiera_hash couldn't match its key, it would return the lambda result,
# "Key 'users' not found".
~~~

`hiera_hash` expects that all values returned will be hashes. If any of the values
found in the data sources are strings or arrays, Puppet raises a type mismatch error.

See
[the documentation](https://docs.puppetlabs.com/hiera/latest/puppet.html#hiera-lookup-functions)
for more information about Hiera lookup functions.

- Since 4.0.0

- *Type*: rvalue

hiera_include
-------------
Assigns classes to a node using an
[array merge lookup](https://docs.puppetlabs.com/hiera/latest/lookup_types.htmlarray-merge)
that retrieves the value for a user-specified key from Hiera's data.

The `hiera_include` function requires:

- A string key name to use for classes.
- A call to this function (i.e. `hiera_include('classes')`) in your environment's
`sites.pp` manifest, outside of any node definitions and below any top-scope variables
that Hiera uses in lookups.
- `classes` keys in the appropriate Hiera data sources, with an array for each
`classes` key and each value of the array containing the name of a class.

The function takes up to three arguments, in this order:

1. A string key that Hiera searches for in the hierarchy. **Required**.
2. An optional default value to return if Hiera doesn't find anything matching the key.
    * If this argument isn't provided and this function results in a lookup failure, Puppet
    fails with a compilation error.
3. The optional name of an arbitrary
[hierarchy level](https://docs.puppetlabs.com/hiera/latest/hierarchy.html) to insert at the
top of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.
    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues
    searching the rest of the hierarchy.

The function uses an
[array merge lookup](https://docs.puppetlabs.com/hiera/latest/lookup_types.htmlarray-merge)
to retrieve the `classes` array, so every node gets every class from the hierarchy.

**Example**: Using `hiera_include`

~~~ yaml
# Assuming hiera.yaml
# :hierarchy:
#   - web01.example.com
#   - common

# Assuming web01.example.com.yaml:
# classes:
#   - apache::mod::php

# Assuming common.yaml:
# classes:
#   - apache
~~~

~~~ puppet
# In site.pp, outside of any node definitions and below any top-scope variables:
hiera_include('classes', undef)

# Puppet assigns the apache and apache::mod::php classes to the web01.example.com node.
~~~

You can optionally generate the default value with a
[lambda](https://docs.puppetlabs.com/puppet/latest/reference/lang_lambdas.html) that
takes one parameter.

**Example**: Using `hiera_include` with a lambda

~~~ puppet
# Assuming the same Hiera data as the previous example:

# In site.pp, outside of any node definitions and below any top-scope variables:
hiera_include('classes') | $key | {"Key '${key}' not found" }

# Puppet assigns the apache and apache::mod::php classes to the web01.example.com node.
# If hiera_include couldn't match its key, it would return the lambda result,
# "Key 'classes' not found".
~~~

See [the documentation](http://links.puppetlabs.com/hierainclude) for more information
and a more detailed example of how `hiera_include` uses array merge lookups to classify
nodes.

- Since 4.0.0

- *Type*: statement

include
-------
Declares one or more classes, causing the resources in them to be
evaluated and added to the catalog. Accepts a class name, an array of class
names, or a comma-separated list of class names.

The `include` function can be used multiple times on the same class and will
only declare a given class once. If a class declared with `include` has any
parameters, Puppet will automatically look up values for them in Hiera, using
`<class name>::<parameter name>` as the lookup key.

Contrast this behavior with resource-like class declarations
(`class {'name': parameter => 'value',}`), which must be used in only one place
per class and can directly set parameters. You should avoid using both `include`
and resource-like declarations with the same class.

The `include` function does not cause classes to be contained in the class
where they are declared. For that, see the `contain` function. It also
does not create a dependency relationship between the declared class and the
surrounding class; for that, see the `require` function.

You must use the class's full name;
relative names are not allowed. In addition to names in string form,
you may also directly use Class and Resource Type values that are produced by
the future parser's resource and relationship expressions.

- Since < 3.0.0
- Since 4.0.0 support for class and resource type values, absolute names

- *Type*: statement

info
----
Log a message on the server at level info.

- *Type*: statement

inline_epp
----------
Evaluates an Embedded Puppet (EPP) template string and returns the rendered
text result as a String.

`inline_epp('<EPP TEMPLATE STRING>', <PARAMETER HASH>)`

The first argument to this function should be a string containing an EPP
template. In most cases, the last argument is optional; if used, it should be a
[hash](/puppet/latest/reference/lang_data_hash.html) that contains parameters to
pass to the template.

- See the [template](/puppet/latest/reference/lang_template.html) documentation
for general template usage information.
- See the [EPP syntax](/puppet/latest/reference/lang_template_epp.html)
documentation for examples of EPP.

For example, to evaluate an inline EPP template and pass it the `docroot` and
`virtual_docroot` parameters, call the `inline_epp` function like this:

`inline_epp('docroot: <%= $docroot %> Virtual docroot: <%= $virtual_docroot %>',
{ 'docroot' => '/var/www/html', 'virtual_docroot' => '/var/www/example' })`

Puppet produces a syntax error if you pass more parameters than are declared in
the template's parameter tag. When passing parameters to a template that
contains a parameter tag, use the same names as the tag's declared parameters.

Parameters are required only if they are declared in the called template's
parameter tag without default values. Puppet produces an error if the
`inline_epp` function fails to pass any required parameter.

An inline EPP template should be written as a single-quoted string or
[heredoc](puppet/latest/reference/lang_data_string.html#heredocs).
A double-quoted string is subject to expression interpolation before the string
is parsed as an EPP template.

For example, to evaluate an inline EPP template using a heredoc, call the
`inline_epp` function like this:

~~~ puppet
# Outputs 'Hello given argument planet!'
inline_epp(@(END), { x => 'given argument' })
<%- | $x, $y = planet | -%>
Hello <%= $x %> <%= $y %>!
END
~~~

- Since 3.5
- Requires [future parser](/puppet/3.8/reference/experiments_future.html) in Puppet 3.5 to 3.8

- *Type*: rvalue

inline_template
---------------
Evaluate a template string and return its value.  See
[the templating docs](http://docs.puppetlabs.com/puppet/latest/reference/lang_template.html) for
more information. Note that if multiple template strings are specified, their
output is all concatenated and returned as the output of the function.

- *Type*: rvalue

intersection
------------
This function returns an array an intersection of two.

*Examples:*

    intersection(["a","b","c"],["b","c","d"])

Would return: ["b","c"]

- *Type*: rvalue

is_array
--------
Returns true if the variable passed to this function is an array.

- *Type*: rvalue

is_bool
-------
Returns true if the variable passed to this function is a boolean.

- *Type*: rvalue

is_domain_name
--------------
Returns true if the string passed to this function is a syntactically correct domain name.

- *Type*: rvalue

is_float
--------
Returns true if the variable passed to this function is a float.

- *Type*: rvalue

is_function_available
---------------------
This function accepts a string as an argument, determines whether the
Puppet runtime has access to a function by that name.  It returns a
true if the function exists, false if not.

- *Type*: rvalue

is_hash
-------
Returns true if the variable passed to this function is a hash.

- *Type*: rvalue

is_integer
----------
Returns true if the variable passed to this function is an Integer or
a decimal (base 10) integer in String form. The string may
start with a '-' (minus). A value of '0' is allowed, but a leading '0' digit may not
be followed by other digits as this indicates that the value is octal (base 8).

If given any other argument `false` is returned.

- *Type*: rvalue

is_ip_address
-------------
Returns true if the string passed to this function is a valid IP address.

- *Type*: rvalue

is_mac_address
--------------
Returns true if the string passed to this function is a valid mac address.

- *Type*: rvalue

is_numeric
----------
Returns true if the given argument is a Numeric (Integer or Float),
or a String containing either a valid integer in decimal base 10 form, or
a valid floating point string representation.

The function recognizes only decimal (base 10) integers and float but not
integers in hex (base 16) or octal (base 8) form.

The string representation may start with a '-' (minus). If a decimal '.' is used,
it must be followed by at least one digit.

Valid examples:

  77435
  10e-12
  -8475
  0.2343
  -23.561e3

- *Type*: rvalue

is_string
---------
Returns true if the variable passed to this function is a string.

- *Type*: rvalue

join
----
This function joins an array into a string using a separator.

*Examples:*

    join(['a','b','c'], ",")

Would result in: "a,b,c"

- *Type*: rvalue

join_keys_to_values
-------------------
This function joins each key of a hash to that key's corresponding value with a
separator. Keys and values are cast to strings. The return value is an array in
which each element is one joined key/value pair.

*Examples:*

    join_keys_to_values({'a'=>1,'b'=>2}, " is ")

Would result in: ["a is 1","b is 2"]

- *Type*: rvalue

keys
----
Returns the keys of a hash as an array.

- *Type*: rvalue

load_module_metadata
--------------------


- *Type*: rvalue

loadyaml
--------
Load a YAML file containing an array, string, or hash, and return the data
in the corresponding native data type.

For example:

    $myhash = loadyaml('/etc/puppet/data/myhash.yaml')

- *Type*: rvalue

lookup
------
Looks up data defined using Data Binding, and Data Providers using different strategies. The lookup searches in
Data Bindings first (if configured; typically Hiera), then in the environments data provider (if any), and last in
the module's data provider (if any) of the module the call to lookup originates from. Thus, the global Data Binding
has higher priority than data provided in the environment, which has higher priority than data provided in a module,

The lookup function can be called in one of these ways:

    lookup(name)
    lookup(name, value_type)
    lookup(name, value_type, merge)
    lookup(name, value_type, merge, default_value)
    lookup(options_hash)
    lookup(name, options_hash)

The function may optionally be called with a code block / lambda with the following signature:

    lookup(...) |$name| { ... }

The block, if present, is mutually exclusive to the `default_value` and will be called with the `name` used in the
lookup when no value is found. The value produced by the block then becomes the value produced by the lookup.

The meaning of the parameters or content of the options hash is:

* `name` - The name or array of names to lookup (first found is returned)
* `value_type` - The type to assert. Defaults to 'Data' See 'Type Specification' below.
* `default_value` - The default value if there was no value found (must comply with the data type)
* `override` - a hash with map from names to values that are used instead of the underlying bindings. If the name
  is found here it wins. Defaults to an empty hash.
* `default_values_hash` - a hash with map from names to values that are used as a last resort to obtain a value.
  Defaults to an empty hash.
* `merge` - A string of type Enum[unique, hash, merge] or a hash with the key 'strategy' set to that string. See
  'Merge Strategies' below.

It is not permitted to pass the `name` as both a parameter and in the options hash.

The search will proceed as follows:
1. For each name given in the `name` array (or once, if it's just one name):
  - If a matching key is found in the `override` hash, it's value is immediately type checked and returned
  - Search and optionally merge Data Binding, environment data providers, and module data providers
  - Type check and return the value if a matching key is found
2. For each name given in the `name` array (or once, if it's just one name):
  - Type check and return the value if a matching key is found in the `default_values_hash`
3. Type check and return either the given `default_value` or the result of calling the code block if either exist
4. Raise an error indicating that no matching value was found

*Merge Strategies*

The default behavior of the lookup is to return the first value that is found for the given `name`. The optional
`merge` parameter will change this so that a lookup makes an attempt to find values in all three sources (the Data
Binder, the environment, and the module scope) and then merge these values according to the given strategy. This
does not apply to values found in the 'override' hash. Such values are returned immediately without merging.
Note that `merge` is passed on to allow the underlying provider to return a merged result

The valid strategies are:
- 'hash' Performs a simple hash-merge by overwriting keys of lower lookup priority. Merged values must be of Hash type
- 'unique' Appends everything to an array containing no nested arrays and where all duplicates have been removed. Can
   append values of Scalar or Array[Scalar] type
- 'deep' Performs a deep merge on values of Array and Hash type. See documentation for the DeepMerge gem's deep_merge
   operation for details and options.

The 'deep' strategy can use additional options to control its behavior. Options can be passed as top level
keys in the `merge` parameter when it is a given as a hash. Recognized options are:
- 'knockout_prefix' Set to string value to signify prefix which deletes elements from existing element. Defaults is _undef_
- 'sort_merged_arrays' Set to _true_ to sort all arrays that are merged together. Default is _false_
- 'unpack_arrays' Set to string value used as a deliminator to join all array values and then split them again. Default is _undef_
- 'merge_hash_arrays' Set to _true_ to merge hashes within arrays. Default is _false_

*Type Specification*

The type specification is a type in the Puppet Type System, e.g.:
  * `Integer`, an integral value with optional range e.g.:
    * `Integer[0, default]` - 0 or positive
    * `Integer[default, -1]` - negative,
    * `Integer[1,100]` - value between 1 and 100 inclusive
  * `String`- any string
  * `Float` - floating point number (same signature as for Integer for `Integer` ranges)
  * `Boolean` - true of false (strict)
  * `Array` - an array (of Data by default), or parameterized as `Array[<element_type>]`, where
    `<element_type>` is the expected type of elements
  * `Hash`,  - a hash (of default `Literal` keys and `Data` values), or parameterized as
    `Hash[<value_type>]`, `Hash[<key_type>, <value_type>]`, where `<key_type>`, and
    `<value_type>` are the types of the keys and values respectively
    (key is `Literal` by default).
  * `Data` - abstract type representing any `Literal` (including _undef_), `Array[Data]`, or `Hash[Literal, Data]`
  * `Pattern[<p1>, <p2>, ..., <pn>]` - an enumeration of valid patterns (one or more) where
     a pattern is a regular expression string or regular expression,
     e.g. `Pattern['.com$', '.net$']`, `Pattern[/[a-z]+[0-9]+/]`
  * `Enum[<s1>, <s2>, ..., <sn>]`, - an enumeration of exact string values (one or more)
     e.g. `Enum[blue, red, green]`.
  * `Variant[<t1>, <t2>,...<tn>]` - matches one of the listed types (at least one must be given)
    e.g. `Variant[Integer[8000,8999], Integer[20000, 99999]]` to accept a value in either range
  * `Regexp`- a regular expression (i.e. the result is a regular expression, not a string
     matching a regular expression).

For more options and details about types, see the Puppet Language Reference

*Handling of undef*

When no match is found for the given `name` when searching all sources, (including the `override`and
`default_values_hash`), then the value used is either the `default_value` or the value produced by the given block.
If neither is provided, then the lookup will always raise an error. Note that this only applies when there's no
match for the given `name`. It does not happen when a value is found and that value happens to be _undef_.

*Validation of returned value*

The produced value is subject to type validation using the `value_type` (if given) and an error is raised unless
the resulting value is of correct type.

*Examples*

When called with one argument; **the name**, it
returns the bound value with the given name after having  asserted it has the default datatype `Data`:

    lookup('the_name')

When called with two arguments; **the name**, and **the expected type**, it
returns the bound value with the given name after having asserted it has the given data
type ('String' in the example):

    lookup('the_name', String)

When called with four arguments, **the name**, the **expected type**, the **merge** strategy, and a
**default value**, it returns the bound value with the given name, or the default after having asserted the value
has the given data type:

    lookup('the_name', String, undef, 'Fred')
    lookup('the_name', Array[String], 'unique', [Fred])

Using a lambda to provide a default value by calling a function:

    lookup('the_size', Integer[1,100]) |$name| {
      obtain_size_default()
    }

There are two ways to make lookup return undef when no matching key was found instead of raising an error.
Either call it with four arguments (the `merge` argument must be present even when using the default strategy
to ensure that the four argument variant is used):

     $are_you_there = lookup('peekaboo', Optional[String], undef, undef)

or call it using an options hash:

     $are_you_there = lookup('peekaboo', { 'default_value' => undef })
     $are_you_there = lookup({ 'name' => 'peekaboo', 'default_value' => undef })

or with a block that produces an undef value:

     $are_you_there = lookup('peekaboo', Optional[String]) |$name| { undef }

- Since 4.0.0

- *Type*: rvalue

lstrip
------
Strips leading spaces to the left of a string.

- *Type*: rvalue

map
---
Applies a [lambda](http://docs.puppetlabs.com/puppet/latest/reference/lang_lambdas.html)
to every value in a data structure and returns an array containing the results.

This function takes two mandatory arguments, in this order:

1. An array or hash the function will iterate over.
2. A lambda, which the function calls for each element in the first argument. It can
request one or two parameters.

**Example**: Using the `map` function

`$transformed_data = $data.map |$parameter| { <PUPPET CODE BLOCK> }`

or

`$transformed_data = map($data) |$parameter| { <PUPPET CODE BLOCK> }`

When the first argument (`$data` in the above example) is an array, Puppet passes each
value in turn to the lambda.

**Example**: Using the `map` function with an array and a one-parameter lambda

~~~ puppet
# For the array $data, return an array containing each value multiplied by 10
$data = [1,2,3]
$transformed_data = $data.map |$items| { $items * 10 }
# $transformed_data contains [10,20,30]
~~~

When the first argument is a hash, Puppet passes each key and value pair to the lambda
as an array in the form `[key, value]`.

**Example**: Using the `map` function with a hash and a one-parameter lambda

~~~ puppet
# For the hash $data, return an array containing the keys
$data = {'a'=>1,'b'=>2,'c'=>3}
$transformed_data = $data.map |$items| { $items[0] }
# $transformed_data contains ['a','b','c']
~~~

When the first argument is an array and the lambda has two parameters, Puppet passes the
array's indexes (enumerated from 0) in the first parameter and its values in the second
parameter.

**Example**: Using the `map` function with an array and a two-parameter lambda

~~~ puppet
# For the array $data, return an array containing the indexes
$data = [1,2,3]
$transformed_data = $data.map |$index,$value| { $index }
# $transformed_data contains [0,1,2]
~~~

When the first argument is a hash, Puppet passes its keys to the first parameter and its
values to the second parameter.

**Example**: Using the `map` function with a hash and a two-parameter lambda

~~~ puppet
# For the hash $data, return an array containing each value
$data = {'a'=>1,'b'=>2,'c'=>3}
$transformed_data = $data.map |$key,$value| { $value }
# $transformed_data contains [1,2,3]
~~~

- Since 4.0.0

- *Type*: rvalue

match
-----
Matches a regular expression against a string and returns an array containing the match
and any matched capturing groups.

The first argument is a string or array of strings. The second argument is either a
regular expression, regular expression represented as a string, or Regex or Pattern
data type that the function matches against the first argument.

The returned array contains the entire match at index 0, and each captured group at
subsequent index values. If the value or expression being matched is an array, the
function returns an array with mapped match results.

If the function doesn't find a match, it returns 'undef'.

**Example**: Matching a regular expression in a string

~~~ ruby
$matches = "abc123".match(/[a-z]+[1-9]+/)
# $matches contains [abc123]
~~~

**Example**: Matching a regular expressions with grouping captures in a string

~~~ ruby
$matches = "abc123".match(/([a-z]+)([1-9]+)/)
# $matches contains [abc123, abc, 123]
~~~

**Example**: Matching a regular expression with grouping captures in an array of strings

~~~ ruby
$matches = ["abc123","def456"].match(/([a-z]+)([1-9]+)/)
# $matches contains [[abc123, abc, 123], [def456, def, 456]]

- Since 4.0.0

- *Type*: statement

max
---
Returns the highest value of all arguments.
Requires at least one argument.

- *Type*: rvalue

md5
---
Returns a MD5 hash value from a provided string.

- *Type*: rvalue

member
------
This function determines if a variable is a member of an array.
The variable can be a string, fixnum, or array.

*Examples:*

    member(['a','b'], 'b')

Would return: true

    member(['a', 'b', 'c'], ['a', 'b'])

would return: true

    member(['a','b'], 'c')

Would return: false

    member(['a', 'b', 'c'], ['d', 'b'])

would return: false

- *Type*: rvalue

merge
-----
Merges two or more hashes together and returns the resulting hash.

For example:

    $hash1 = {'one' => 1, 'two', => 2}
    $hash2 = {'two' => 'dos', 'three', => 'tres'}
    $merged_hash = merge($hash1, $hash2)
    # The resulting hash is equivalent to:
    # $merged_hash =  {'one' => 1, 'two' => 'dos', 'three' => 'tres'}

When there is a duplicate key, the key in the rightmost hash will "win."

- *Type*: rvalue

min
---
Returns the lowest value of all arguments.
Requires at least one argument.

- *Type*: rvalue

notice
------
Log a message on the server at level notice.

- *Type*: statement

num2bool
--------
This function converts a number or a string representation of a number into a
true boolean. Zero or anything non-numeric becomes false. Numbers higher then 0
become true.

- *Type*: rvalue

parsejson
---------
This function accepts JSON as a string and converts into the correct Puppet
structure.

- *Type*: rvalue

parseyaml
---------
This function accepts YAML as a string and converts it into the correct
Puppet structure.

- *Type*: rvalue

pick
----

This function is similar to a coalesce function in SQL in that it will return
the first value in a list of values that is not undefined or an empty string
(two things in Puppet that will return a boolean false value). Typically,
this function is used to check for a value in the Puppet Dashboard/Enterprise
Console, and failover to a default value like the following:

  $real_jenkins_version = pick($::jenkins_version, '1.449')

The value of $real_jenkins_version will first look for a top-scope variable
called 'jenkins_version' (note that parameters set in the Puppet Dashboard/
Enterprise Console are brought into Puppet as top-scope variables), and,
failing that, will use a default value of 1.449.

- *Type*: rvalue

pick_default
------------

This function is similar to a coalesce function in SQL in that it will return
the first value in a list of values that is not undefined or an empty string
(two things in Puppet that will return a boolean false value). If no value is
found, it will return the last argument.

Typically, this function is used to check for a value in the Puppet
Dashboard/Enterprise Console, and failover to a default value like the
following:

  $real_jenkins_version = pick_default($::jenkins_version, '1.449')

The value of $real_jenkins_version will first look for a top-scope variable
called 'jenkins_version' (note that parameters set in the Puppet Dashboard/
Enterprise Console are brought into Puppet as top-scope variables), and,
failing that, will use a default value of 1.449.

Note that, contrary to the pick() function, the pick_default does not fail if
all arguments are empty. This allows pick_default to use an empty value as
default.

- *Type*: rvalue

postgresql_acls_to_resources_hash
---------------------------------
This internal function translates the ipv(4|6)acls format into a resource
suitable for create_resources. It is not intended to be used outside of the
postgresql internal classes/defined resources.

This function accepts an array of strings that are pg_hba.conf rules. It
will return a hash that can be fed into create_resources to create multiple
individual pg_hba_rule resources.

The second parameter is an identifier that will be included in the namevar
to provide uniqueness. It must be a string.

The third parameter is an order offset, so you can start the order at an
arbitrary starting point.

- *Type*: rvalue

postgresql_escape
-----------------
Safely escapes a string using $$ using a random tag which should be consistent

- *Type*: rvalue

postgresql_password
-------------------
Returns the postgresql password hash from the clear text username / password.

- *Type*: rvalue

prefix
------
This function applies a prefix to all elements in an array or a hash.

*Examples:*

    prefix(['a','b','c'], 'p')

Will return: ['pa','pb','pc']

- *Type*: rvalue

private
-------
DEPRECATED: Sets the current class or definition as private.
Calling the class or definition from outside the current module will fail.

- *Type*: statement

pw_hash
-------
Hashes a password using the crypt function. Provides a hash
usable on most POSIX systems.

The first argument to this function is the password to hash. If it is
undef or an empty string, this function returns undef.

The second argument to this function is which type of hash to use. It
will be converted into the appropriate crypt(3) hash specifier. Valid
hash types are:

|Hash type            |Specifier|
|---------------------|---------|
|MD5                  |1        |
|SHA-256              |5        |
|SHA-512 (recommended)|6        |

The third argument to this function is the salt to use.

Note: this uses the Puppet Master's implementation of crypt(3). If your
environment contains several different operating systems, ensure that they
are compatible before using this function.

- *Type*: rvalue

range
-----
When given range in the form of (start, stop) it will extrapolate a range as
an array.

*Examples:*

    range("0", "9")

Will return: [0,1,2,3,4,5,6,7,8,9]

    range("00", "09")

Will return: [0,1,2,3,4,5,6,7,8,9] (Zero padded strings are converted to
integers automatically)

    range("a", "c")

Will return: ["a","b","c"]

    range("host01", "host10")

Will return: ["host01", "host02", ..., "host09", "host10"]

Passing a third argument will cause the generated range to step by that
interval, e.g.

    range("0", "9", "2")

Will return: [0,2,4,6,8]

- *Type*: rvalue

realize
-------
Make a virtual object real.  This is useful
when you want to know the name of the virtual object and don't want to
bother with a full collection.  It is slightly faster than a collection,
and, of course, is a bit shorter.  You must pass the object using a
reference; e.g.: `realize User[luke]`.

- *Type*: statement

reduce
------
Applies a [lambda](https://docs.puppetlabs.com/puppet/latest/reference/lang_lambdas.html)
to every value in a data structure from the first argument, carrying over the returned
value of each iteration, and returns the result of the lambda's final iteration. This
lets you create a new value or data structure by combining values from the first
argument's data structure.

This function takes two mandatory arguments, in this order:

1. An array or hash the function will iterate over.
2. A lambda, which the function calls for each element in the first argument. It takes
two mandatory parameters:
    1. A memo value that is overwritten after each iteration with the iteration's result.
    2. A second value that is overwritten after each iteration with the next value in the
    function's first argument.

**Example**: Using the `reduce` function

`$data.reduce |$memo, $value| { ... }`

or

`reduce($data) |$memo, $value| { ... }`

You can also pass an optional "start memo" value as an argument, such as `start` below:

`$data.reduce(start) |$memo, $value| { ... }`

or

`reduce($data, start) |$memo, $value| { ... }`

When the first argument (`$data` in the above example) is an array, Puppet passes each
of the data structure's values in turn to the lambda's parameters. When the first
argument is a hash, Puppet converts each of the hash's values to an array in the form
`[key, value]`.

If you pass a start memo value, Puppet executes the lambda with the provided memo value
and the data structure's first value. Otherwise, Puppet passes the structure's first two
values to the lambda.

Puppet calls the lambda for each of the data structure's remaining values. For each
call, it passes the result of the previous call as the first parameter ($memo in the
above examples) and the next value from the data structure as the second parameter
($value).

If the structure has one value, Puppet returns the value and does not call the lambda.

**Example**: Using the `reduce` function

~~~ puppet
# Reduce the array $data, returning the sum of all values in the array.
$data = [1, 2, 3]
$sum = $data.reduce |$memo, $value| { $memo + $value }
# $sum contains 6

# Reduce the array $data, returning the sum of a start memo value and all values in the
# array.
$data = [1, 2, 3]
$sum = $data.reduce(4) |$memo, $value| { $memo + $value }
# $sum contains 10

# Reduce the hash $data, returning the sum of all values and concatenated string of all
# keys.
$data = {a => 1, b => 2, c => 3}
$combine = $data.reduce |$memo, $value| {
  $string = "${memo[0]}${value[0]}"
  $number = $memo[1] + $value[1]
  [$string, $number]
}
# $combine contains [abc, 6]
~~~

**Example**: Using the `reduce` function with a start memo and two-parameter lambda

~~~ puppet
# Reduce the array $data, returning the sum of all values in the array and starting
# with $memo set to an arbitrary value instead of $data's first value.
$data = [1, 2, 3]
$sum = $data.reduce(4) |$memo, $value| { $memo + $value }
# At the start of the lambda's first iteration, $memo contains 4 and $value contains 1.
# After all iterations, $sum contains 10.

# Reduce the hash $data, returning the sum of all values and concatenated string of
# all keys, and starting with $memo set to an arbitrary array instead of $data's first
# key-value pair.
$data = {a => 1, b => 2, c => 3}
$combine = $data.reduce( [d, 4] ) |$memo, $value| {
  $string = "${memo[0]}${value[0]}"
  $number = $memo[1] + $value[1]
  [$string, $number]
}
# At the start of the lambda's first iteration, $memo contains [d, 4] and $value
# contains [a, 1].
# $combine contains [dabc, 10]
~~~

- Since 4.0.0

- *Type*: rvalue

regsubst
--------

Perform regexp replacement on a string or array of strings.

* *Parameters* (in order):
    * _target_  The string or array of strings to operate on.  If an array, the replacement will be performed on each of the elements in the array, and the return value will be an array.
    * _regexp_  The regular expression matching the target string.  If you want it anchored at the start and or end of the string, you must do that with ^ and $ yourself.
    * _replacement_  Replacement string. Can contain backreferences to what was matched using \0 (whole match), \1 (first set of parentheses), and so on.
    * _flags_  Optional. String of single letter flags for how the regexp is interpreted:
        - *E*         Extended regexps
        - *I*         Ignore case in regexps
        - *M*         Multiline regexps
        - *G*         Global replacement; all occurrences of the regexp in each target string will be replaced.  Without this, only the first occurrence will be replaced.
    * _encoding_  Optional.  How to handle multibyte characters.  A single-character string with the following values:
        - *N*         None
        - *E*         EUC
        - *S*         SJIS
        - *U*         UTF-8

* *Examples*

Get the third octet from the node's IP address:

    $i3 = regsubst($ipaddress,'^(\d+)\.(\d+)\.(\d+)\.(\d+)$','\3')

Put angle brackets around each octet in the node's IP address:

    $x = regsubst($ipaddress, '([0-9]+)', '<\1>', 'G')

- *Type*: rvalue

reject
------
This function searches through an array and rejects all elements that match
the provided regular expression.

*Examples:*

    reject(['aaa','bbb','ccc','aaaddd'], 'aaa')

Would return:

    ['bbb','ccc']

- *Type*: rvalue

require
-------
Evaluate one or more classes,  adding the required class as a dependency.

The relationship metaparameters work well for specifying relationships
between individual resources, but they can be clumsy for specifying
relationships between classes.  This function is a superset of the
'include' function, adding a class relationship so that the requiring
class depends on the required class.

Warning: using require in place of include can lead to unwanted dependency cycles.

For instance the following manifest, with 'require' instead of 'include' would produce a nasty dependence cycle, because notify imposes a before between File[/foo] and Service[foo]:

    class myservice {
      service { foo: ensure => running }
    }

    class otherstuff {
      include myservice
      file { '/foo': notify => Service[foo] }
    }

Note that this function only works with clients 0.25 and later, and it will
fail if used with earlier clients.

You must use the class's full name;
relative names are not allowed. In addition to names in string form,
you may also directly use Class and Resource Type values that are produced when evaluating
resource and relationship expressions.

- Since 4.0.0 Class and Resource types, absolute names

- *Type*: statement

reverse
-------
Reverses the order of a string or array.

- *Type*: rvalue

rstrip
------
Strips leading spaces to the right of the string.

- *Type*: rvalue

scanf
-----
Scans a string and returns an array of one or more converted values as directed by a given format string.args
See the documenation of Ruby's String::scanf method for details about the supported formats (which
are similar but not identical to the formats used in Puppet's `sprintf` function.

This function takes two mandatory arguments: the first is the String to
convert, and the second the format String. The result of the scan is an Array,
with each sucessfully scanned and transformed value.args The scanning stops if
a scan is unsuccesful and the scanned result up to that point is returned. If
there was no succesful scan at all, the result is an empty Array.

      scanf("42", "%i")[0] == 42


When used with the future parser, an optional parameterized block may be given.
The block is called with the result that is produced by scanf if no block is
present, the result of the block is then returned by the function.

The optional code block is typically used to assert that the scan was
succesful, and either produce the same input, or perform unwrapping of
the result:

      "42".scanf("%i")
      "42".scanf("%i") |$x| {
        unless $x[0] =~ Integer {
          fail "Expected a well formed integer value, got '$x[0]'"
        }
        $x[0]
      }

- since 3.7.4 with `parser = future`
- since 3.7.5 with classic parser

- *Type*: rvalue

sha1
----
Returns a SHA1 hash value from a provided string.

- *Type*: rvalue

shellquote
----------
Quote and concatenate arguments for use in Bourne shell.

Each argument is quoted separately, and then all are concatenated
with spaces.  If an argument is an array, the elements of that
array is interpolated within the rest of the arguments; this makes
it possible to have an array of arguments and pass that array to
shellquote instead of having to specify each argument
individually in the call.

- *Type*: rvalue

shuffle
-------
Randomizes the order of a string or array elements.

- *Type*: rvalue

size
----
Returns the number of elements in a string, an array or a hash

- *Type*: rvalue

slice
-----
Applies a parameterized block to each _slice_ of elements in a sequence of selected entries from the first
argument and returns the first argument, or if no block is given returns a new array with a concatenation of
the slices.

This function takes two mandatory arguments: the first, `$a`, should be an Array, Hash, or something of
enumerable type (integer, Integer range, or String), and the second, `$n`, the number of elements to include
in each slice. The optional third argument should be a a parameterized block as produced by the puppet syntax:

    $a.slice($n) |$x| { ... }
    slice($a) |$x| { ... }

The parameterized block should have either one parameter (receiving an array with the slice), or the same number
of parameters as specified by the slice size (each parameter receiving its part of the slice).
In case there are fewer remaining elements than the slice size for the last slice it will contain the remaining
elements. When the block has multiple parameters, excess parameters are set to undef for an array or
enumerable type, and to empty arrays for a Hash.

    $a.slice(2) |$first, $second| { ... }

When the first argument is a Hash, each `key,value` entry is counted as one, e.g, a slice size of 2 will produce
an array of two arrays with key, and value.

Example Using slice with Hash

    $a.slice(2) |$entry|          { notice "first ${$entry[0]}, second ${$entry[1]}" }
    $a.slice(2) |$first, $second| { notice "first ${first}, second ${second}" }

When called without a block, the function produces a concatenated result of the slices.

Example Using slice without a block

    slice([1,2,3,4,5,6], 2) # produces [[1,2], [3,4], [5,6]]
    slice(Integer[1,6], 2)  # produces [[1,2], [3,4], [5,6]]
    slice(4,2)              # produces [[0,1], [2,3]]
    slice('hello',2)        # produces [[h, e], [l, l], [o]]

- Since 4.0.0

- *Type*: rvalue

sort
----
Sorts strings and arrays lexically.

- *Type*: rvalue

split
-----
Split a string variable into an array using the specified split regexp.

*Example:*

    $string     = 'v1.v2:v3.v4'
    $array_var1 = split($string, ':')
    $array_var2 = split($string, '[.]')
    $array_var3 = split($string, '[.:]')

`$array_var1` now holds the result `['v1.v2', 'v3.v4']`,
while `$array_var2` holds `['v1', 'v2:v3', 'v4']`, and
`$array_var3` holds `['v1', 'v2', 'v3', 'v4']`.

Note that in the second example, we split on a literal string that contains
a regexp meta-character (.), which must be escaped.  A simple
way to do that for a single character is to enclose it in square
brackets; a backslash will also escape a single character.

- *Type*: rvalue

sprintf
-------
Perform printf-style formatting of text.

The first parameter is format string describing how the rest of the parameters should be formatted.  See the documentation for the `Kernel::sprintf` function in Ruby for all the details.

- *Type*: rvalue

squeeze
-------
Returns a new string where runs of the same character that occur in this set are replaced by a single character.

- *Type*: rvalue

str2bool
--------
This converts a string to a boolean. This attempt to convert strings that
contain things like: y, 1, t, true to 'true' and strings that contain things
like: 0, f, n, false, no to 'false'.

- *Type*: rvalue

str2saltedsha512
----------------
This converts a string to a salted-SHA512 password hash (which is used for
OS X versions >= 10.7). Given any simple string, you will get a hex version
of a salted-SHA512 password hash that can be inserted into your Puppet
manifests as a valid password attribute.

- *Type*: rvalue

strftime
--------
This function returns formatted time.

*Examples:*

To return the time since epoch:

    strftime("%s")

To return the date:

    strftime("%Y-%m-%d")

*Format meaning:*

    %a - The abbreviated weekday name (``Sun'')
    %A - The  full  weekday  name (``Sunday'')
    %b - The abbreviated month name (``Jan'')
    %B - The  full  month  name (``January'')
    %c - The preferred local date and time representation
    %C - Century (20 in 2009)
    %d - Day of the month (01..31)
    %D - Date (%m/%d/%y)
    %e - Day of the month, blank-padded ( 1..31)
    %F - Equivalent to %Y-%m-%d (the ISO 8601 date format)
    %h - Equivalent to %b
    %H - Hour of the day, 24-hour clock (00..23)
    %I - Hour of the day, 12-hour clock (01..12)
    %j - Day of the year (001..366)
    %k - hour, 24-hour clock, blank-padded ( 0..23)
    %l - hour, 12-hour clock, blank-padded ( 0..12)
    %L - Millisecond of the second (000..999)
    %m - Month of the year (01..12)
    %M - Minute of the hour (00..59)
    %n - Newline (
)
    %N - Fractional seconds digits, default is 9 digits (nanosecond)
            %3N  millisecond (3 digits)
            %6N  microsecond (6 digits)
            %9N  nanosecond (9 digits)
    %p - Meridian indicator (``AM''  or  ``PM'')
    %P - Meridian indicator (``am''  or  ``pm'')
    %r - time, 12-hour (same as %I:%M:%S %p)
    %R - time, 24-hour (%H:%M)
    %s - Number of seconds since 1970-01-01 00:00:00 UTC.
    %S - Second of the minute (00..60)
    %t - Tab character (	)
    %T - time, 24-hour (%H:%M:%S)
    %u - Day of the week as a decimal, Monday being 1. (1..7)
    %U - Week  number  of the current year,
            starting with the first Sunday as the first
            day of the first week (00..53)
    %v - VMS date (%e-%b-%Y)
    %V - Week number of year according to ISO 8601 (01..53)
    %W - Week  number  of the current year,
            starting with the first Monday as the first
            day of the first week (00..53)
    %w - Day of the week (Sunday is 0, 0..6)
    %x - Preferred representation for the date alone, no time
    %X - Preferred representation for the time alone, no date
    %y - Year without a century (00..99)
    %Y - Year with century
    %z - Time zone as  hour offset from UTC (e.g. +0900)
    %Z - Time zone name
    %% - Literal ``%'' character

- *Type*: rvalue

strip
-----
This function removes leading and trailing whitespace from a string or from
every string inside an array.

*Examples:*

    strip("    aaa   ")

Would result in: "aaa"

- *Type*: rvalue

suffix
------
This function applies a suffix to all elements in an array.

*Examples:*

    suffix(['a','b','c'], 'p')

Will return: ['ap','bp','cp']

- *Type*: rvalue

swapcase
--------
This function will swap the existing case of a string.

*Examples:*

    swapcase("aBcD")

Would result in: "AbCd"

- *Type*: rvalue

tag
---
Add the specified tags to the containing class
or definition.  All contained objects will then acquire that tag, also.

- *Type*: statement

tagged
------
A boolean function that
tells you whether the current container is tagged with the specified tags.
The tags are ANDed, so that all of the specified tags must be included for
the function to return true.

- *Type*: rvalue

template
--------
Loads an ERB template from a module, evaluates it, and returns the resulting
value as a string.

The argument to this function should be a `<MODULE NAME>/<TEMPLATE FILE>`
reference, which will load `<TEMPLATE FILE>` from a module's `templates`
directory. (For example, the reference `apache/vhost.conf.erb` will load the
file `<MODULES DIRECTORY>/apache/templates/vhost.conf.erb`.)

This function can also accept:

* An absolute path, which can load a template file from anywhere on disk.
* Multiple arguments, which will evaluate all of the specified templates and
return their outputs concatenated into a single string.

- *Type*: rvalue

time
----
This function will return the current time since epoch as an integer.

*Examples:*

    time()

Will return something like: 1311972653

- *Type*: rvalue

to_bytes
--------
Converts the argument into bytes, for example 4 kB becomes 4096.
Takes a single string value as an argument.
These conversions reflect a layperson's understanding of
1 MB = 1024 KB, when in fact 1 MB = 1000 KB, and 1 MiB = 1024 KiB.

- *Type*: rvalue

try_get_value
-------------
Looks up into a complex structure of arrays and hashes and returns a value
or the default value if nothing was found.

Key can contain slashes to describe path components. The function will go down
the structure and try to extract the required value.

$data = {
  'a' => {
    'b' => [
      'b1',
      'b2',
      'b3',
    ]
  }
}

$value = try_get_value($data, 'a/b/2', 'not_found', '/')
=> $value = 'b3'

a -> first hash key
b -> second hash key
2 -> array index starting with 0

not_found -> (optional) will be returned if there is no value or the path did not match. Defaults to nil.
/ -> (optional) path delimiter. Defaults to '/'.

In addition to the required "key" argument, "try_get_value" accepts default
argument. It will be returned if no value was found or a path component is
missing. And the fourth argument can set a variable path separator.

- *Type*: rvalue

type
----
DEPRECATED: This function will cease to function on Puppet 4; please use type3x() before upgrading to puppet 4 for backwards-compatibility, or migrate to the new parser's typing system.

- *Type*: rvalue

type3x
------
DEPRECATED: This function will be removed when puppet 3 support is dropped; please migrate to the new parser's typing system.

Returns the type when passed a value. Type can be one of:

* string
* array
* hash
* float
* integer
* boolean

- *Type*: rvalue

union
-----
This function returns a union of two or more arrays.

*Examples:*

    union(["a","b","c"],["b","c","d"])

Would return: ["a","b","c","d"]

- *Type*: rvalue

unique
------
This function will remove duplicates from strings and arrays.

*Examples:*

    unique("aabbcc")

Will return:

    abc

You can also use this with arrays:

    unique(["a","a","b","b","c","c"])

This returns:

    ["a","b","c"]

- *Type*: rvalue

unix2dos
--------
Returns the DOS version of the given string.
Takes a single string argument.

- *Type*: rvalue

upcase
------
Converts a string or an array of strings to uppercase.

*Examples:*

    upcase("abcd")

Will return:

    ABCD

- *Type*: rvalue

uriescape
---------
Urlencodes a string or array of strings.
Requires either a single string or an array as an input.

- *Type*: rvalue

validate_absolute_path
----------------------
Validate the string represents an absolute path in the filesystem.  This function works
for windows and unix style paths.

The following values will pass:

    $my_path = 'C:/Program Files (x86)/Puppet Labs/Puppet'
    validate_absolute_path($my_path)
    $my_path2 = '/var/lib/puppet'
    validate_absolute_path($my_path2)
    $my_path3 = ['C:/Program Files (x86)/Puppet Labs/Puppet','C:/Program Files/Puppet Labs/Puppet']
    validate_absolute_path($my_path3)
    $my_path4 = ['/var/lib/puppet','/usr/share/puppet']
    validate_absolute_path($my_path4)

The following values will fail, causing compilation to abort:

    validate_absolute_path(true)
    validate_absolute_path('../var/lib/puppet')
    validate_absolute_path('var/lib/puppet')
    validate_absolute_path([ 'var/lib/puppet', '/var/foo' ])
    validate_absolute_path([ '/var/lib/puppet', 'var/foo' ])
    $undefined = undef
    validate_absolute_path($undefined)

- *Type*: statement

validate_array
--------------
Validate that all passed values are array data structures. Abort catalog
compilation if any value fails this check.

The following values will pass:

    $my_array = [ 'one', 'two' ]
    validate_array($my_array)

The following values will fail, causing compilation to abort:

    validate_array(true)
    validate_array('some_string')
    $undefined = undef
    validate_array($undefined)

- *Type*: statement

validate_augeas
---------------
Perform validation of a string using an Augeas lens
The first argument of this function should be a string to
test, and the second argument should be the name of the Augeas lens to use.
If Augeas fails to parse the string with the lens, the compilation will
abort with a parse error.

A third argument can be specified, listing paths which should
not be found in the file. The `$file` variable points to the location
of the temporary file being tested in the Augeas tree.

For example, if you want to make sure your passwd content never contains
a user `foo`, you could write:

    validate_augeas($passwdcontent, 'Passwd.lns', ['$file/foo'])

Or if you wanted to ensure that no users used the '/bin/barsh' shell,
you could use:

    validate_augeas($passwdcontent, 'Passwd.lns', ['$file/*[shell="/bin/barsh"]']

If a fourth argument is specified, this will be the error message raised and
seen by the user.

A helpful error message can be returned like this:

    validate_augeas($sudoerscontent, 'Sudoers.lns', [], 'Failed to validate sudoers content with Augeas')

- *Type*: statement

validate_bool
-------------
Validate that all passed values are either true or false. Abort catalog
compilation if any value fails this check.

The following values will pass:

    $iamtrue = true
    validate_bool(true)
    validate_bool(true, true, false, $iamtrue)

The following values will fail, causing compilation to abort:

    $some_array = [ true ]
    validate_bool("false")
    validate_bool("true")
    validate_bool($some_array)

- *Type*: statement

validate_cmd
------------
Perform validation of a string with an external command.
The first argument of this function should be a string to
test, and the second argument should be a path to a test command
taking a % as a placeholder for the file path (will default to the end).
If the command, launched against a tempfile containing the passed string,
returns a non-null value, compilation will abort with a parse error.

If a third argument is specified, this will be the error message raised and
seen by the user.

A helpful error message can be returned like this:

Example:

    # Defaults to end of path
    validate_cmd($sudoerscontent, '/usr/sbin/visudo -c -f', 'Visudo failed to validate sudoers content')

    # % as file location
    validate_cmd($haproxycontent, '/usr/sbin/haproxy -f % -c', 'Haproxy failed to validate config content')

- *Type*: statement

validate_hash
-------------
Validate that all passed values are hash data structures. Abort catalog
compilation if any value fails this check.

The following values will pass:

    $my_hash = { 'one' => 'two' }
    validate_hash($my_hash)

The following values will fail, causing compilation to abort:

    validate_hash(true)
    validate_hash('some_string')
    $undefined = undef
    validate_hash($undefined)

- *Type*: statement

validate_integer
----------------
Validate that the first argument is an integer (or an array of integers). Abort catalog compilation if any of the checks fail.

The second argument is optional and passes a maximum. (All elements of) the first argument has to be less or equal to this max.

The third argument is optional and passes a minimum.  (All elements of) the first argument has to be greater or equal to this min.
If, and only if, a minimum is given, the second argument may be an empty string or undef, which will be handled to just check
if (all elements of) the first argument are greater or equal to the given minimum.

It will fail if the first argument is not an integer or array of integers, and if arg 2 and arg 3 are not convertable to an integer.

The following values will pass:

  validate_integer(1)
  validate_integer(1, 2)
  validate_integer(1, 1)
  validate_integer(1, 2, 0)
  validate_integer(2, 2, 2)
  validate_integer(2, '', 0)
  validate_integer(2, undef, 0)
  $foo = undef
  validate_integer(2, $foo, 0)
  validate_integer([1,2,3,4,5], 6)
  validate_integer([1,2,3,4,5], 6, 0)

Plus all of the above, but any combination of values passed as strings ('1' or "1").
Plus all of the above, but with (correct) combinations of negative integer values.

The following values will not:

  validate_integer(true)
  validate_integer(false)
  validate_integer(7.0)
  validate_integer({ 1 => 2 })
  $foo = undef
  validate_integer($foo)
  validate_integer($foobaridontexist)

  validate_integer(1, 0)
  validate_integer(1, true)
  validate_integer(1, '')
  validate_integer(1, undef)
  validate_integer(1, , 0)
  validate_integer(1, 2, 3)
  validate_integer(1, 3, 2)
  validate_integer(1, 3, true)

Plus all of the above, but any combination of values passed as strings ('false' or "false").
Plus all of the above, but with incorrect combinations of negative integer values.
Plus all of the above, but with non-integer items in arrays or maximum / minimum argument.

- *Type*: statement

validate_ipv4_address
---------------------
Validate that all values passed are valid IPv4 addresses.
Fail compilation if any value fails this check.

The following values will pass:

$my_ip = "1.2.3.4"
validate_ipv4_address($my_ip)
validate_bool("8.8.8.8", "172.16.0.1", $my_ip)

The following values will fail, causing compilation to abort:

$some_array = [ 1, true, false, "garbage string", "3ffe:505:2" ]
validate_ipv4_address($some_array)

- *Type*: statement

validate_ipv6_address
---------------------
Validate that all values passed are valid IPv6 addresses.
Fail compilation if any value fails this check.

The following values will pass:

$my_ip = "3ffe:505:2"
validate_ipv6_address(1)
validate_ipv6_address($my_ip)
validate_bool("fe80::baf6:b1ff:fe19:7507", $my_ip)

The following values will fail, causing compilation to abort:

$some_array = [ true, false, "garbage string", "1.2.3.4" ]
validate_ipv6_address($some_array)

- *Type*: statement

validate_numeric
----------------
Validate that the first argument is a numeric value (or an array of numeric values). Abort catalog compilation if any of the checks fail.

The second argument is optional and passes a maximum. (All elements of) the first argument has to be less or equal to this max.

The third argument is optional and passes a minimum.  (All elements of) the first argument has to be greater or equal to this min.
If, and only if, a minimum is given, the second argument may be an empty string or undef, which will be handled to just check
if (all elements of) the first argument are greater or equal to the given minimum.

It will fail if the first argument is not a numeric (Integer or Float) or array of numerics, and if arg 2 and arg 3 are not convertable to a numeric.

For passing and failing usage, see `validate_integer()`. It is all the same for validate_numeric, yet now floating point values are allowed, too.

- *Type*: statement

validate_re
-----------
Perform simple validation of a string against one or more regular
expressions. The first argument of this function should be a string to
test, and the second argument should be a stringified regular expression
(without the // delimiters) or an array of regular expressions.  If none
of the regular expressions match the string passed in, compilation will
abort with a parse error.

If a third argument is specified, this will be the error message raised and
seen by the user.

The following strings will validate against the regular expressions:

    validate_re('one', '^one$')
    validate_re('one', [ '^one', '^two' ])

The following strings will fail to validate, causing compilation to abort:

    validate_re('one', [ '^two', '^three' ])

A helpful error message can be returned like this:

    validate_re($::puppetversion, '^2.7', 'The $puppetversion fact value does not match 2.7')

- *Type*: statement

validate_slength
----------------
Validate that the first argument is a string (or an array of strings), and
less/equal to than the length of the second argument. An optional third
parameter can be given the minimum length. It fails if the first
argument is not a string or array of strings, and if arg 2 and arg 3 are
not convertable to a number.

The following values will pass:

  validate_slength("discombobulate",17)
  validate_slength(["discombobulate","moo"],17)
  validate_slength(["discombobulate","moo"],17,3)

The following valueis will not:

  validate_slength("discombobulate",1)
  validate_slength(["discombobulate","thermometer"],5)
  validate_slength(["discombobulate","moo"],17,10)

- *Type*: statement

validate_string
---------------
Validate that all passed values are string data structures. Abort catalog
compilation if any value fails this check.

The following values will pass:

    $my_string = "one two"
    validate_string($my_string, 'three')

The following values will fail, causing compilation to abort:

    validate_string(true)
    validate_string([ 'some', 'array' ])

Note: validate_string(undef) will not fail in this version of the
functions API (incl. current and future parser). Instead, use:

    if $var == undef {
      fail('...')
    }

- *Type*: statement

values
------
When given a hash this function will return the values of that hash.

*Examples:*

    $hash = {
      'a' => 1,
      'b' => 2,
      'c' => 3,
    }
    values($hash)

This example would return:

    [1,2,3]

- *Type*: rvalue

values_at
---------
Finds value inside an array based on location.

The first argument is the array you want to analyze, and the second element can
be a combination of:

* A single numeric index
* A range in the form of 'start-stop' (eg. 4-9)
* An array combining the above

*Examples*:

    values_at(['a','b','c'], 2)

Would return ['c'].

    values_at(['a','b','c'], ["0-1"])

Would return ['a','b'].

    values_at(['a','b','c','d','e'], [0, "2-3"])

Would return ['a','c','d'].

- *Type*: rvalue

versioncmp
----------
Compares two version numbers.

Prototype:

    $result = versioncmp(a, b)

Where a and b are arbitrary version strings.

This function returns:

* `1` if version a is greater than version b
* `0` if the versions are equal
* `-1` if version a is less than version b

Example:

    if versioncmp('2.6-1', '2.4.5') > 0 {
        notice('2.6-1 is > than 2.4.5')
    }

This function uses the same version comparison algorithm used by Puppet's
`package` type.

- *Type*: rvalue

warning
-------
Log a message on the server at level warning.

- *Type*: statement

with
----
Call a [lambda](https://docs.puppetlabs.com/puppet/latest/reference/lang_lambdas.html)
with the given arguments and return the result. Since a lambda's scope is
[local](https://docs.puppetlabs.com/puppet/latest/reference/lang_lambdas.html#lambda-scope)
to the lambda, you can use the `with` function to create private blocks of code within a
class using variables whose values cannot be accessed outside of the lambda.

**Example**: Using `with`

~~~ puppet
# Concatenate three strings into a single string formatted as a list.
$fruit = with("apples", "oranges", "bananas") |$x, $y, $z| {
  "${x}, ${y}, and ${z}"
}
$check_var = $x
# $fruit contains "apples, oranges, and bananas"
# $check_var is undefined, as the value of $x is local to the lambda.
~~~

- Since 4.0.0

- *Type*: rvalue

zip
---
Takes one element from first array and merges corresponding elements from second array. This generates a sequence of n-element arrays, where n is one more than the count of arguments.

*Example:*

    zip(['1','2','3'],['4','5','6'])

Would result in:

    ["1", "4"], ["2", "5"], ["3", "6"]

- *Type*: rvalue



----------------

*This page autogenerated on 2016-01-14 14:50:46 -0800*
