{
  "puppet_classes"=>[],
  "data_types"=>[
    {
      "name"=>"Error",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/datatypes/error.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "String[1]"
            ],
            "name"=>"msg"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[String[1]]"
            ],
            "name"=>"kind"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Hash[String[1],Data]]"
            ],
            "name"=>"details"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[String[1]]"
            ],
            "name"=>"issue_code"
          }
        ]
      },
      "functions"=>[
        {
          "name"=>"message",
          "signature"=>"Error.message",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "String[1]"
                ]
              }
            ]
          }
        }
      ]
    }
  ],
  "data_type_aliases"=>[],
  "defined_types"=>[],
  "resource_types"=>[
    {
      "name"=>"component",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/component.rb",
      "line"=>6,
      "docstring"=>{
        "text"=>"The name of the component.  Generally optional."
      },
      "parameters"=>[
        {
          "name"=>"name",
          "description"=>"The name of the component.  Generally optional.",
          "isnamevar"=>true
        }
      ]
    },
    {
      "name"=>"exec",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/exec.rb",
      "line"=>2,
      "docstring"=>{
        "text"=>"Executes external commands.\n\nAny command in an `exec` resource **must** be able to run multiple times\nwithout causing harm --- that is, it must be *idempotent*. There are three\nmain ways for an exec to be idempotent:\n\n* The command itself is already idempotent. (For example, `apt-get update`.)\n* The exec has an `onlyif`, `unless`, or `creates` attribute, which prevents\n  Puppet from running the command unless some condition is met.\n* The exec has `refreshonly => true`, which allows Puppet to run the\n  command only when some other resource is changed. (See the notes on refreshing\n  below.)\n\nThe state managed by an `exec` resource represents whether the specified command\n_needs to be_ executed during the catalog run. The target state is always that\nthe command does not need to be executed. If the initial state is that the\ncommand _does_ need to be executed, then successfully executing the command\ntransitions it to the target state.\n\nThe `unless`, `onlyif`, and `creates` properties check the initial state of the\nresource. If one or more of these properties is specified, the exec might not\nneed to run. If the exec does not need to run, then the system is already in\nthe target state. In such cases, the exec is considered successful without\nactually executing its command.\n\nA caution: There's a widespread tendency to use collections of execs to\nmanage resources that aren't covered by an existing resource type. This\nworks fine for simple tasks, but once your exec pile gets complex enough\nthat you really have to think to understand what's happening, you should\nconsider developing a custom resource type instead, as it is much\nmore predictable and maintainable.\n\n**Duplication:** Even though `command` is the namevar, Puppet allows\nmultiple `exec` resources with the same `command` value.\n\n**Refresh:** `exec` resources can respond to refresh events (via\n`notify`, `subscribe`, or the `~>` arrow). The refresh behavior of execs\nis non-standard, and can be affected by the `refresh` and\n`refreshonly` attributes:\n\n* If `refreshonly` is set to true, the exec runs _only_ when it receives an\n  event. This is the most reliable way to use refresh with execs.\n* If the exec has already run and then receives an event, it runs its\n  command **up to two times.** If an `onlyif`, `unless`, or `creates` condition\n  is no longer met after the first run, the second run does not occur.\n* If the exec has already run, has a `refresh` command, and receives an\n  event, it runs its normal command. Then, if any `onlyif`, `unless`, or `creates`\n  conditions are still met, the exec runs its `refresh` command.\n* If the exec has an `onlyif`, `unless`, or `creates` attribute that prevents it\n  from running, and it then receives an event, it still will not run.\n* If the exec has `noop => true`, would otherwise have run, and receives\n  an event from a non-noop resource, it runs once. However, if it has a `refresh`\n  command, it runs that instead of its normal command.\n\nIn short: If there's a possibility of your exec receiving refresh events,\nit is extremely important to make sure the run conditions are restricted.\n\n**Autorequires:** If Puppet is managing an exec's cwd or the executable\nfile used in an exec's command, the exec resource autorequires those\nfiles. If Puppet is managing the user that an exec should run as, the\nexec resource autorequires that user."
      },
      "properties"=>[
        {
          "name"=>"returns",
          "description"=>"The expected exit code(s).  An error will be returned if the\nexecuted command has some other exit code. Can be specified as an array\nof acceptable exit codes or a single value.\n\nOn POSIX systems, exit codes are always integers between 0 and 255.\n\nOn Windows, **most** exit codes should be integers between 0\nand 2147483647.\n\nLarger exit codes on Windows can behave inconsistently across different\ntools. The Win32 APIs define exit codes as 32-bit unsigned integers, but\nboth the cmd.exe shell and the .NET runtime cast them to signed\nintegers. This means some tools will report negative numbers for exit\ncodes above 2147483647. (For example, cmd.exe reports 4294967295 as -1.)\nSince Puppet uses the plain Win32 APIs, it will report the very large\nnumber instead of the negative number, which might not be what you\nexpect if you got the exit code from a cmd.exe session.\n\nMicrosoft recommends against using negative/very large exit codes, and\nyou should avoid them when possible. To convert a negative exit code to\nthe positive one Puppet will use, add it to 4294967296.",
          "default"=>"0"
        }
      ],
      "parameters"=>[
        {
          "name"=>"command",
          "description"=>"The actual command to execute.  Must either be fully qualified\nor a search path for the command must be provided.  If the command\nsucceeds, any output produced will be logged at the instance's\nnormal log level (usually `notice`), but if the command fails\n(meaning its return code does not match the specified code) then\nany output is logged at the `err` log level.\n\nMultiple `exec` resources can use the same `command` value; Puppet\nonly uses the resource title to ensure `exec`s are unique.",
          "isnamevar"=>true
        },
        {
          "name"=>"cwd",
          "description"=>"The directory from which to run the command.  If\nthis directory does not exist, the command will fail."
        },
        {
          "name"=>"environment",
          "description"=>"An array of any additional environment variables you want to set for a\ncommand, such as `[ 'HOME=/root', 'MAIL=root@example.com']`.\nNote that if you use this to set PATH, it will override the `path`\nattribute. Multiple environment variables should be specified as an\narray."
        },
        {
          "name"=>"group",
          "description"=>"The group to run the command as.  This seems to work quite\nhaphazardly on different platforms -- it is a platform issue\nnot a Ruby or Puppet one, since the same variety exists when\nrunning commands as different users in the shell."
        },
        {
          "name"=>"logoutput",
          "description"=>"Whether to log command output in addition to logging the\nexit code. Defaults to `on_failure`, which only logs the output\nwhen the command has an exit code that does not match any value\nspecified by the `returns` attribute. As with any resource type,\nthe log level can be controlled with the `loglevel` metaparameter.",
          "values"=>[
            "true",
            "false",
            "on_failure"
          ],
          "default"=>"on_failure"
        },
        {
          "name"=>"path",
          "description"=>"The search path used for command execution.\nCommands must be fully qualified if no path is specified.  Paths\ncan be specified as an array or as a '"
        },
        {
          "name"=>"provider",
          "description"=>"The specific backend to use for this `exec` resource. You will seldom need to specify this --- Puppet will usually discover the appropriate provider for your platform."
        },
        {
          "name"=>"refresh",
          "description"=>"An alternate command to run when the `exec` receives a refresh event\nfrom another resource. By default, Puppet runs the main command again.\nFor more details, see the notes about refresh behavior above, in the\ndescription for this resource type.\n\nNote that this alternate command runs with the same `provider`, `path`,\n`user`, and `group` as the main command. If the `path` isn't set, you\nmust fully qualify the command's name."
        },
        {
          "name"=>"timeout",
          "description"=>"The maximum time the command should take.  If the command takes\nlonger than the timeout, the command is considered to have failed\nand will be stopped. The timeout is specified in seconds. The default\ntimeout is 300 seconds and you can set it to 0 to disable the timeout.",
          "default"=>"300"
        },
        {
          "name"=>"tries",
          "description"=>"The number of times execution of the command should be tried.\nThis many attempts will be made to execute the command until an\nacceptable return code is returned. Note that the timeout parameter\napplies to each try rather than to the complete set of tries.",
          "default"=>"1"
        },
        {
          "name"=>"try_sleep",
          "description"=>"The time to sleep in seconds between 'tries'.",
          "default"=>"0"
        },
        {
          "name"=>"umask",
          "description"=>"Sets the umask to be used while executing this command"
        },
        {
          "name"=>"user",
          "description"=>"The user to run the command as.\n\n> **Note:** Puppet cannot execute commands as other users on Windows.\n\nNote that if you use this attribute, any error output is not captured\ndue to a bug within Ruby. If you use Puppet to create this user, the\nexec automatically requires the user, as long as it is specified by\nname.\n\nThe $HOME environment variable is not automatically set when using\nthis attribute."
        }
      ],
      "checks"=>[
        {
          "name"=>"creates",
          "description"=>"A file to look for before running the command. The command will\nonly run if the file **doesn't exist.**\n\nThis parameter doesn't cause Puppet to create a file; it is only\nuseful if **the command itself** creates a file.\n\n    exec { 'tar -xf /Volumes/nfs02/important.tar':\n      cwd     => '/var/tmp',\n      creates => '/var/tmp/myfile',\n      path    => ['/usr/bin', '/usr/sbin',],\n    }\n\nIn this example, `myfile` is assumed to be a file inside\n`important.tar`. If it is ever deleted, the exec will bring it\nback by re-extracting the tarball. If `important.tar` does **not**\nactually contain `myfile`, the exec will keep running every time\nPuppet runs."
        },
        {
          "name"=>"onlyif",
          "description"=>"A test command that checks the state of the target system and restricts\nwhen the `exec` can run. If present, Puppet runs this test command\nfirst, and only runs the main command if the test has an exit code of 0\n(success). For example:\n\n    exec { 'logrotate':\n      path     => '/usr/bin:/usr/sbin:/bin',\n      provider => shell,\n      onlyif   => 'test `du /var/log/messages | cut -f1` -gt 100000',\n    }\n\nThis would run `logrotate` only if that test returns true.\n\nNote that this test command runs with the same `provider`, `path`,\n`user`, `cwd`, and `group` as the main command. If the `path` isn't set, you\nmust fully qualify the command's name.\n\nThis parameter can also take an array of commands. For example:\n\n    onlyif => ['test -f /tmp/file1', 'test -f /tmp/file2'],\n\nThis `exec` would only run if every command in the array has an\nexit code of 0 (success)."
        },
        {
          "name"=>"refreshonly",
          "description"=>"The command should only be run as a\nrefresh mechanism for when a dependent object is changed.  It only\nmakes sense to use this option when this command depends on some\nother object; it is useful for triggering an action:\n\n    # Pull down the main aliases file\n    file { '/etc/aliases':\n      source => 'puppet://server/module/aliases',\n    }\n\n    # Rebuild the database, but only when the file changes\n    exec { newaliases:\n      path        => ['/usr/bin', '/usr/sbin'],\n      subscribe   => File['/etc/aliases'],\n      refreshonly => true,\n    }\n\nNote that only `subscribe` and `notify` can trigger actions, not `require`,\nso it only makes sense to use `refreshonly` with `subscribe` or `notify`.",
          "values"=>[
            "true",
            "false"
          ]
        },
        {
          "name"=>"unless",
          "description"=>"A test command that checks the state of the target system and restricts\nwhen the `exec` can run. If present, Puppet runs this test command\nfirst, then runs the main command unless the test has an exit code of 0\n(success). For example:\n\n    exec { '/bin/echo root >> /usr/lib/cron/cron.allow':\n      path   => '/usr/bin:/usr/sbin:/bin',\n      unless => 'grep root /usr/lib/cron/cron.allow 2>/dev/null',\n    }\n\nThis would add `root` to the cron.allow file (on Solaris) unless\n`grep` determines it's already there.\n\nNote that this test command runs with the same `provider`, `path`,\n`user`, `cwd`, and `group` as the main command. If the `path` isn't set, you\nmust fully qualify the command's name.\n\nThis parameter can also take an array of commands. For example:\n\n    unless => ['test -f /tmp/file1', 'test -f /tmp/file2'],\n\nThis `exec` would only run if every command in the array has a\nnon-zero exit code."
        }
      ],
      "providers"=>[
        {
          "name"=>"posix",
          "type_name"=>"exec",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/exec/posix.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Executes external binaries directly, without passing through a shell or\nperforming any interpolation. This is a safer and more predictable way\nto execute most commands, but prevents the use of globbing and shell\nbuilt-ins (including control logic like \"for\" and \"if\" statements)."
          },
          "confines"=>{
            "feature"=>"posix"
          },
          "features"=>[
            "umask"
          ],
          "defaults"=>[
            [
              [
                "feature",
                "posix"
              ]
            ]
          ]
        },
        {
          "name"=>"shell",
          "type_name"=>"exec",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/exec/shell.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Passes the provided command through `/bin/sh`; only available on\nPOSIX systems. This allows the use of shell globbing and built-ins, and\ndoes not require that the path to a command be fully-qualified. Although\nthis can be more convenient than the `posix` provider, it also means that\nyou need to be more careful with escaping; as ever, with great power comes\netc. etc.\n\nThis provider closely resembles the behavior of the `exec` type\nin Puppet 0.25.x."
          },
          "confines"=>{
            "feature"=>"posix"
          }
        },
        {
          "name"=>"windows",
          "type_name"=>"exec",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/exec/windows.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Execute external binaries on Windows systems. As with the `posix`\nprovider, this provider directly calls the command with the arguments\ngiven, without passing it through a shell or performing any interpolation.\nTo use shell built-ins --- that is, to emulate the `shell` provider on\nWindows --- a command must explicitly invoke the shell:\n\n    exec {'echo foo':\n      command => 'cmd.exe /c echo \"foo\"',\n    }\n\nIf no extension is specified for a command, Windows will use the `PATHEXT`\nenvironment variable to locate the executable.\n\n**Note on PowerShell scripts:** PowerShell's default `restricted`\nexecution policy doesn't allow it to run saved scripts. To run PowerShell\nscripts, specify the `remotesigned` execution policy as part of the\ncommand:\n\n    exec { 'test':\n      path    => 'C:/Windows/System32/WindowsPowerShell/v1.0',\n      command => 'powershell -executionpolicy remotesigned -file C:/test.ps1',\n    }"
          },
          "confines"=>{
            "operatingsystem"=>"windows"
          },
          "defaults"=>[
            [
              [
                "operatingsystem",
                "windows"
              ]
            ]
          ]
        }
      ]
    },
    {
      "name"=>"file",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/file/source.rb",
      "line"=>13,
      "docstring"=>{
        "text"=>"Manages files, including their content, ownership, and permissions.\n\nThe `file` type can manage normal files, directories, and symlinks; the\ntype should be specified in the `ensure` attribute.\n\nFile contents can be managed directly with the `content` attribute, or\ndownloaded from a remote source using the `source` attribute; the latter\ncan also be used to recursively serve directories (when the `recurse`\nattribute is set to `true` or `local`). On Windows, note that file\ncontents are managed in binary mode; Puppet never automatically translates\nline endings.\n\n**Autorequires:** If Puppet is managing the user or group that owns a\nfile, the file resource will autorequire them. If Puppet is managing any\nparent directories of a file, the file resource autorequires them.\n\nWarning: Enabling `recurse` on directories containing large numbers of\nfiles slows agent runs. To manage file attributes for many files,\nconsider using alternative methods such as the `chmod_r`, `chown_r`,\n or `recursive_file_permissions` modules from the Forge."
      },
      "properties"=>[
        {
          "name"=>"checksum_value",
          "description"=>"The checksum of the source contents. Only md5, sha256, sha224, sha384 and sha512\nare supported when specifying this parameter. If this parameter is set,\nsource_permissions will be assumed to be false, and ownership and permissions\nwill not be read from source."
        },
        {
          "name"=>"content",
          "description"=>"The desired contents of a file, as a string. This attribute is mutually\nexclusive with `source` and `target`.\n\nNewlines and tabs can be specified in double-quoted strings using\nstandard escaped syntax --- \\n for a newline, and \\t for a tab.\n\nWith very small files, you can construct content strings directly in\nthe manifest...\n\n    define resolve($nameserver1, $nameserver2, $domain, $search) {\n        $str = \"search ${search}\n            domain ${domain}\n            nameserver ${nameserver1}\n            nameserver ${nameserver2}\n            \"\n\n        file { '/etc/resolv.conf':\n          content => $str,\n        }\n    }\n\n...but for larger files, this attribute is more useful when combined with the\n[template](https://puppet.com/docs/puppet/latest/function.html#template)\nor [file](https://puppet.com/docs/puppet/latest/function.html#file)\nfunction."
        },
        {
          "name"=>"ctime",
          "description"=>"A read-only state to check the file ctime. On most modern \\*nix-like\nsystems, this is the time of the most recent change to the owner, group,\npermissions, or content of the file."
        },
        {
          "name"=>"group",
          "description"=>"Which group should own the file.  Argument can be either a group\nname or a group ID.\n\nOn Windows, a user (such as \"Administrator\") can be set as a file's group\nand a group (such as \"Administrators\") can be set as a file's owner;\nhowever, a file's owner and group shouldn't be the same. (If the owner\nis also the group, files with modes like `\"0640\"` will cause log churn, as\nthey will always appear out of sync.)"
        },
        {
          "name"=>"mode",
          "description"=>"The desired permissions mode for the file, in symbolic or numeric\nnotation. This value **must** be specified as a string; do not use\nun-quoted numbers to represent file modes.\n\nIf the mode is omitted (or explicitly set to `undef`), Puppet does not\nenforce permissions on existing files and creates new files with\npermissions of `0644`.\n\nThe `file` type uses traditional Unix permission schemes and translates\nthem to equivalent permissions for systems which represent permissions\ndifferently, including Windows. For detailed ACL controls on Windows,\nyou can leave `mode` unmanaged and use\n[the puppetlabs/acl module.](https://forge.puppetlabs.com/puppetlabs/acl)\n\nNumeric modes should use the standard octal notation of\n`<SETUID/SETGID/STICKY><OWNER><GROUP><OTHER>` (for example, \"0644\").\n\n* Each of the \"owner,\" \"group,\" and \"other\" digits should be a sum of the\n  permissions for that class of users, where read = 4, write = 2, and\n  execute/search = 1.\n* The setuid/setgid/sticky digit is also a sum, where setuid = 4, setgid = 2,\n  and sticky = 1.\n* The setuid/setgid/sticky digit is optional. If it is absent, Puppet will\n  clear any existing setuid/setgid/sticky permissions. (So to make your intent\n  clear, you should use at least four digits for numeric modes.)\n* When specifying numeric permissions for directories, Puppet sets the search\n  permission wherever the read permission is set.\n\nSymbolic modes should be represented as a string of comma-separated\npermission clauses, in the form `<WHO><OP><PERM>`:\n\n* \"Who\" should be any combination of u (user), g (group), and o (other), or a (all)\n* \"Op\" should be = (set exact permissions), + (add select permissions),\n  or - (remove select permissions)\n* \"Perm\" should be one or more of:\n    * r (read)\n    * w (write)\n    * x (execute/search)\n    * t (sticky)\n    * s (setuid/setgid)\n    * X (execute/search if directory or if any one user can execute)\n    * u (user's current permissions)\n    * g (group's current permissions)\n    * o (other's current permissions)\n\nThus, mode `\"0664\"` could be represented symbolically as either `a=r,ug+w`\nor `ug=rw,o=r`.  However, symbolic modes are more expressive than numeric\nmodes: a mode only affects the specified bits, so `mode => 'ug+w'` will\nset the user and group write bits, without affecting any other bits.\n\nSee the manual page for GNU or BSD `chmod` for more details\non numeric and symbolic modes.\n\nOn Windows, permissions are translated as follows:\n\n* Owner and group names are mapped to Windows SIDs\n* The \"other\" class of users maps to the \"Everyone\" SID\n* The read/write/execute permissions map to the `FILE_GENERIC_READ`,\n  `FILE_GENERIC_WRITE`, and `FILE_GENERIC_EXECUTE` access rights; a\n  file's owner always has the `FULL_CONTROL` right\n* \"Other\" users can't have any permissions a file's group lacks,\n  and its group can't have any permissions its owner lacks; that is, \"0644\"\n  is an acceptable mode, but \"0464\" is not."
        },
        {
          "name"=>"mtime",
          "description"=>"A read-only state to check the file mtime. On \\*nix-like systems, this\nis the time of the most recent change to the content of the file."
        },
        {
          "name"=>"owner",
          "description"=>"The user to whom the file should belong.  Argument can be a user name or a\nuser ID.\n\nOn Windows, a group (such as \"Administrators\") can be set as a file's owner\nand a user (such as \"Administrator\") can be set as a file's group; however,\na file's owner and group shouldn't be the same. (If the owner is also\nthe group, files with modes like `\"0640\"` will cause log churn, as they\nwill always appear out of sync.)"
        },
        {
          "name"=>"selrange",
          "description"=>"What the SELinux range component of the context of the file should be.\nAny valid SELinux range component is accepted.  For example `s0` or\n`SystemHigh`.  If not specified it defaults to the value returned by\nmatchpathcon for the file, if any exists.  Only valid on systems with\nSELinux support enabled and that have support for MCS (Multi-Category\nSecurity)."
        },
        {
          "name"=>"selrole",
          "description"=>"What the SELinux role component of the context of the file should be.\nAny valid SELinux role component is accepted.  For example `role_r`.\nIf not specified it defaults to the value returned by matchpathcon for\nthe file, if any exists.  Only valid on systems with SELinux support\nenabled."
        },
        {
          "name"=>"seltype",
          "description"=>"What the SELinux type component of the context of the file should be.\nAny valid SELinux type component is accepted.  For example `tmp_t`.\nIf not specified it defaults to the value returned by matchpathcon for\nthe file, if any exists.  Only valid on systems with SELinux support\nenabled."
        },
        {
          "name"=>"seluser",
          "description"=>"What the SELinux user component of the context of the file should be.\nAny valid SELinux user component is accepted.  For example `user_u`.\nIf not specified it defaults to the value returned by matchpathcon for\nthe file, if any exists.  Only valid on systems with SELinux support\nenabled."
        },
        {
          "name"=>"target",
          "description"=>"The target for creating a link.  Currently, symlinks are the\nonly type supported. This attribute is mutually exclusive with `source`\nand `content`.\n\nSymlink targets can be relative, as well as absolute:\n\n    # (Useful on Solaris)\n    file { '/etc/inetd.conf':\n      ensure => link,\n      target => 'inet/inetd.conf',\n    }\n\nDirectories of symlinks can be served recursively by instead using the\n`source` attribute, setting `ensure` to `directory`, and setting the\n`links` attribute to `manage`.",
          "values"=>[
            "notlink",
            "/./"
          ]
        },
        {
          "name"=>"type",
          "description"=>"A read-only state to check the file type."
        }
      ],
      "parameters"=>[
        {
          "name"=>"backup",
          "description"=>"Whether (and how) file content should be backed up before being replaced.\nThis attribute works best as a resource default in the site manifest\n(`File { backup => main }`), so it can affect all file resources.\n\n* If set to `false`, file content won't be backed up.\n* If set to a string beginning with `.`, such as `.puppet-bak`, Puppet will\n  use copy the file in the same directory with that value as the extension\n  of the backup. (A value of `true` is a synonym for `.puppet-bak`.)\n* If set to any other string, Puppet will try to back up to a filebucket\n  with that title. Puppet automatically creates a **local** filebucket\n  named `puppet` if one doesn't already exist. See the `filebucket` resource\n  type for more details.\n\nDefault value: `false`\n\nBacking up to a local filebucket isn't particularly useful. If you want\nto make organized use of backups, you will generally want to use the\npuppet master server's filebucket service. This requires declaring a\nfilebucket resource and a resource default for the `backup` attribute\nin site.pp:\n\n    # /etc/puppetlabs/puppet/manifests/site.pp\n    filebucket { 'main':\n      path   => false,                # This is required for remote filebuckets.\n      server => 'puppet.example.com', # Optional; defaults to the configured puppet master.\n    }\n\n    File { backup => main, }\n\nIf you are using multiple puppet master servers, you will want to\ncentralize the contents of the filebucket. Either configure your load\nbalancer to direct all filebucket traffic to a single master, or use\nsomething like an out-of-band rsync task to synchronize the content on all\nmasters.\n\n> **Note**: Enabling and using the backup option, and by extension the\n  filebucket resource, requires appropriate planning and management to ensure\n  that sufficient disk space is available for the file backups. Generally, you\n  can implement this using one of the following two options:\n  - Use a `find` command and `crontab` entry to retain only the last X days\n  of file backups. For example:\n\n  ```\n  find /opt/puppetlabs/server/data/puppetserver/bucket -type f -mtime +45 -atime +45 -print0 | xargs -0 rm\n  ```\n\n  - Restrict the directory to a maximum size after which the oldest items are removed.",
          "default"=>"false"
        },
        {
          "name"=>"checksum",
          "description"=>"The checksum type to use when determining whether to replace a file's contents.\n\nThe default checksum type is",
          "values"=>[
            "Puppet::Util::Checksums.known_checksum_types"
          ]
        },
        {
          "name"=>"force",
          "description"=>"Perform the file operation even if it will destroy one or more directories.\nYou must use `force` in order to:\n\n* `purge` subdirectories\n* Replace directories with files or links\n* Remove a directory when `ensure => absent`",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "default"=>"false"
        },
        {
          "name"=>"ignore",
          "description"=>"A parameter which omits action on files matching\nspecified patterns during recursion.  Uses Ruby's builtin globbing\nengine, so shell metacharacters such as `[a-z]*` are fully supported.\nMatches that would descend into the directory structure are ignored,\nsuch as `*/*`."
        },
        {
          "name"=>"links",
          "description"=>"How to handle links during file actions.  During file copying,\n`follow` will copy the target file instead of the link and `manage`\nwill copy the link itself. When not copying, `manage` will manage\nthe link, and `follow` will manage the file to which the link points.",
          "values"=>[
            "follow",
            "manage"
          ],
          "default"=>"manage"
        },
        {
          "name"=>"path",
          "description"=>"The path to the file to manage.  Must be fully qualified.\n\nOn Windows, the path should include the drive letter and should use `/` as\nthe separator character (rather than `\\\\`).",
          "isnamevar"=>true
        },
        {
          "name"=>"provider",
          "description"=>"The specific backend to use for this `file` resource. You will seldom need to specify this --- Puppet will usually discover the appropriate provider for your platform."
        },
        {
          "name"=>"purge",
          "description"=>"Whether unmanaged files should be purged. This option only makes\nsense when `ensure => directory` and `recurse => true`.\n\n* When recursively duplicating an entire directory with the `source`\n  attribute, `purge => true` will automatically purge any files\n  that are not in the source directory.\n* When managing files in a directory as individual resources,\n  setting `purge => true` will purge any files that aren't being\n  specifically managed.\n\nIf you have a filebucket configured, the purged files will be uploaded,\nbut if you do not, this will destroy data.\n\nUnless `force => true` is set, purging will **not** delete directories,\nalthough it will delete the files they contain.\n\nIf `recurselimit` is set and you aren't using `force => true`, purging\nwill obey the recursion limit; files in any subdirectories deeper than the\nlimit will be treated as unmanaged and left alone.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "default"=>"false"
        },
        {
          "name"=>"recurse",
          "description"=>"Whether to recursively manage the _contents_ of a directory. This attribute\nis only used when `ensure => directory` is set. The allowed values are:\n\n* `false` --- The default behavior. The contents of the directory will not be\n  automatically managed.\n* `remote` --- If the `source` attribute is set, Puppet will automatically\n  manage the contents of the source directory (or directories), ensuring\n  that equivalent files and directories exist on the target system and\n  that their contents match.\n\n  Using `remote` will disable the `purge` attribute, but results in faster\n  catalog application than `recurse => true`.\n\n  The `source` attribute is mandatory when `recurse => remote`.\n* `true` --- If the `source` attribute is set, this behaves similarly to\n  `recurse => remote`, automatically managing files from the source directory.\n\n  This also enables the `purge` attribute, which can delete unmanaged\n  files from a directory. See the description of `purge` for more details.\n\n  The `source` attribute is not mandatory when using `recurse => true`, so you\n  can enable purging in directories where all files are managed individually.\n\nBy default, setting recurse to `remote` or `true` will manage _all_\nsubdirectories. You can use the `recurselimit` attribute to limit the\nrecursion depth.",
          "values"=>[
            "true",
            "false",
            "remote"
          ]
        },
        {
          "name"=>"recurselimit",
          "description"=>"How far Puppet should descend into subdirectories, when using\n`ensure => directory` and either `recurse => true` or `recurse => remote`.\nThe recursion limit affects which files will be copied from the `source`\ndirectory, as well as which files can be purged when `purge => true`.\n\nSetting `recurselimit => 0` is the same as setting `recurse => false` ---\nPuppet will manage the directory, but all of its contents will be treated\nas unmanaged.\n\nSetting `recurselimit => 1` will manage files and directories that are\ndirectly inside the directory, but will not manage the contents of any\nsubdirectories.\n\nSetting `recurselimit => 2` will manage the direct contents of the\ndirectory, as well as the contents of the _first_ level of subdirectories.\n\nThis pattern continues for each incremental value of `recurselimit`.",
          "values"=>[
            "/^[0-9]+$/"
          ]
        },
        {
          "name"=>"replace",
          "description"=>"Whether to replace a file or symlink that already exists on the local system but\nwhose content doesn't match what the `source` or `content` attribute\nspecifies.  Setting this to false allows file resources to initialize files\nwithout overwriting future changes.  Note that this only affects content;\nPuppet will still manage ownership and permissions.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "default"=>"true"
        },
        {
          "name"=>"selinux_ignore_defaults",
          "description"=>"If this is set then Puppet will not ask SELinux (via matchpathcon) to\nsupply defaults for the SELinux attributes (seluser, selrole,\nseltype, and selrange). In general, you should leave this set at its\ndefault and only set it to true when you need Puppet to not try to fix\nSELinux labels automatically.",
          "values"=>[
            "true",
            "false"
          ],
          "default"=>"false"
        },
        {
          "name"=>"show_diff",
          "description"=>"Whether to display differences when the file changes, defaulting to\ntrue.  This parameter is useful for files that may contain passwords or\nother secret data, which might otherwise be included in Puppet reports or\nother insecure outputs.  If the global `show_diff` setting\nis false, then no diffs will be shown even if this parameter is true.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "default"=>"true"
        },
        {
          "name"=>"source",
          "description"=>"A source file, which will be copied into place on the local system. This\nattribute is mutually exclusive with `content` and `target`. Allowed\nvalues are:\n\n* `puppet:` URIs, which point to files in modules or Puppet file server\nmount points.\n* Fully qualified paths to locally available files (including files on NFS\nshares or Windows mapped drives).\n* `file:` URIs, which behave the same as local file paths.\n* `http(s):` URIs, which point to files served by common web servers.\n\nThe normal form of a `puppet:` URI is:\n\n`puppet:///modules/<MODULE NAME>/<FILE PATH>`\n\nThis will fetch a file from a module on the Puppet master (or from a\nlocal module when using Puppet apply). Given a `modulepath` of\n`/etc/puppetlabs/code/modules`, the example above would resolve to\n`/etc/puppetlabs/code/modules/<MODULE NAME>/files/<FILE PATH>`.\n\nUnlike `content`, the `source` attribute can be used to recursively copy\ndirectories if the `recurse` attribute is set to `true` or `remote`. If\na source directory contains symlinks, use the `links` attribute to\nspecify whether to recreate links or follow them.\n\n_HTTP_ URIs cannot be used to recursively synchronize whole directory\ntrees. You cannot use `source_permissions` values other than `ignore`\nbecause HTTP servers do not transfer any metadata that translates to\nownership or permission details.\n\nPuppet determines if file content is synchronized by computing a checksum\nfor the local file and comparing it against the `checksum_value`\nparameter. If the `checksum_value` parameter is not specified for\n`puppet` and `file` sources, Puppet computes a checksum based on its\n`Puppet[:digest_algorithm]`. For `http(s)` sources, Puppet uses the\nfirst HTTP header it recognizes out of the following list:\n`X-Checksum-Sha256`, `X-Checksum-Sha1`, `X-Checksum-Md5` or `Content-MD5`.\nIf the server response does not include one of these headers, Puppet\ndefaults to using the `Last-Modified` header. Puppet updates the local\nfile if the header is newer than the modified time (mtime) of the local\nfile.\n\n_HTTP_ URIs can include a user information component so that Puppet can\nretrieve file metadata and content from HTTP servers that require HTTP Basic\nauthentication. For example `https://<user>:<pass>@<server>:<port>/path/to/file.`\n\nWhen connecting to _HTTPS_ servers, Puppet trusts CA certificates in the\npuppet-agent certificate bundle and the Puppet CA. You can configure Puppet\nto trust additional CA certificates using the `Puppet[:ssl_trust_store]`\nsetting.\n\nMultiple `source` values can be specified as an array, and Puppet will\nuse the first source that exists. This can be used to serve different\nfiles to different system types:\n\n    file { '/etc/nfs.conf':\n      source => [\n        \"puppet:///modules/nfs/conf.${host}\",\n        \"puppet:///modules/nfs/conf.${operatingsystem}\",\n        'puppet:///modules/nfs/conf'\n      ]\n    }\n\nAlternately, when serving directories recursively, multiple sources can\nbe combined by setting the `sourceselect` attribute to `all`."
        },
        {
          "name"=>"source_permissions",
          "description"=>"Whether (and how) Puppet should copy owner, group, and mode permissions from\nthe `source` to `file` resources when the permissions are not explicitly\nspecified. (In all cases, explicit permissions will take precedence.)\nValid values are `use`, `use_when_creating`, and `ignore`:\n\n* `ignore` (the default) will never apply the owner, group, or mode from\n  the `source` when managing a file. When creating new files without explicit\n  permissions, the permissions they receive will depend on platform-specific\n  behavior. On POSIX, Puppet will use the umask of the user it is running as.\n  On Windows, Puppet will use the default DACL associated with the user it is\n  running as.\n* `use` will cause Puppet to apply the owner, group,\n  and mode from the `source` to any files it is managing.\n* `use_when_creating` will only apply the owner, group, and mode from the\n  `source` when creating a file; existing files will not have their permissions\n  overwritten.",
          "values"=>[
            "use",
            "use_when_creating",
            "ignore"
          ],
          "default"=>"ignore"
        },
        {
          "name"=>"sourceselect",
          "description"=>"Whether to copy all valid sources, or just the first one.  This parameter\nonly affects recursive directory copies; by default, the first valid\nsource is the only one used, but if this parameter is set to `all`, then\nall valid sources will have all of their contents copied to the local\nsystem. If a given file exists in more than one source, the version from\nthe earliest source in the list will be used.",
          "values"=>[
            "first",
            "all"
          ],
          "default"=>"first"
        },
        {
          "name"=>"staging_location",
          "description"=>"When rendering a file first render it to this location. The default\nlocation is the same path as the desired location with a unique filename.\nThis parameter is useful in conjuction with validate_cmd to test a\nfile before moving the file to it's final location.\nWARNING: File replacement is only guaranteed to be atomic if the staging\nlocation is on the same filesystem as the final location."
        },
        {
          "name"=>"validate_cmd",
          "description"=>"A command for validating the file's syntax before replacing it. If\nPuppet would need to rewrite a file due to new `source` or `content`, it\nwill check the new content's validity first. If validation fails, the file\nresource will fail.\n\nThis command must have a fully qualified path, and should contain a\npercent (`%`) token where it would expect an input file. It must exit `0`\nif the syntax is correct, and non-zero otherwise. The command will be\nrun on the target system while applying the catalog, not on the puppet master.\n\nExample:\n\n    file { '/etc/apache2/apache2.conf':\n      content      => 'example',\n      validate_cmd => '/usr/sbin/apache2 -t -f %',\n    }\n\nThis would replace apache2.conf only if the test returned true.\n\nNote that if a validation command requires a `%` as part of its text,\nyou can specify a different placeholder token with the\n`validate_replacement` attribute."
        },
        {
          "name"=>"validate_replacement",
          "description"=>"The replacement string in a `validate_cmd` that will be replaced\nwith an input file name.",
          "default"=>"%"
        }
      ],
      "features"=>[
        {
          "name"=>"manages_symlinks",
          "description"=>"The provider can manage symbolic links."
        }
      ],
      "providers"=>[
        {
          "name"=>"posix",
          "type_name"=>"file",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/file/posix.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Uses POSIX functionality to manage file ownership and permissions."
          },
          "confines"=>{
            "feature"=>"posix"
          },
          "features"=>[
            "manages_symlinks"
          ]
        },
        {
          "name"=>"windows",
          "type_name"=>"file",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/file/windows.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Uses Microsoft Windows functionality to manage file ownership and permissions."
          },
          "confines"=>{
            "operatingsystem"=>"windows"
          }
        }
      ]
    },
    {
      "name"=>"filebucket",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/filebucket.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"A repository for storing and retrieving file content by MD5 checksum. Can\nbe local to each agent node, or centralized on a puppet master server. All\npuppet servers provide a filebucket service that agent nodes can access\nvia HTTP, but you must declare a filebucket resource before any agents\nwill do so.\n\nFilebuckets are used for the following features:\n\n- **Content backups.** If the `file` type's `backup` attribute is set to\n  the name of a filebucket, Puppet will back up the _old_ content whenever\n  it rewrites a file; see the documentation for the `file` type for more\n  details. These backups can be used for manual recovery of content, but\n  are more commonly used to display changes and differences in a tool like\n  Puppet Dashboard.\n\nTo use a central filebucket for backups, you will usually want to declare\na filebucket resource and a resource default for the `backup` attribute\nin site.pp:\n\n    # /etc/puppetlabs/puppet/manifests/site.pp\n    filebucket { 'main':\n      path   => false,                # This is required for remote filebuckets.\n      server => 'puppet.example.com', # Optional; defaults to the configured puppet master.\n    }\n\n    File { backup => main, }\n\nPuppet Servers automatically provide the filebucket service, so\nthis will work in a default configuration. If you have a heavily\nrestricted Puppet Server `auth.conf` file, you may need to allow access to the\n`file_bucket_file` endpoint."
      },
      "parameters"=>[
        {
          "name"=>"name",
          "description"=>"The name of the filebucket.",
          "isnamevar"=>true
        },
        {
          "name"=>"path",
          "description"=>"The path to the _local_ filebucket; defaults to the value of the\n`clientbucketdir` setting.  To use a remote filebucket, you _must_ set\nthis attribute to `false`."
        },
        {
          "name"=>"port",
          "description"=>"The port on which the remote server is listening.\n\nThis setting is _only_ consulted if the `path` attribute is set to `false`.\n\nIf this attribute is not specified, the first entry in the `server_list`\nconfiguration setting is used, followed by the value of the `serverport`\nsetting if `server_list` is not set."
        },
        {
          "name"=>"server",
          "description"=>"The server providing the remote filebucket service.\n\nThis setting is _only_ consulted if the `path` attribute is set to `false`.\n\nIf this attribute is not specified, the first entry in the `server_list`\nconfiguration setting is used, followed by the value of the `server` setting\nif `server_list` is not set."
        }
      ]
    },
    {
      "name"=>"group",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/group.rb",
      "line"=>7,
      "docstring"=>{
        "text"=>"Manage groups. On most platforms this can only create groups.\nGroup membership must be managed on individual users.\n\nOn some platforms such as OS X, group membership is managed as an\nattribute of the group, not the user record. Providers must have\nthe feature 'manages_members' to manage the 'members' property of\na group record."
      },
      "properties"=>[
        {
          "name"=>"attributes",
          "description"=>"Specify group AIX attributes, as an array of `'key=value'` strings. This\nparameter's behavior can be configured with `attribute_membership`.",
          "required_features"=>"manages_aix_lam"
        },
        {
          "name"=>"ensure",
          "description"=>"Create or remove the group.",
          "values"=>[
            "present",
            "absent"
          ],
          "default"=>"present"
        },
        {
          "name"=>"gid",
          "description"=>"The group ID.  Must be specified numerically.  If no group ID is\nspecified when creating a new group, then one will be chosen\nautomatically according to local system standards. This will likely\nresult in the same group having different GIDs on different systems,\nwhich is not recommended.\n\nOn Windows, this property is read-only and will return the group's security\nidentifier (SID)."
        },
        {
          "name"=>"members",
          "description"=>"The members of the group. For platforms or directory services where group\nmembership is stored in the group objects, not the users. This parameter's\nbehavior can be configured with `auth_membership`.",
          "required_features"=>"manages_members"
        }
      ],
      "parameters"=>[
        {
          "name"=>"allowdupe",
          "description"=>"Whether to allow duplicate GIDs.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "default"=>"false"
        },
        {
          "name"=>"attribute_membership",
          "description"=>"AIX only. Configures the behavior of the `attributes` parameter.\n\n* `minimum` (default) --- The provided list of attributes is partial, and Puppet\n  **ignores** any attributes that aren't listed there.\n* `inclusive` --- The provided list of attributes is comprehensive, and\n  Puppet **purges** any attributes that aren't listed there.",
          "values"=>[
            "inclusive",
            "minimum"
          ],
          "default"=>"minimum"
        },
        {
          "name"=>"auth_membership",
          "description"=>"Configures the behavior of the `members` parameter.\n\n* `false` (default) --- The provided list of group members is partial,\n  and Puppet **ignores** any members that aren't listed there.\n* `true` --- The provided list of of group members is comprehensive, and\n  Puppet **purges** any members that aren't listed there.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "default"=>"false"
        },
        {
          "name"=>"forcelocal",
          "description"=>"Forces the management of local accounts when accounts are also\nbeing managed by some other Name Switch Service (NSS). For AIX, refer to the `ia_load_module` parameter.\n\nThis option relies on your operating system's implementation of `luser*` commands, such as `luseradd` , `lgroupadd`, and `lusermod`. The `forcelocal` option could behave unpredictably in some circumstances. If the tools it depends on are not available, it might have no effect at all.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "required_features"=>"manages_local_users_and_groups",
          "default"=>"false"
        },
        {
          "name"=>"ia_load_module",
          "description"=>"The name of the I&A module to use to manage this group.\nThis should be set to `files` if managing local groups.",
          "required_features"=>"manages_aix_lam"
        },
        {
          "name"=>"name",
          "description"=>"The group name. While naming limitations vary by operating system,\nit is advisable to restrict names to the lowest common denominator,\nwhich is a maximum of 8 characters beginning with a letter.\n\nNote that Puppet considers group names to be case-sensitive, regardless\nof the platform's own rules; be sure to always use the same case when\nreferring to a given group.",
          "isnamevar"=>true
        },
        {
          "name"=>"provider",
          "description"=>"The specific backend to use for this `group` resource. You will seldom need to specify this --- Puppet will usually discover the appropriate provider for your platform."
        },
        {
          "name"=>"system",
          "description"=>"Whether the group is a system group with lower GID.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "default"=>"false"
        }
      ],
      "features"=>[
        {
          "name"=>"manages_aix_lam",
          "description"=>"The provider can manage AIX Loadable Authentication Module (LAM) system."
        },
        {
          "name"=>"manages_local_users_and_groups",
          "description"=>"Allows local groups to be managed on systems that also use some other remote Name Switch Service (NSS) method of managing accounts."
        },
        {
          "name"=>"manages_members",
          "description"=>"For directories where membership is an attribute of groups not users."
        },
        {
          "name"=>"system_groups",
          "description"=>"The provider allows you to create system groups with lower GIDs."
        }
      ],
      "providers"=>[
        {
          "name"=>"aix",
          "type_name"=>"group",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/group/aix.rb",
          "line"=>5,
          "docstring"=>{
            "text"=>"Group management for AIX."
          },
          "confines"=>{
            "operatingsystem"=>"aix"
          },
          "features"=>[
            "manages_aix_lam",
            "manages_members",
            "manages_local_users_and_groups"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "aix"
              ]
            ]
          ],
          "commands"=>{
            "list"=>"/usr/sbin/lsgroup",
            "add"=>"/usr/bin/mkgroup",
            "delete"=>"/usr/sbin/rmgroup",
            "modify"=>"/usr/bin/chgroup"
          }
        },
        {
          "name"=>"directoryservice",
          "type_name"=>"group",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/group/directoryservice.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Group management using DirectoryService on OS X."
          },
          "confines"=>{
            "operatingsystem"=>"darwin"
          },
          "features"=>[
            "manages_members"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "darwin"
              ]
            ]
          ],
          "commands"=>{
            "dscl"=>"/usr/bin/dscl"
          }
        },
        {
          "name"=>"groupadd",
          "type_name"=>"group",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/group/groupadd.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Group management via `groupadd` and its ilk. The default for most platforms."
          },
          "commands"=>{
            "add"=>"groupadd",
            "delete"=>"groupdel",
            "modify"=>"groupmod"
          }
        },
        {
          "name"=>"ldap",
          "type_name"=>"group",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/group/ldap.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Group management via LDAP.\n\nThis provider requires that you have valid values for all of the\nLDAP-related settings in `puppet.conf`, including `ldapbase`.  You will\nalmost definitely need settings for `ldapuser` and `ldappassword` in order\nfor your clients to write to LDAP.\n\nNote that this provider will automatically generate a GID for you if you do\nnot specify one, but it is a potentially expensive operation, as it\niterates across all existing groups to pick the appropriate next one."
          },
          "confines"=>{
            "feature"=>"ldap",
            "false"=>"(Puppet[:ldapuser] == \"\")"
          }
        },
        {
          "name"=>"pw",
          "type_name"=>"group",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/group/pw.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Group management via `pw` on FreeBSD and DragonFly BSD."
          },
          "confines"=>{
            "operatingsystem"=>"[:freebsd, :dragonfly]"
          },
          "features"=>[
            "manages_members"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "[:freebsd, :dragonfly]"
              ]
            ]
          ],
          "commands"=>{
            "pw"=>"pw"
          }
        },
        {
          "name"=>"windows_adsi",
          "type_name"=>"group",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/group/windows_adsi.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Local group management for Windows. Group members can be both users and groups.\nAdditionally, local groups can contain domain users."
          },
          "confines"=>{
            "operatingsystem"=>"windows"
          },
          "features"=>[
            "manages_members"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "windows"
              ]
            ]
          ]
        }
      ]
    },
    {
      "name"=>"notify",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/notify.rb",
      "line"=>6,
      "docstring"=>{
        "text"=>"Sends an arbitrary message, specified as a string, to the agent run-time log. It's important to note that the notify resource type is not idempotent. As a result, notifications are shown as a change on every Puppet run."
      },
      "properties"=>[
        {
          "name"=>"message",
          "description"=>"The message to be sent to the log. Note that the value specified must be a string."
        }
      ],
      "parameters"=>[
        {
          "name"=>"name",
          "description"=>"An arbitrary tag for your own reference; the name of the message.",
          "isnamevar"=>true
        },
        {
          "name"=>"withpath",
          "description"=>"Whether to show the full object path.",
          "values"=>[
            "true",
            "false"
          ],
          "default"=>"false"
        }
      ]
    },
    {
      "name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/package.rb",
      "line"=>11,
      "docstring"=>{
        "text"=>"Manage packages.  There is a basic dichotomy in package\nsupport right now:  Some package types (such as yum and apt) can\nretrieve their own package files, while others (such as rpm and sun)\ncannot.  For those package formats that cannot retrieve their own files,\nyou can use the `source` parameter to point to the correct file.\n\nPuppet will automatically guess the packaging format that you are\nusing based on the platform you are on, but you can override it\nusing the `provider` parameter; each provider defines what it\nrequires in order to function, and you must meet those requirements\nto use a given provider.\n\nYou can declare multiple package resources with the same `name` as long\nas they have unique titles, and specify different providers and commands.\n\nNote that you must use the _title_ to make a reference to a package\nresource; `Package[<NAME>]` is not a synonym for `Package[<TITLE>]` like\nit is for many other resource types.\n\n**Autorequires:** If Puppet is managing the files specified as a\npackage's `adminfile`, `responsefile`, or `source`, the package\nresource will autorequire those files."
      },
      "properties"=>[
        {
          "name"=>"ensure",
          "description"=>"What state the package should be in. On packaging systems that can\nretrieve new packages on their own, you can choose which package to\nretrieve by specifying a version number or `latest` as the ensure\nvalue. On packaging systems that manage configuration files separately\nfrom \"normal\" system files, you can uninstall config files by\nspecifying `purged` as the ensure value. This defaults to `installed`.\n\nVersion numbers must match the full version to install, including\nrelease if the provider uses a release moniker. For\nexample, to install the bash package from the rpm\n`bash-4.1.2-29.el6.x86_64.rpm`, use the string `'4.1.2-29.el6'`.\n\nOn supported providers, version ranges can also be ensured. For example,\ninequalities: `<2.0.0`, or intersections: `>1.0.0 <2.0.0`.",
          "values"=>[
            "present",
            "absent",
            "purged",
            "disabled",
            "installed",
            "latest",
            "/./"
          ],
          "aliases"=>{
            "installed"=>"present"
          },
          "default"=>"installed"
        },
        {
          "name"=>"flavor",
          "description"=>"OpenBSD and DNF modules support 'flavors', which are\nfurther specifications for which type of package you want.",
          "required_features"=>"supports_flavors"
        },
        {
          "name"=>"mark",
          "description"=>"Set to hold to tell Debian apt/Solaris pkg to hold the package version\n\n\#{mark_doc}\nDefault is \"none\". Mark can be specified with or without `ensure`,\nif `ensure` is missing will default to \"present\".\n\nMark cannot be specified together with \"purged\", or \"absent\"\nvalues for `ensure`.",
          "values"=>[
            "hold",
            "none"
          ],
          "required_features"=>"holdable"
        },
        {
          "name"=>"package_settings",
          "description"=>"Settings that can change the contents or configuration of a package.\n\nThe formatting and effects of package_settings are provider-specific; any\nprovider that implements them must explain how to use them in its\ndocumentation. (Our general expectation is that if a package is\ninstalled but its settings are out of sync, the provider should\nre-install that package with the desired settings.)\n\nAn example of how package_settings could be used is FreeBSD's port build\noptions --- a future version of the provider could accept a hash of options,\nand would reinstall the port if the installed version lacked the correct\nsettings.\n\n    package { 'www/apache22':\n      package_settings => { 'SUEXEC' => false }\n    }\n\nAgain, check the documentation of your platform's package provider to see\nthe actual usage.",
          "required_features"=>"package_settings"
        }
      ],
      "parameters"=>[
        {
          "name"=>"adminfile",
          "description"=>"A file containing package defaults for installing packages.\n\nThis attribute is only used on Solaris. Its value should be a path to a\nlocal file stored on the target system. Solaris's package tools expect\neither an absolute file path or a relative path to a file in\n`/var/sadm/install/admin`.\n\nThe value of `adminfile` will be passed directly to the `pkgadd` or\n`pkgrm` command with the `-a <ADMINFILE>` option."
        },
        {
          "name"=>"allow_virtual",
          "description"=>"Specifies if virtual package names are allowed for install and uninstall.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "required_features"=>"virtual_packages"
        },
        {
          "name"=>"allowcdrom",
          "description"=>"Tells apt to allow cdrom sources in the sources.list file.\nNormally apt will bail if you try this.",
          "values"=>[
            "true",
            "false"
          ]
        },
        {
          "name"=>"category",
          "description"=>"A read-only parameter set by the package."
        },
        {
          "name"=>"command",
          "description"=>"The targeted command to use when managing a package:\n\n  package { 'mysql':\n    provider => gem,\n  }\n\n  package { 'mysql-opt':\n    name     => 'mysql',\n    provider => gem,\n    command  => '/opt/ruby/bin/gem',\n  }\n\nEach provider defines a package management command; and uses the first\ninstance of the command found in the PATH.\n\nProviders supporting the targetable feature allow you to specify the\nabsolute path of the package management command; useful when multiple\ninstances of the command are installed, or the command is not in the PATH.",
          "isnamevar"=>true,
          "required_features"=>"targetable",
          "default"=>"default"
        },
        {
          "name"=>"configfiles",
          "description"=>"Whether to keep or replace modified config files when installing or\nupgrading a package. This only affects the `apt` and `dpkg` providers.",
          "values"=>[
            "keep",
            "replace"
          ],
          "default"=>"keep"
        },
        {
          "name"=>"description",
          "description"=>"A read-only parameter set by the package."
        },
        {
          "name"=>"enable_only",
          "description"=>"Tells `dnf module` to only enable a specific module, instead\nof installing its default profile.\n\nModules with no default profile will be enabled automatically\nwithout the use of this parameter.\n\nConflicts with the `flavor` property, which selects a profile\nto install.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "default"=>"false"
        },
        {
          "name"=>"install_only",
          "description"=>"It should be set for packages that should only ever be installed,\nnever updated. Kernels in particular fall into this category.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "required_features"=>"install_only",
          "default"=>"false"
        },
        {
          "name"=>"install_options",
          "description"=>"An array of additional options to pass when installing a package. These\noptions are package-specific, and should be documented by the software\nvendor.  One commonly implemented option is `INSTALLDIR`:\n\n    package { 'mysql':\n      ensure          => installed,\n      source          => 'N:/packages/mysql-5.5.16-winx64.msi',\n      install_options => [ '/S', { 'INSTALLDIR' => 'C:\\\\mysql-5.5' } ],\n    }\n\nEach option in the array can either be a string or a hash, where each\nkey and value pair are interpreted in a provider specific way.  Each\noption will automatically be quoted when passed to the install command.\n\nWith Windows packages, note that file paths in an install option must\nuse backslashes. (Since install options are passed directly to the\ninstallation command, forward slashes won't be automatically converted\nlike they are in `file` resources.) Note also that backslashes in\ndouble-quoted strings _must_ be escaped and backslashes in single-quoted\nstrings _can_ be escaped.",
          "required_features"=>"install_options"
        },
        {
          "name"=>"instance",
          "description"=>"A read-only parameter set by the package."
        },
        {
          "name"=>"name",
          "description"=>"The package name.  This is the name that the packaging\nsystem uses internally, which is sometimes (especially on Solaris)\na name that is basically useless to humans.  If a package goes by\nseveral names, you can use a single title and then set the name\nconditionally:\n\n    # In the 'openssl' class\n    $ssl = $operatingsystem ? {\n      solaris => SMCossl,\n      default => openssl\n    }\n\n    package { 'openssl':\n      ensure => installed,\n      name   => $ssl,\n    }\n\n    ...\n\n    $ssh = $operatingsystem ? {\n      solaris => SMCossh,\n      default => openssh\n    }\n\n    package { 'openssh':\n      ensure  => installed,\n      name    => $ssh,\n      require => Package['openssl'],\n    }",
          "isnamevar"=>true
        },
        {
          "name"=>"platform",
          "description"=>"A read-only parameter set by the package."
        },
        {
          "name"=>"provider",
          "description"=>"The specific backend to use for this `package` resource. You will seldom need to specify this --- Puppet will usually discover the appropriate provider for your platform."
        },
        {
          "name"=>"reinstall_on_refresh",
          "description"=>"Whether this resource should respond to refresh events (via `subscribe`,\n`notify`, or the `~>` arrow) by reinstalling the package. Only works for\nproviders that support the `reinstallable` feature.\n\nThis is useful for source-based distributions, where you may want to\nrecompile a package if the build options change.\n\nIf you use this, be careful of notifying classes when you want to restart\nservices. If the class also contains a refreshable package, doing so could\ncause unnecessary re-installs.",
          "values"=>[
            "true",
            "false"
          ],
          "default"=>"false"
        },
        {
          "name"=>"responsefile",
          "description"=>"A file containing any necessary answers to questions asked by\nthe package.  This is currently used on Solaris and Debian.  The\nvalue will be validated according to system rules, but it should\ngenerally be a fully qualified path."
        },
        {
          "name"=>"root",
          "description"=>"A read-only parameter set by the package."
        },
        {
          "name"=>"source",
          "description"=>"Where to find the package file. This is mostly used by providers that don't\nautomatically download packages from a central repository. (For example:\nthe `yum` provider ignores this attribute, `apt` provider uses it if present\nand the `rpm` and `dpkg` providers require it.)\n\nDifferent providers accept different values for `source`. Most providers\naccept paths to local files stored on the target system. Some providers\nmay also accept URLs or network drive paths. Puppet will not\nautomatically retrieve source files for you, and usually just passes the\nvalue of `source` to the package installation command.\n\nYou can use a `file` resource if you need to manually copy package files\nto the target system."
        },
        {
          "name"=>"status",
          "description"=>"A read-only parameter set by the package."
        },
        {
          "name"=>"uninstall_options",
          "description"=>"An array of additional options to pass when uninstalling a package. These\noptions are package-specific, and should be documented by the software\nvendor.  For example:\n\n    package { 'VMware Tools':\n      ensure            => absent,\n      uninstall_options => [ { 'REMOVE' => 'Sync,VSS' } ],\n    }\n\nEach option in the array can either be a string or a hash, where each\nkey and value pair are interpreted in a provider specific way.  Each\noption will automatically be quoted when passed to the uninstall\ncommand.\n\nOn Windows, this is the **only** place in Puppet where backslash\nseparators should be used.  Note that backslashes in double-quoted\nstrings _must_ be double-escaped and backslashes in single-quoted\nstrings _may_ be double-escaped.",
          "required_features"=>"uninstall_options"
        },
        {
          "name"=>"vendor",
          "description"=>"A read-only parameter set by the package."
        }
      ],
      "features"=>[
        {
          "name"=>"disableable",
          "description"=>"The provider can disable packages. This feature is used by specifying `disabled` as the desired value for the package."
        },
        {
          "name"=>"holdable",
          "description"=>"The provider is capable of placing packages on hold such that they are not automatically upgraded as a result of other package dependencies unless explicit action is taken by a user or another package."
        },
        {
          "name"=>"install_only",
          "description"=>"The provider accepts options to only install packages never update (kernels, etc.)"
        },
        {
          "name"=>"install_options",
          "description"=>"The provider accepts options to be passed to the installer command."
        },
        {
          "name"=>"installable",
          "description"=>"The provider can install packages."
        },
        {
          "name"=>"package_settings",
          "description"=>"The provider accepts package_settings to be ensured for the given package. The meaning and format of these settings is provider-specific."
        },
        {
          "name"=>"purgeable",
          "description"=>"The provider can purge packages.  This generally means that all traces of the package are removed, including existing configuration files.  This feature is thus destructive and should be used with the utmost care."
        },
        {
          "name"=>"reinstallable",
          "description"=>"The provider can reinstall packages."
        },
        {
          "name"=>"supports_flavors",
          "description"=>"The provider accepts flavors, which are specific variants of packages."
        },
        {
          "name"=>"targetable",
          "description"=>"The provider accepts a targeted package management command."
        },
        {
          "name"=>"uninstall_options",
          "description"=>"The provider accepts options to be passed to the uninstaller command."
        },
        {
          "name"=>"uninstallable",
          "description"=>"The provider can uninstall packages."
        },
        {
          "name"=>"upgradeable",
          "description"=>"The provider can upgrade to the latest version of a package.  This feature is used by specifying `latest` as the desired value for the package."
        },
        {
          "name"=>"version_ranges",
          "description"=>"The provider can ensure version ranges."
        },
        {
          "name"=>"versionable",
          "description"=>"The provider is capable of interrogating the package database for installed version(s), and can select which out of a set of available versions of a package to install if asked."
        },
        {
          "name"=>"virtual_packages",
          "description"=>"The provider accepts virtual package names for install and uninstall."
        }
      ],
      "providers"=>[
        {
          "name"=>"aix",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/aix.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Installation from an AIX software directory, using the AIX `installp`\ncommand.  The `source` parameter is required for this provider, and should\nbe set to the absolute path (on the puppet agent machine) of a directory\ncontaining one or more BFF package files.\n\nThe `installp` command will generate a table of contents file (named `.toc`)\nin this directory, and the `name` parameter (or resource title) that you\nspecify for your `package` resource must match a package name that exists\nin the `.toc` file.\n\nNote that package downgrades are *not* supported; if your resource specifies\na specific version number and there is already a newer version of the package\ninstalled on the machine, the resource will fail with an error message."
          },
          "confines"=>{
            "operatingsystem"=>"[ :aix ]"
          },
          "features"=>[
            "versionable"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "aix"
              ]
            ]
          ],
          "commands"=>{
            "lslpp"=>"/usr/bin/lslpp",
            "installp"=>"/usr/sbin/installp"
          }
        },
        {
          "name"=>"appdmg",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/appdmg.rb",
          "line"=>17,
          "docstring"=>{
            "text"=>"Package management which copies application bundles to a target."
          },
          "confines"=>{
            "operatingsystem"=>"darwin",
            "feature"=>"cfpropertylist"
          },
          "commands"=>{
            "hdiutil"=>"/usr/bin/hdiutil",
            "curl"=>"/usr/bin/curl",
            "ditto"=>"/usr/bin/ditto"
          }
        },
        {
          "name"=>"apple",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/apple.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Package management based on OS X's built-in packaging system.  This is\nessentially the simplest and least functional package system in existence --\nit only supports installation; no deletion or upgrades.  The provider will\nautomatically add the `.pkg` extension, so leave that off when specifying\nthe package name."
          },
          "confines"=>{
            "operatingsystem"=>"darwin"
          },
          "commands"=>{
            "installer"=>"/usr/sbin/installer"
          }
        },
        {
          "name"=>"apt",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/apt.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Package management via `apt-get`.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to apt-get.\nThese options should be specified as an array where each element is either a\n string or a hash."
          },
          "features"=>[
            "versionable",
            "install_options",
            "virtual_packages"
          ],
          "defaults"=>[
            [
              [
                "osfamily",
                "debian"
              ]
            ]
          ],
          "commands"=>{
            "aptget"=>"/usr/bin/apt-get",
            "aptcache"=>"/usr/bin/apt-cache",
            "aptmark"=>"/usr/bin/apt-mark",
            "preseed"=>"/usr/bin/debconf-set-selections"
          }
        },
        {
          "name"=>"aptitude",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/aptitude.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Package management via `aptitude`."
          },
          "features"=>[
            "versionable"
          ],
          "commands"=>{
            "aptitude"=>"/usr/bin/aptitude",
            "aptcache"=>"/usr/bin/apt-cache"
          }
        },
        {
          "name"=>"aptrpm",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/aptrpm.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Package management via `apt-get` ported to `rpm`."
          },
          "features"=>[
            "versionable"
          ],
          "commands"=>{
            "aptget"=>"apt-get",
            "aptcache"=>"apt-cache",
            "rpm"=>"rpm"
          }
        },
        {
          "name"=>"blastwave",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/blastwave.rb",
          "line"=>2,
          "docstring"=>{
            "text"=>"Package management using Blastwave.org's `pkg-get` command on Solaris."
          },
          "confines"=>{
            "osfamily"=>"solaris"
          },
          "commands"=>{
            "pkgget"=>"pkgget"
          }
        },
        {
          "name"=>"dnf",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/dnf.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Support via `dnf`.\n\nUsing this provider's `uninstallable` feature will not remove dependent packages. To\nremove dependent packages with this provider use the `purgeable` feature, but note this\nfeature is destructive and should be used with the utmost care.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to dnf.\nThese options should be specified as an array where each element is either\n a string or a hash."
          },
          "features"=>[
            "install_options",
            "versionable",
            "virtual_packages",
            "install_only"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "fedora"
              ]
            ],
            [
              [
                "osfamily",
                "redhat"
              ]
            ]
          ],
          "commands"=>{
            "cmd"=>"dnf",
            "rpm"=>"rpm"
          }
        },
        {
          "name"=>"dnfmodule",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/dnfmodule.rb",
          "line"=>13,
          "docstring"=>{
            "text"=>""
          },
          "features"=>[
            "installable",
            "uninstallable",
            "versionable",
            "supports_flavors",
            "disableable"
          ],
          "commands"=>{
            "dnf"=>"/usr/bin/dnf"
          }
        },
        {
          "name"=>"dpkg",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/dpkg.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Package management via `dpkg`.  Because this only uses `dpkg`\nand not `apt`, you must specify the source of any packages you want\nto manage."
          },
          "features"=>[
            "holdable",
            "virtual_packages"
          ],
          "commands"=>{
            "dpkg"=>"/usr/bin/dpkg",
            "dpkg_deb"=>"/usr/bin/dpkg-deb",
            "dpkgquery"=>"/usr/bin/dpkg-query"
          }
        },
        {
          "name"=>"fink",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/fink.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Package management via `fink`."
          },
          "features"=>[
            "versionable"
          ],
          "commands"=>{
            "fink"=>"/sw/bin/fink",
            "aptget"=>"/sw/bin/apt-get",
            "aptcache"=>"/sw/bin/apt-cache",
            "dpkgquery"=>"/sw/bin/dpkg-query"
          }
        },
        {
          "name"=>"freebsd",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/freebsd.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"The specific form of package management on FreeBSD.  This is an\nextremely quirky packaging system, in that it freely mixes between\nports and packages.  Apparently all of the tools are written in Ruby,\nso there are plans to rewrite this support to directly use those\nlibraries."
          },
          "confines"=>{
            "operatingsystem"=>"freebsd"
          },
          "commands"=>{
            "pkginfo"=>"/usr/sbin/pkg_info",
            "pkgadd"=>"/usr/sbin/pkg_add",
            "pkgdelete"=>"/usr/sbin/pkg_delete"
          }
        },
        {
          "name"=>"gem",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/gem.rb",
          "line"=>7,
          "docstring"=>{
            "text"=>"Ruby Gem support. If a URL is passed via `source`, then that URL is\nappended to the list of remote gem repositories; to ensure that only the\nspecified source is used, also pass `--clear-sources` via `install_options`.\nIf source is present but is not a valid URL, it will be interpreted as the\npath to a local gem file. If source is not present, the gem will be\ninstalled from the default gem repositories. Note that to modify this for Windows, it has to be a valid URL.\n\nThis provider supports the `install_options` and `uninstall_options` attributes,\nwhich allow command-line flags to be passed to the gem command.\nThese options should be specified as an array where each element is either a\nstring or a hash."
          },
          "features"=>[
            "versionable",
            "install_options",
            "uninstall_options",
            "targetable",
            "version_ranges"
          ]
        },
        {
          "name"=>"hpux",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/hpux.rb",
          "line"=>5,
          "docstring"=>{
            "text"=>"HP-UX's packaging system."
          },
          "confines"=>{
            "operatingsystem"=>"hp-ux"
          },
          "defaults"=>[
            [
              [
                "operatingsystem",
                "hp-ux"
              ]
            ]
          ],
          "commands"=>{
            "swinstall"=>"/usr/sbin/swinstall",
            "swlist"=>"/usr/sbin/swlist",
            "swremove"=>"/usr/sbin/swremove"
          }
        },
        {
          "name"=>"macports",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/macports.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Package management using MacPorts on OS X.\n\nSupports MacPorts versions and revisions, but not variants.\nVariant preferences may be specified using\n[the MacPorts variants.conf file](http://guide.macports.org/chunked/internals.configuration-files.html#internals.configuration-files.variants-conf).\n\nWhen specifying a version in the Puppet DSL, only specify the version, not the revision.\nRevisions are only used internally for ensuring the latest version/revision of a port."
          },
          "confines"=>{
            "operatingsystem"=>"darwin"
          },
          "features"=>[
            "installable",
            "uninstallable",
            "upgradeable",
            "versionable"
          ]
        },
        {
          "name"=>"nim",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/nim.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Installation from an AIX NIM LPP source.  The `source` parameter is required\nfor this provider, and should specify the name of a NIM `lpp_source` resource\nthat is visible to the puppet agent machine.  This provider supports the\nmanagement of both BFF/installp and RPM packages.\n\nNote that package downgrades are *not* supported; if your resource specifies\na specific version number and there is already a newer version of the package\ninstalled on the machine, the resource will fail with an error message."
          },
          "confines"=>{
            "exists"=>"/etc/niminfo"
          },
          "features"=>[
            "versionable"
          ],
          "commands"=>{
            "nimclient"=>"/usr/sbin/nimclient",
            "lslpp"=>"/usr/bin/lslpp",
            "rpm"=>"rpm"
          }
        },
        {
          "name"=>"openbsd",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/openbsd.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"OpenBSD's form of `pkg_add` support.\n\nThis provider supports the `install_options` and `uninstall_options`\nattributes, which allow command-line flags to be passed to pkg_add and pkg_delete.\nThese options should be specified as an array where each element is either a\n string or a hash."
          },
          "confines"=>{
            "operatingsystem"=>"openbsd"
          },
          "features"=>[
            "versionable",
            "install_options",
            "uninstall_options",
            "upgradeable",
            "supports_flavors"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "openbsd"
              ]
            ]
          ],
          "commands"=>{
            "pkginfo"=>"pkg_info",
            "pkgadd"=>"pkg_add",
            "pkgdelete"=>"pkg_delete"
          }
        },
        {
          "name"=>"opkg",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/opkg.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Opkg packaging support. Common on OpenWrt and OpenEmbedded platforms"
          },
          "confines"=>{
            "operatingsystem"=>"openwrt"
          },
          "defaults"=>[
            [
              [
                "operatingsystem",
                "openwrt"
              ]
            ]
          ],
          "commands"=>{
            "opkg"=>"opkg"
          }
        },
        {
          "name"=>"pacman",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pacman.rb",
          "line"=>5,
          "docstring"=>{
            "text"=>"Support for the Package Manager Utility (pacman) used in Archlinux.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to pacman.\nThese options should be specified as an array where each element is either a string or a hash."
          },
          "confines"=>{
            "operatingsystem"=>"[:archlinux, :manjarolinux]"
          },
          "features"=>[
            "install_options",
            "uninstall_options",
            "upgradeable",
            "virtual_packages"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "[:archlinux, :manjarolinux]"
              ]
            ]
          ],
          "commands"=>{
            "pacman"=>"/usr/bin/pacman"
          }
        },
        {
          "name"=>"pip",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pip.rb",
          "line"=>8,
          "docstring"=>{
            "text"=>"Python packages via `pip`.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to pip.\nThese options should be specified as an array where each element is either a string or a hash."
          },
          "features"=>[
            "installable",
            "uninstallable",
            "upgradeable",
            "versionable",
            "version_ranges",
            "install_options",
            "targetable"
          ]
        },
        {
          "name"=>"pip2",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pip2.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Python packages via `pip2`.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to pip2.\nThese options should be specified as an array where each element is either a string or a hash."
          },
          "features"=>[
            "installable",
            "uninstallable",
            "upgradeable",
            "versionable",
            "install_options",
            "targetable"
          ]
        },
        {
          "name"=>"pip3",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pip3.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Python packages via `pip3`.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to pip3.\nThese options should be specified as an array where each element is either a string or a hash."
          },
          "features"=>[
            "installable",
            "uninstallable",
            "upgradeable",
            "versionable",
            "install_options",
            "targetable"
          ]
        },
        {
          "name"=>"pkg",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pkg.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"OpenSolaris image packaging system. See pkg(5) for more information.\n\nThis provider supports the `install_options` attribute, which allows\ncommand-line flags to be passed to pkg. These options should be specified as an\narray where each element is either a string or a hash."
          },
          "confines"=>{
            "osfamily"=>"solaris"
          },
          "features"=>[
            "versionable",
            "upgradable",
            "holdable",
            "install_options"
          ],
          "defaults"=>[
            [
              [
                "osfamily",
                "solaris"
              ],
              [
                "kernelrelease",
                "['5.11', '5.12']"
              ]
            ]
          ],
          "commands"=>{
            "pkg"=>"/usr/bin/pkg"
          }
        },
        {
          "name"=>"pkgdmg",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pkgdmg.rb",
          "line"=>15,
          "docstring"=>{
            "text"=>"Package management based on Apple's Installer.app and DiskUtility.app.\n\nThis provider works by checking the contents of a DMG image for Apple pkg or\nmpkg files. Any number of pkg or mpkg files may exist in the root directory\nof the DMG file system, and Puppet will install all of them. Subdirectories\nare not checked for packages.\n\nThis provider can also accept plain .pkg (but not .mpkg) files in addition\nto .dmg files.\n\nNotes:\n\n* The `source` attribute is mandatory. It must be either a local disk path\n  or an HTTP, HTTPS, or FTP URL to the package.\n* The `name` of the resource must be the filename (without path) of the DMG file.\n* When installing the packages from a DMG, this provider writes a file to\n  disk at `/var/db/.puppet_pkgdmg_installed_NAME`. If that file is present,\n  Puppet assumes all packages from that DMG are already installed.\n* This provider is not versionable and uses DMG filenames to determine\n  whether a package has been installed. Thus, to install new a version of a\n  package, you must create a new DMG with a different filename."
          },
          "confines"=>{
            "operatingsystem"=>"darwin",
            "feature"=>"cfpropertylist"
          },
          "defaults"=>[
            [
              [
                "operatingsystem",
                "darwin"
              ]
            ]
          ],
          "commands"=>{
            "installer"=>"/usr/sbin/installer",
            "hdiutil"=>"/usr/bin/hdiutil",
            "curl"=>"/usr/bin/curl"
          }
        },
        {
          "name"=>"pkgin",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pkgin.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Package management using pkgin, a binary package manager for pkgsrc."
          },
          "features"=>[
            "installable",
            "uninstallable",
            "upgradeable",
            "versionable"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "[ :smartos, :netbsd ]"
              ]
            ]
          ],
          "commands"=>{
            "pkgin"=>"pkgin"
          }
        },
        {
          "name"=>"pkgng",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pkgng.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"A PkgNG provider for FreeBSD and DragonFly."
          },
          "confines"=>{
            "operatingsystem"=>"[:freebsd, :dragonfly]"
          },
          "features"=>[
            "versionable",
            "upgradeable",
            "install_options"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "[:freebsd, :dragonfly]"
              ]
            ]
          ],
          "commands"=>{
            "pkg"=>"/usr/local/sbin/pkg"
          }
        },
        {
          "name"=>"pkgutil",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pkgutil.rb",
          "line"=>2,
          "docstring"=>{
            "text"=>"Package management using Peter Bonivart's ``pkgutil`` command on Solaris."
          },
          "confines"=>{
            "osfamily"=>"solaris"
          }
        },
        {
          "name"=>"portage",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/portage.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Provides packaging support for Gentoo's portage system.\n\nThis provider supports the `install_options` and `uninstall_options` attributes, which allows command-line\nflags to be passed to emerge. These options should be specified as an array where each element is either a string or a hash."
          },
          "confines"=>{
            "osfamily"=>"gentoo"
          },
          "features"=>[
            "install_options",
            "purgeable",
            "reinstallable",
            "uninstall_options",
            "versionable",
            "virtual_packages"
          ],
          "defaults"=>[
            [
              [
                "osfamily",
                "gentoo"
              ]
            ]
          ]
        },
        {
          "name"=>"ports",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/ports.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Support for FreeBSD's ports.  Note that this, too, mixes packages and ports."
          },
          "commands"=>{
            "portupgrade"=>"/usr/local/sbin/portupgrade",
            "portversion"=>"/usr/local/sbin/portversion",
            "portuninstall"=>"/usr/local/sbin/pkg_deinstall",
            "portinfo"=>"/usr/sbin/pkg_info"
          }
        },
        {
          "name"=>"portupgrade",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/portupgrade.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Support for FreeBSD's ports using the portupgrade ports management software.\nUse the port's full origin as the resource name. eg (ports-mgmt/portupgrade)\nfor the portupgrade port."
          },
          "commands"=>{
            "portupgrade"=>"/usr/local/sbin/portupgrade",
            "portinstall"=>"/usr/local/sbin/portinstall",
            "portversion"=>"/usr/local/sbin/portversion",
            "portuninstall"=>"/usr/local/sbin/pkg_deinstall",
            "portinfo"=>"/usr/sbin/pkg_info"
          }
        },
        {
          "name"=>"puppet_gem",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/puppet_gem.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Puppet Ruby Gem support. This provider is useful for managing\ngems needed by the ruby provided in the puppet-agent package."
          },
          "features"=>[
            "versionable",
            "install_options",
            "uninstall_options"
          ]
        },
        {
          "name"=>"puppetserver_gem",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/puppetserver_gem.rb",
          "line"=>8,
          "docstring"=>{
            "text"=>"Puppet Server Ruby Gem support. If a URL is passed via `source`, then\nthat URL is appended to the list of remote gem repositories which by default\ncontains rubygems.org; To ensure that only the specified source is used also\npass `--clear-sources` in via `install_options`; if a source is present but\nis not a valid URL, it will be interpreted as the path to a local gem file.\nIf source is not present at all, the gem will be installed from the default\ngem repositories."
          },
          "confines"=>{
            "feature"=>"hocon",
            "fips_enabled"=>"false"
          },
          "features"=>[
            "versionable",
            "install_options",
            "uninstall_options"
          ]
        },
        {
          "name"=>"rpm",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/rpm.rb",
          "line"=>5,
          "docstring"=>{
            "text"=>"RPM packaging support; should work anywhere with a working `rpm`\nbinary.\n\nThis provider supports the `install_options` and `uninstall_options`\nattributes, which allow command-line flags to be passed to rpm.\nThese options should be specified as an array where each element is either a string or a hash."
          },
          "features"=>[
            "versionable",
            "install_options",
            "uninstall_options",
            "virtual_packages",
            "install_only"
          ],
          "commands"=>{
            "rpm"=>"rpm"
          }
        },
        {
          "name"=>"rug",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/rug.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Support for suse `rug` package manager."
          },
          "confines"=>{
            "operatingsystem"=>"[:suse, :sles]"
          },
          "features"=>[
            "versionable"
          ],
          "commands"=>{
            "rug"=>"/usr/bin/rug",
            "rpm"=>"rpm"
          }
        },
        {
          "name"=>"sun",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/sun.rb",
          "line"=>5,
          "docstring"=>{
            "text"=>"Sun's packaging system.  Requires that you specify the source for\nthe packages you're managing.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to pkgadd.\nThese options should be specified as an array where each element is either a string\n or a hash."
          },
          "confines"=>{
            "osfamily"=>"solaris"
          },
          "features"=>[
            "install_options"
          ],
          "defaults"=>[
            [
              [
                "osfamily",
                "solaris"
              ]
            ]
          ],
          "commands"=>{
            "pkginfo"=>"/usr/bin/pkginfo",
            "pkgadd"=>"/usr/sbin/pkgadd",
            "pkgrm"=>"/usr/sbin/pkgrm"
          }
        },
        {
          "name"=>"sunfreeware",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/sunfreeware.rb",
          "line"=>2,
          "docstring"=>{
            "text"=>"Package management using sunfreeware.com's `pkg-get` command on Solaris.\nAt this point, support is exactly the same as `blastwave` support and\nhas not actually been tested."
          },
          "confines"=>{
            "osfamily"=>"solaris"
          },
          "commands"=>{
            "pkgget"=>"pkg-get"
          }
        },
        {
          "name"=>"tdnf",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/tdnf.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Support via `tdnf`.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to tdnf.\nThese options should be spcified as a string (e.g. '--flag'), a hash (e.g. {'--flag' => 'value'}), or an\narray where each element is either a string or a hash."
          },
          "features"=>[
            "install_options",
            "versionable",
            "virtual_packages"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "PhotonOS"
              ]
            ]
          ],
          "commands"=>{
            "cmd"=>"tdnf",
            "rpm"=>"rpm"
          }
        },
        {
          "name"=>"up2date",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/up2date.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Support for Red Hat's proprietary `up2date` package update\nmechanism."
          },
          "confines"=>{
            "osfamily"=>"redhat"
          },
          "defaults"=>[
            [
              [
                "osfamily",
                "redhat"
              ],
              [
                "lsbdistrelease",
                "[\"2.1\", \"3\", \"4\"]"
              ]
            ]
          ],
          "commands"=>{
            "up2date"=>"/usr/sbin/up2date-nox"
          }
        },
        {
          "name"=>"urpmi",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/urpmi.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Support via `urpmi`."
          },
          "features"=>[
            "versionable"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "[:mandriva, :mandrake]"
              ]
            ]
          ],
          "commands"=>{
            "urpmi"=>"urpmi",
            "urpmq"=>"urpmq",
            "rpm"=>"rpm",
            "urpme"=>"urpme"
          }
        },
        {
          "name"=>"windows",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/windows.rb",
          "line"=>5,
          "docstring"=>{
            "text"=>"Windows package management.\n\nThis provider supports either MSI or self-extracting executable installers.\n\nThis provider requires a `source` attribute when installing the package.\nIt accepts paths to local files, mapped drives, or UNC paths.\n\nThis provider supports the `install_options` and `uninstall_options`\nattributes, which allow command-line flags to be passed to the installer.\nThese options should be specified as an array where each element is either\na string or a hash.\n\nIf the executable requires special arguments to perform a silent install or\nuninstall, then the appropriate arguments should be specified using the\n`install_options` or `uninstall_options` attributes, respectively.  Puppet\nwill automatically quote any option that contains spaces."
          },
          "confines"=>{
            "operatingsystem"=>"windows"
          },
          "features"=>[
            "installable",
            "uninstallable",
            "install_options",
            "uninstall_options",
            "versionable"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "windows"
              ]
            ]
          ]
        },
        {
          "name"=>"yum",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/yum.rb",
          "line"=>5,
          "docstring"=>{
            "text"=>"Support via `yum`.\n\nUsing this provider's `uninstallable` feature will not remove dependent packages. To\nremove dependent packages with this provider use the `purgeable` feature, but note this\nfeature is destructive and should be used with the utmost care.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to yum.\nThese options should be specified as an array where each element is either a string or a hash."
          },
          "features"=>[
            "install_options",
            "versionable",
            "virtual_packages",
            "install_only"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "amazon"
              ]
            ],
            [
              [
                "osfamily",
                "redhat"
              ],
              [
                "operatingsystemmajrelease",
                "(4..7).to_a"
              ]
            ]
          ],
          "commands"=>{
            "cmd"=>"yum",
            "rpm"=>"rpm"
          }
        },
        {
          "name"=>"zypper",
          "type_name"=>"package",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/zypper.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Support for SuSE `zypper` package manager. Found in SLES10sp2+ and SLES11.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to zypper.\nThese options should be specified as an array where each element is either a\nstring or a hash."
          },
          "confines"=>{
            "operatingsystem"=>"[:suse, :sles, :sled, :opensuse]"
          },
          "features"=>[
            "versionable",
            "install_options",
            "virtual_packages"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "[:suse, :sles, :sled, :opensuse]"
              ]
            ]
          ],
          "commands"=>{
            "zypper"=>"/usr/bin/zypper"
          }
        }
      ]
    },
    {
      "name"=>"resources",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/resources.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"This is a metatype that can manage other resource types.  Any\nmetaparams specified here will be passed on to any generated resources,\nso you can purge unmanaged resources but set `noop` to true so the\npurging is only logged and does not actually happen."
      },
      "parameters"=>[
        {
          "name"=>"name",
          "description"=>"The name of the type to be managed.",
          "isnamevar"=>true
        },
        {
          "name"=>"purge",
          "description"=>"Whether to purge unmanaged resources.  When set to `true`, this will\ndelete any resource that is not specified in your configuration and is not\nautorequired by any managed resources. **Note:** The `ssh_authorized_key`\nresource type can't be purged this way; instead, see the `purge_ssh_keys`\nattribute of the `user` type.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "default"=>"false"
        },
        {
          "name"=>"unless_system_user",
          "description"=>"This keeps system users from being purged.  By default, it\ndoes not purge users whose UIDs are less than the minimum UID for the system (typically 500 or 1000), but you can specify\na different UID as the inclusive limit.",
          "values"=>[
            "true",
            "false",
            "/^\\d+$/"
          ]
        },
        {
          "name"=>"unless_uid",
          "description"=>"This keeps specific uids or ranges of uids from being purged when purge is true.\nAccepts integers, integer strings, and arrays of integers or integer strings.\nTo specify a range of uids, consider using the range() function from stdlib."
        }
      ]
    },
    {
      "name"=>"schedule",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/schedule.rb",
      "line"=>2,
      "docstring"=>{
        "text"=>"Define schedules for Puppet. Resources can be limited to a schedule by using the\n[`schedule`](https://puppet.com/docs/puppet/latest/metaparameter.html#schedule)\nmetaparameter.\n\nCurrently, **schedules can only be used to stop a resource from being\napplied;** they cannot cause a resource to be applied when it otherwise\nwouldn't be, and they cannot accurately specify a time when a resource\nshould run.\n\nEvery time Puppet applies its configuration, it will apply the\nset of resources whose schedule does not eliminate them from\nrunning right then, but there is currently no system in place to\nguarantee that a given resource runs at a given time.  If you\nspecify a very  restrictive schedule and Puppet happens to run at a\ntime within that schedule, then the resources will get applied;\notherwise, that work may never get done.\n\nThus, it is advisable to use wider scheduling (for example, over a couple\nof hours) combined with periods and repetitions.  For instance, if you\nwanted to restrict certain resources to only running once, between\nthe hours of two and 4 AM, then you would use this schedule:\n\n    schedule { 'maint':\n      range  => '2 - 4',\n      period => daily,\n      repeat => 1,\n    }\n\nWith this schedule, the first time that Puppet runs between 2 and 4 AM,\nall resources with this schedule will get applied, but they won't\nget applied again between 2 and 4 because they will have already\nrun once that day, and they won't get applied outside that schedule\nbecause they will be outside the scheduled range.\n\nPuppet automatically creates a schedule for each of the valid periods\nwith the same name as that period (such as hourly and daily).\nAdditionally, a schedule named `puppet` is created and used as the\ndefault, with the following attributes:\n\n    schedule { 'puppet':\n      period => hourly,\n      repeat => 2,\n    }\n\nThis will cause resources to be applied every 30 minutes by default.\n\nThe `statettl` setting on the agent affects the ability of a schedule to\ndetermine if a resource has already been checked. If the `statettl` is\nset lower than the span of the associated schedule resource, then a\nresource could be checked & applied multiple times in the schedule as\nthe information about when the resource was last checked will have\nexpired from the cache."
      },
      "parameters"=>[
        {
          "name"=>"name",
          "description"=>"The name of the schedule.  This name is used when assigning the schedule\nto a resource with the `schedule` metaparameter:\n\n    schedule { 'everyday':\n      period => daily,\n      range  => '2 - 4',\n    }\n\n    exec { '/usr/bin/apt-get update':\n      schedule => 'everyday',\n    }",
          "isnamevar"=>true
        },
        {
          "name"=>"period",
          "description"=>"The period of repetition for resources on this schedule. The default is\nfor resources to get applied every time Puppet runs.\n\nNote that the period defines how often a given resource will get\napplied but not when; if you would like to restrict the hours\nthat a given resource can be applied (for instance, only at night\nduring a maintenance window), then use the `range` attribute.\n\nIf the provided periods are not sufficient, you can provide a\nvalue to the *repeat* attribute, which will cause Puppet to\nschedule the affected resources evenly in the period the\nspecified number of times.  Take this schedule:\n\n    schedule { 'veryoften':\n      period => hourly,\n      repeat => 6,\n    }\n\nThis can cause Puppet to apply that resource up to every 10 minutes.\n\nAt the moment, Puppet cannot guarantee that level of repetition; that\nis, the resource can applied _up to_ every 10 minutes, but internal\nfactors might prevent it from actually running that often (for instance,\nif a Puppet run is still in progress when the next run is scheduled to\nstart, that next run will be suppressed).\n\nSee the `periodmatch` attribute for tuning whether to match\ntimes by their distance apart or by their specific value.\n\n> **Tip**: You can use `period => never,` to prevent a resource from being applied\nin the given `range`. This is useful if you need to create a blackout window to\nperform sensitive operations without interruption.",
          "values"=>[
            "hourly",
            "daily",
            "weekly",
            "monthly",
            "never"
          ]
        },
        {
          "name"=>"periodmatch",
          "description"=>"Whether periods should be matched by a numeric value (for instance,\nwhether two times are in the same hour) or by their chronological\ndistance apart (whether two times are 60 minutes apart).",
          "values"=>[
            "number",
            "distance"
          ],
          "default"=>"distance"
        },
        {
          "name"=>"range",
          "description"=>"The earliest and latest that a resource can be applied.  This is\nalways a hyphen-separated range within a 24 hour period, and hours\nmust be specified in numbers between 0 and 23, inclusive.  Minutes and\nseconds can optionally be provided, using the normal colon as a\nseparator. For instance:\n\n    schedule { 'maintenance':\n      range => '1:30 - 4:30',\n    }\n\nThis is mostly useful for restricting certain resources to being\napplied in maintenance windows or during off-peak hours. Multiple\nranges can be applied in array context. As a convenience when specifying\nranges, you can cross midnight (for example, `range => \"22:00 - 04:00\"`)."
        },
        {
          "name"=>"repeat",
          "description"=>"How often a given resource may be applied in this schedule's `period`.\nMust be an integer.",
          "default"=>"1"
        },
        {
          "name"=>"weekday",
          "description"=>"The days of the week in which the schedule should be valid.\nYou may specify the full day name 'Tuesday', the three character\nabbreviation 'Tue', or a number (as a string or as an integer) corresponding to the day of the\nweek where 0 is Sunday, 1 is Monday, and so on. Multiple days can be specified\nas an array. If not specified, the day of the week will not be\nconsidered in the schedule.\n\nIf you are also using a range match that spans across midnight\nthen this parameter will match the day that it was at the start\nof the range, not necessarily the day that it is when it matches.\nFor example, consider this schedule:\n\n    schedule { 'maintenance_window':\n      range   => '22:00 - 04:00',\n      weekday => 'Saturday',\n    }\n\nThis will match at 11 PM on Saturday and 2 AM on Sunday, but not\nat 2 AM on Saturday."
        }
      ]
    },
    {
      "name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/service.rb",
      "line"=>10,
      "docstring"=>{
        "text"=>"Manage running services.  Service support unfortunately varies\nwidely by platform --- some platforms have very little if any concept of a\nrunning service, and some have a very codified and powerful concept.\nPuppet's service support is usually capable of doing the right thing, but\nthe more information you can provide, the better behaviour you will get.\n\nPuppet 2.7 and newer expect init scripts to have a working status command.\nIf this isn't the case for any of your services' init scripts, you will\nneed to set `hasstatus` to false and possibly specify a custom status\ncommand in the `status` attribute. As a last resort, Puppet will attempt to\nsearch the process table by calling whatever command is listed in the `ps`\nfact. The default search pattern is the name of the service, but you can\nspecify it with the `pattern` attribute.\n\n**Refresh:** `service` resources can respond to refresh events (via\n`notify`, `subscribe`, or the `~>` arrow). If a `service` receives an\nevent from another resource, Puppet will restart the service it manages.\nThe actual command used to restart the service depends on the platform and\ncan be configured:\n\n* If you set `hasrestart` to true, Puppet will use the init script's restart command.\n* You can provide an explicit command for restarting with the `restart` attribute.\n* If you do neither, the service's stop and start commands will be used."
      },
      "properties"=>[
        {
          "name"=>"enable",
          "description"=>"Whether a service should be enabled to start at boot.\nThis property behaves differently depending on the platform;\nwherever possible, it relies on local tools to enable or disable\na given service. Default values depend on the platform.\n\nIf you don't specify a value for the `enable` attribute, Puppet leaves\nthat aspect of the service alone and your operating system determines\nthe behavior.",
          "values"=>[
            "true",
            "false",
            "manual",
            "mask",
            "delayed"
          ],
          "required_features"=>"enableable"
        },
        {
          "name"=>"ensure",
          "description"=>"Whether a service should be running. Default values depend on the platform.",
          "values"=>[
            "stopped",
            "running",
            "false",
            "true"
          ],
          "aliases"=>{
            "false"=>"stopped",
            "true"=>"running"
          }
        },
        {
          "name"=>"flags",
          "description"=>"Specify a string of flags to pass to the startup script.",
          "required_features"=>"flaggable"
        },
        {
          "name"=>"logonaccount",
          "description"=>"Specify an account for service logon",
          "required_features"=>"manages_logon_credentials"
        }
      ],
      "parameters"=>[
        {
          "name"=>"binary",
          "description"=>"The path to the daemon.  This is only used for\nsystems that do not support init scripts.  This binary will be\nused to start the service if no `start` parameter is\nprovided."
        },
        {
          "name"=>"control",
          "description"=>"The control variable used to manage services (originally for HP-UX).\nDefaults to the upcased service name plus `START` replacing dots with\nunderscores, for those providers that support the `controllable` feature."
        },
        {
          "name"=>"hasrestart",
          "description"=>"Specify that an init script has a `restart` command.  If this is\nfalse and you do not specify a command in the `restart` attribute,\nthe init script's `stop` and `start` commands will be used.",
          "values"=>[
            "true",
            "false"
          ]
        },
        {
          "name"=>"hasstatus",
          "description"=>"Declare whether the service's init script has a functional status\ncommand. This attribute's default value changed in Puppet 2.7.0.\n\nThe init script's status command must return 0 if the service is\nrunning and a nonzero value otherwise. Ideally, these exit codes\nshould conform to [the LSB's specification][lsb-exit-codes] for init\nscript status actions, but Puppet only considers the difference\nbetween 0 and nonzero to be relevant.\n\nIf a service's init script does not support any kind of status command,\nyou should set `hasstatus` to false and either provide a specific\ncommand using the `status` attribute or expect that Puppet will look for\nthe service name in the process table. Be aware that 'virtual' init\nscripts (like 'network' under Red Hat systems) will respond poorly to\nrefresh events from other resources if you override the default behavior\nwithout providing a status command.",
          "values"=>[
            "true",
            "false"
          ],
          "default"=>"true"
        },
        {
          "name"=>"logonpassword",
          "description"=>"Specify a password for service logon. Default value is an empty string (when logonaccount is specified).",
          "required_features"=>"manages_logon_credentials"
        },
        {
          "name"=>"manifest",
          "description"=>"Specify a command to config a service, or a path to a manifest to do so."
        },
        {
          "name"=>"name",
          "description"=>"The name of the service to run.\n\nThis name is used to find the service; on platforms where services\nhave short system names and long display names, this should be the\nshort name. (To take an example from Windows, you would use \"wuauserv\"\nrather than \"Automatic Updates.\")",
          "isnamevar"=>true
        },
        {
          "name"=>"path",
          "description"=>"The search path for finding init scripts.  Multiple values should\nbe separated by colons or provided as an array."
        },
        {
          "name"=>"pattern",
          "description"=>"The pattern to search for in the process table.\nThis is used for stopping services on platforms that do not\nsupport init scripts, and is also used for determining service\nstatus on those service whose init scripts do not include a status\ncommand.\n\nDefaults to the name of the service. The pattern can be a simple string\nor any legal Ruby pattern, including regular expressions (which should\nbe quoted without enclosing slashes)."
        },
        {
          "name"=>"provider",
          "description"=>"The specific backend to use for this `service` resource. You will seldom need to specify this --- Puppet will usually discover the appropriate provider for your platform."
        },
        {
          "name"=>"restart",
          "description"=>"Specify a *restart* command manually.  If left\nunspecified, the service will be stopped and then started."
        },
        {
          "name"=>"start",
          "description"=>"Specify a *start* command manually.  Most service subsystems\nsupport a `start` command, so this will not need to be\nspecified."
        },
        {
          "name"=>"status",
          "description"=>"Specify a *status* command manually.  This command must\nreturn 0 if the service is running and a nonzero value otherwise.\nIdeally, these exit codes should conform to [the LSB's\nspecification][lsb-exit-codes] for init script status actions, but\nPuppet only considers the difference between 0 and nonzero to be\nrelevant.\n\nIf left unspecified, the status of the service will be determined\nautomatically, usually by looking for the service in the process\ntable.\n\n[lsb-exit-codes]: http://refspecs.linuxfoundation.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html"
        },
        {
          "name"=>"stop",
          "description"=>"Specify a *stop* command manually."
        },
        {
          "name"=>"timeout",
          "description"=>"Specify an optional minimum timeout (in seconds) for puppet to wait when syncing service properties",
          "required_features"=>"configurable_timeout"
        }
      ],
      "features"=>[
        {
          "name"=>"configurable_timeout",
          "description"=>"The provider can specify a minumum timeout for syncing service properties"
        },
        {
          "name"=>"controllable",
          "description"=>"The provider uses a control variable."
        },
        {
          "name"=>"enableable",
          "description"=>"The provider can enable and disable the service."
        },
        {
          "name"=>"flaggable",
          "description"=>"The provider can pass flags to the service."
        },
        {
          "name"=>"manages_logon_credentials",
          "description"=>"The provider can specify the logon credentials used for a service"
        },
        {
          "name"=>"maskable",
          "description"=>"The provider can 'mask' the service."
        },
        {
          "name"=>"refreshable",
          "description"=>"The provider can restart the service."
        }
      ],
      "providers"=>[
        {
          "name"=>"base",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/base.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"The simplest form of Unix service support.\n\nYou have to specify enough about your service for this to work; the\nminimum you can specify is a binary for starting the process, and this\nsame binary will be searched for in the process table to stop the\nservice.  As with `init`-style services, it is preferable to specify start,\nstop, and status commands."
          },
          "commands"=>{
            "kill"=>"kill"
          }
        },
        {
          "name"=>"bsd",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/bsd.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Generic BSD form of `init`-style service management with `rc.d`.\n\nUses `rc.conf.d` for service enabling and disabling."
          },
          "confines"=>{
            "operatingsystem"=>"[:freebsd, :dragonfly]"
          }
        },
        {
          "name"=>"daemontools",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/daemontools.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Daemontools service management.\n\nThis provider manages daemons supervised by D.J. Bernstein daemontools.\nWhen detecting the service directory it will check, in order of preference:\n\n* `/service`\n* `/etc/service`\n* `/var/lib/svscan`\n\nThe daemon directory should be in one of the following locations:\n\n* `/var/lib/service`\n* `/etc`\n\n...or this can be overridden in the resource's attributes:\n\n    service { 'myservice':\n      provider => 'daemontools',\n      path     => '/path/to/daemons',\n    }\n\nThis provider supports out of the box:\n\n* start/stop (mapped to enable/disable)\n* enable/disable\n* restart\n* status\n\nIf a service has `ensure => \"running\"`, it will link /path/to/daemon to\n/path/to/service, which will automatically enable the service.\n\nIf a service has `ensure => \"stopped\"`, it will only shut down the service, not\nremove the `/path/to/service` link."
          },
          "commands"=>{
            "svc"=>"/usr/bin/svc",
            "svstat"=>"/usr/bin/svstat"
          }
        },
        {
          "name"=>"debian",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/debian.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Debian's form of `init`-style management.\n\nThe only differences from `init` are support for enabling and disabling\nservices via `update-rc.d` and the ability to determine enabled status via\n`invoke-rc.d`."
          },
          "confines"=>{
            "false"=>"Puppet::FileSystem.exist?('/proc/1/comm') && Puppet::FileSystem.read('/proc/1/comm').include?('systemd')"
          },
          "defaults"=>[
            [
              [
                "operatingsystem",
                "cumuluslinux"
              ],
              [
                "operatingsystemmajrelease",
                "['1','2']"
              ]
            ],
            [
              [
                "operatingsystem",
                "debian"
              ],
              [
                "operatingsystemmajrelease",
                "['5','6','7']"
              ]
            ],
            [
              [
                "operatingsystem",
                "devuan"
              ]
            ]
          ],
          "commands"=>{
            "update_rc"=>"/usr/sbin/update-rc.d",
            "invoke_rc"=>"/usr/sbin/invoke-rc.d",
            "service"=>"/usr/sbin/service"
          }
        },
        {
          "name"=>"freebsd",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/freebsd.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Provider for FreeBSD and DragonFly BSD. Uses the `rcvar` argument of init scripts and parses/edits rc files."
          },
          "confines"=>{
            "operatingsystem"=>"[:freebsd, :dragonfly]"
          },
          "defaults"=>[
            [
              [
                "operatingsystem",
                "[:freebsd, :dragonfly]"
              ]
            ]
          ]
        },
        {
          "name"=>"gentoo",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/gentoo.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Gentoo's form of `init`-style service management.\n\nUses `rc-update` for service enabling and disabling."
          },
          "confines"=>{
            "operatingsystem"=>"gentoo"
          },
          "commands"=>{
            "update"=>"/sbin/rc-update"
          }
        },
        {
          "name"=>"init",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/init.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Standard `init`-style service management."
          },
          "confines"=>{
            "true"=>"begin\n      os = Facter.value(:operatingsystem).downcase\n      family = Facter.value(:osfamily).downcase\n      !(os == 'debian' || os == 'ubuntu' || family == 'redhat')\n  end"
          }
        },
        {
          "name"=>"launchd",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/launchd.rb",
          "line"=>2,
          "docstring"=>{
            "text"=>"This provider manages jobs with `launchd`, which is the default service\nframework for Mac OS X (and may be available for use on other platforms).\n\nFor more information, see the `launchd` man page:\n\n* <https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man8/launchd.8.html>\n\nThis provider reads plists out of the following directories:\n\n* `/System/Library/LaunchDaemons`\n* `/System/Library/LaunchAgents`\n* `/Library/LaunchDaemons`\n* `/Library/LaunchAgents`\n\n...and builds up a list of services based upon each plist's \"Label\" entry.\n\nThis provider supports:\n\n* ensure => running/stopped,\n* enable => true/false\n* status\n* restart\n\nHere is how the Puppet states correspond to `launchd` states:\n\n* stopped --- job unloaded\n* started --- job loaded\n* enabled --- 'Disable' removed from job plist file\n* disabled --- 'Disable' added to job plist file\n\nNote that this allows you to do something `launchctl` can't do, which is to\nbe in a state of \"stopped/enabled\" or \"running/disabled\".\n\nNote that this provider does not support overriding 'restart'"
          },
          "confines"=>{
            "operatingsystem"=>"darwin",
            "feature"=>"cfpropertylist"
          },
          "features"=>[
            "enableable",
            "refreshable"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "darwin"
              ]
            ]
          ],
          "commands"=>{
            "launchctl"=>"/bin/launchctl"
          }
        },
        {
          "name"=>"openbsd",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/openbsd.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Provider for OpenBSD's rc.d daemon control scripts"
          },
          "confines"=>{
            "operatingsystem"=>"openbsd"
          },
          "features"=>[
            "flaggable"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "openbsd"
              ]
            ]
          ],
          "commands"=>{
            "rcctl"=>"/usr/sbin/rcctl"
          }
        },
        {
          "name"=>"openrc",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/openrc.rb",
          "line"=>2,
          "docstring"=>{
            "text"=>"Support for Gentoo's OpenRC initskripts\n\nUses rc-update, rc-status and rc-service to manage services."
          },
          "defaults"=>[
            [
              [
                "operatingsystem",
                "gentoo"
              ]
            ],
            [
              [
                "operatingsystem",
                "funtoo"
              ]
            ]
          ],
          "commands"=>{
            "rcservice"=>"/sbin/rc-service",
            "rcupdate"=>"/sbin/rc-update"
          }
        },
        {
          "name"=>"openwrt",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/openwrt.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Support for OpenWrt flavored init scripts.\n\nUses /etc/init.d/service_name enable, disable, and enabled."
          },
          "confines"=>{
            "operatingsystem"=>"openwrt"
          },
          "features"=>[
            "enableable"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "openwrt"
              ]
            ]
          ]
        },
        {
          "name"=>"rcng",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/rcng.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"RCng service management with rc.d"
          },
          "confines"=>{
            "operatingsystem"=>"[:netbsd, :cargos]"
          },
          "defaults"=>[
            [
              [
                "operatingsystem",
                "[:netbsd, :cargos]"
              ]
            ]
          ]
        },
        {
          "name"=>"redhat",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/redhat.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Red Hat's (and probably many others') form of `init`-style service\nmanagement. Uses `chkconfig` for service enabling and disabling."
          },
          "defaults"=>[
            [
              [
                "osfamily",
                "redhat"
              ]
            ],
            [
              [
                "osfamily",
                "suse"
              ],
              [
                "operatingsystemmajrelease",
                "[\"10\", \"11\"]"
              ]
            ]
          ],
          "commands"=>{
            "chkconfig"=>"/sbin/chkconfig",
            "service"=>"/sbin/service"
          }
        },
        {
          "name"=>"runit",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/runit.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Runit service management.\n\nThis provider manages daemons running supervised by Runit.\nWhen detecting the service directory it will check, in order of preference:\n\n* `/service`\n* `/etc/service`\n* `/var/service`\n\nThe daemon directory should be in one of the following locations:\n\n* `/etc/sv`\n* `/var/lib/service`\n\nor this can be overridden in the service resource parameters:\n\n    service { 'myservice':\n      provider => 'runit',\n      path     => '/path/to/daemons',\n    }\n\nThis provider supports out of the box:\n\n* start/stop\n* enable/disable\n* restart\n* status"
          },
          "commands"=>{
            "sv"=>"/usr/bin/sv"
          }
        },
        {
          "name"=>"service",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/service.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"The simplest form of service support."
          }
        },
        {
          "name"=>"smf",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/smf.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Support for Sun's new Service Management Framework.\n\nWhen managing the enable property, this provider will try to preserve\nthe previous ensure state per the enableable semantics. On Solaris,\nenabling a service starts it up while disabling a service stops it. Thus,\nthere's a chance for this provider to execute two operations when managing\nthe enable property. For example, if enable is set to true and the ensure\nstate is stopped, this provider will manage the service using two operations:\none to enable the service which will start it up, and another to stop the\nservice (without affecting its enabled status).\n\nBy specifying `manifest => \"/path/to/service.xml\"`, the SMF manifest will\nbe imported if it does not exist."
          },
          "confines"=>{
            "osfamily"=>"solaris"
          },
          "features"=>[
            "refreshable"
          ],
          "defaults"=>[
            [
              [
                "osfamily",
                "solaris"
              ]
            ]
          ],
          "commands"=>{
            "adm"=>"/usr/sbin/svcadm",
            "svcs"=>"/usr/bin/svcs",
            "svccfg"=>"/usr/sbin/svccfg"
          }
        },
        {
          "name"=>"src",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/src.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"Support for AIX's System Resource controller.\n\nServices are started/stopped based on the `stopsrc` and `startsrc`\ncommands, and some services can be refreshed with `refresh` command.\n\nEnabling and disabling services is not supported, as it requires\nmodifications to `/etc/inittab`. Starting and stopping groups of subsystems\nis not yet supported."
          },
          "confines"=>{
            "operatingsystem"=>"aix"
          },
          "features"=>[
            "refreshable"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "aix"
              ]
            ]
          ]
        },
        {
          "name"=>"systemd",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/systemd.rb",
          "line"=>5,
          "docstring"=>{
            "text"=>"Manages `systemd` services using `systemctl`.\n\nBecause `systemd` defaults to assuming the `.service` unit type, the suffix\nmay be omitted.  Other unit types (such as `.path`) may be managed by\nproviding the proper suffix."
          },
          "confines"=>{
            "true"=>"Puppet::FileSystem.exist?('/proc/1/comm') && Puppet::FileSystem.read('/proc/1/comm').include?('systemd')"
          },
          "defaults"=>[
            [
              [
                "osfamily",
                "[:archlinux]"
              ]
            ],
            [
              [
                "osfamily",
                "redhat"
              ],
              [
                "operatingsystemmajrelease",
                "[\"7\", \"8\"]"
              ]
            ],
            [
              [
                "osfamily",
                "redhat"
              ],
              [
                "operatingsystem",
                "fedora"
              ]
            ],
            [
              [
                "osfamily",
                "suse"
              ]
            ],
            [
              [
                "osfamily",
                "coreos"
              ]
            ],
            [
              [
                "operatingsystem",
                "amazon"
              ],
              [
                "operatingsystemmajrelease",
                "[\"2\"]"
              ]
            ],
            [
              [
                "operatingsystem",
                "debian"
              ]
            ],
            [
              [
                "operatingsystem",
                "LinuxMint"
              ]
            ],
            [
              [
                "operatingsystem",
                "ubuntu"
              ]
            ],
            [
              [
                "operatingsystem",
                "cumuluslinux"
              ],
              [
                "operatingsystemmajrelease",
                "[\"3\", \"4\"]"
              ]
            ]
          ],
          "commands"=>{
            "systemctl"=>"systemctl"
          }
        },
        {
          "name"=>"upstart",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/upstart.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"Ubuntu service management with `upstart`.\n\nThis provider manages `upstart` jobs on Ubuntu. For `upstart` documentation,\nsee <http://upstart.ubuntu.com/>."
          },
          "confines"=>{
            "any"=>"[\n    Facter.value(:operatingsystem) == 'Ubuntu',\n    (Facter.value(:osfamily) == 'RedHat' and Facter.value(:operatingsystemrelease) =~ /^6\\./),\n    (Facter.value(:operatingsystem) == 'Amazon' and Facter.value(:operatingsystemmajrelease) =~ /\\d{4}/),\n    Facter.value(:operatingsystem) == 'LinuxMint',\n  ]",
            "true"=>"lambda { has_initctl? }"
          },
          "features"=>[
            "enableable"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "ubuntu"
              ],
              [
                "operatingsystemmajrelease",
                "[\"10.04\", \"12.04\", \"14.04\", \"14.10\"]"
              ]
            ],
            [
              [
                "operatingsystem",
                "LinuxMint"
              ],
              [
                "operatingsystemmajrelease",
                "[\"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\"]"
              ]
            ]
          ],
          "commands"=>{
            "start"=>"/sbin/start",
            "stop"=>"/sbin/stop",
            "restart"=>"/sbin/restart",
            "status_exec"=>"/sbin/status",
            "initctl"=>"/sbin/initctl"
          }
        },
        {
          "name"=>"windows",
          "type_name"=>"service",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/windows.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Support for Windows Service Control Manager (SCM). This provider can\nstart, stop, enable, and disable services, and the SCM provides working\nstatus methods for all services.\n\nControl of service groups (dependencies) is not yet supported, nor is running\nservices as a specific user."
          },
          "confines"=>{
            "operatingsystem"=>"windows"
          },
          "features"=>[
            "refreshable",
            "configurable_timeout",
            "manages_logon_credentials"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "windows"
              ]
            ]
          ]
        }
      ]
    },
    {
      "name"=>"stage",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/stage.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"A resource type for creating new run stages.  Once a stage is available,\nclasses can be assigned to it by declaring them with the resource-like syntax\nand using\n[the `stage` metaparameter](https://puppet.com/docs/puppet/latest/metaparameter.html#stage).\n\nNote that new stages are not useful unless you also declare their order\nin relation to the default `main` stage.\n\nA complete run stage example:\n\n    stage { 'pre':\n      before => Stage['main'],\n    }\n\n    class { 'apt-updates':\n      stage => 'pre',\n    }\n\nIndividual resources cannot be assigned to run stages; you can only set stages\nfor classes."
      },
      "parameters"=>[
        {
          "name"=>"name",
          "description"=>"The name of the stage. Use this as the value for the `stage` metaparameter\nwhen assigning classes to this stage.",
          "isnamevar"=>true
        }
      ]
    },
    {
      "name"=>"tidy",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/tidy.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Remove unwanted files based on specific criteria.  Multiple\ncriteria are OR'd together, so a file that is too large but is not\nold enough will still get tidied.\n\nIf you don't specify either `age` or `size`, then all files will\nbe removed.\n\nThis resource type works by generating a file resource for every file\nthat should be deleted and then letting that resource perform the\nactual deletion."
      },
      "parameters"=>[
        {
          "name"=>"age",
          "description"=>"Tidy files whose age is equal to or greater than\nthe specified time.  You can choose seconds, minutes,\nhours, days, or weeks by specifying the first letter of any\nof those words (for example, '1w' represents one week).\n\nSpecifying 0 will remove all files."
        },
        {
          "name"=>"backup",
          "description"=>"Whether tidied files should be backed up.  Any values are passed\ndirectly to the file resources used for actual file deletion, so consult\nthe `file` type's backup documentation to determine valid values."
        },
        {
          "name"=>"matches",
          "description"=>"One or more (shell type) file glob patterns, which restrict\nthe list of files to be tidied to those whose basenames match\nat least one of the patterns specified. Multiple patterns can\nbe specified using an array.\n\nExample:\n\n    tidy { '/tmp':\n      age     => '1w',\n      recurse => 1,\n      matches => [ '[0-9]pub*.tmp', '*.temp', 'tmpfile?' ],\n    }\n\nThis removes files from `/tmp` if they are one week old or older,\nare not in a subdirectory and match one of the shell globs given.\n\nNote that the patterns are matched against the basename of each\nfile -- that is, your glob patterns should not have any '/'\ncharacters in them, since you are only specifying against the last\nbit of the file.\n\nFinally, note that you must now specify a non-zero/non-false value\nfor recurse if matches is used, as matches only apply to files found\nby recursion (there's no reason to use static patterns match against\na statically determined path).  Requiring explicit recursion clears\nup a common source of confusion."
        },
        {
          "name"=>"path",
          "description"=>"The path to the file or directory to manage.  Must be fully\nqualified.",
          "isnamevar"=>true
        },
        {
          "name"=>"recurse",
          "description"=>"If target is a directory, recursively descend\ninto the directory looking for files to tidy.",
          "values"=>[
            "true",
            "false",
            "inf",
            "/^[0-9]+$/"
          ]
        },
        {
          "name"=>"rmdirs",
          "description"=>"Tidy directories in addition to files; that is, remove\ndirectories whose age is older than the specified criteria.\nThis will only remove empty directories, so all contained\nfiles must also be tidied before a directory gets removed.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ]
        },
        {
          "name"=>"size",
          "description"=>"Tidy files whose size is equal to or greater than\nthe specified size.  Unqualified values are in kilobytes, but\n*b*, *k*, *m*, *g*, and *t* can be appended to specify *bytes*,\n*kilobytes*, *megabytes*, *gigabytes*, and *terabytes*, respectively.\nOnly the first character is significant, so the full word can also\nbe used."
        },
        {
          "name"=>"type",
          "description"=>"Set the mechanism for determining age.",
          "values"=>[
            "atime",
            "mtime",
            "ctime"
          ],
          "default"=>"atime"
        }
      ]
    },
    {
      "name"=>"user",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/user.rb",
      "line"=>9,
      "docstring"=>{
        "text"=>"Manage users.  This type is mostly built to manage system\nusers, so it is lacking some features useful for managing normal\nusers.\n\nThis resource type uses the prescribed native tools for creating\ngroups and generally uses POSIX APIs for retrieving information\nabout them.  It does not directly modify `/etc/passwd` or anything.\n\n**Autorequires:** If Puppet is managing the user's primary group (as\nprovided in the `gid` attribute) or any group listed in the `groups`\nattribute then the user resource will autorequire that group. If Puppet\nis managing any role accounts corresponding to the user's roles, the\nuser resource will autorequire those role accounts."
      },
      "properties"=>[
        {
          "name"=>"attributes",
          "description"=>"Specify AIX attributes for the user in an array or hash of attribute = value pairs.\n\n For example:\n\n ```\n ['minage=0', 'maxage=5', 'SYSTEM=compat']\n ```\n\n or\n\n```\nattributes => { 'minage' => '0', 'maxage' => '5', 'SYSTEM' => 'compat' }\n```",
          "required_features"=>"manages_aix_lam"
        },
        {
          "name"=>"auths",
          "description"=>"The auths the user has.  Multiple auths should be\nspecified as an array.",
          "required_features"=>"manages_solaris_rbac"
        },
        {
          "name"=>"comment",
          "description"=>"A description of the user.  Generally the user's full name."
        },
        {
          "name"=>"ensure",
          "description"=>"The basic state that the object should be in.",
          "values"=>[
            "present",
            "absent",
            "role"
          ]
        },
        {
          "name"=>"expiry",
          "description"=>"The expiry date for this user. Provide as either the special\nvalue `absent` to ensure that the account never expires, or as\na zero-padded YYYY-MM-DD format -- for example, 2010-02-19.",
          "values"=>[
            "absent",
            "/^\\d{4}-\\d{2}-\\d{2}$/"
          ],
          "required_features"=>"manages_expiry"
        },
        {
          "name"=>"gid",
          "description"=>"The user's primary group.  Can be specified numerically or by name.\n\nThis attribute is not supported on Windows systems; use the `groups`\nattribute instead. (On Windows, designating a primary group is only\nmeaningful for domain accounts, which Puppet does not currently manage.)"
        },
        {
          "name"=>"groups",
          "description"=>"The groups to which the user belongs.  The primary group should\nnot be listed, and groups should be identified by name rather than by\nGID.  Multiple groups should be specified as an array."
        },
        {
          "name"=>"home",
          "description"=>"The home directory of the user.  The directory must be created\nseparately and is not currently checked for existence."
        },
        {
          "name"=>"iterations",
          "description"=>"This is the number of iterations of a chained computation of the\n[PBKDF2 password hash](https://en.wikipedia.org/wiki/PBKDF2). This parameter\nis used in OS X, and is required for managing passwords on OS X 10.8 and\nnewer.",
          "required_features"=>"manages_password_salt"
        },
        {
          "name"=>"keys",
          "description"=>"Specify user attributes in an array of key = value pairs.",
          "required_features"=>"manages_solaris_rbac"
        },
        {
          "name"=>"loginclass",
          "description"=>"The name of login class to which the user belongs.",
          "required_features"=>"manages_loginclass"
        },
        {
          "name"=>"password",
          "description"=>"The user's password, in whatever encrypted format the local system\nrequires. Consult your operating system's documentation for acceptable password\nencryption formats and requirements.\n\n* Mac OS X 10.5 and 10.6, and some older Linux distributions, use salted SHA1\n  hashes. You can use Puppet's built-in `sha1` function to generate a salted SHA1\n  hash from a password.\n* Mac OS X 10.7 (Lion), and many recent Linux distributions, use salted SHA512\n  hashes. The Puppet Labs [stdlib][] module contains a `str2saltedsha512` function\n  which can generate password hashes for these operating systems.\n* OS X 10.8 and higher use salted SHA512 PBKDF2 hashes. When managing passwords\n  on these systems, the `salt` and `iterations` attributes need to be specified as\n  well as the password.\n* Windows passwords can be managed only in cleartext, because there is no Windows\n  API for setting the password hash.\n\n[stdlib]: https://github.com/puppetlabs/puppetlabs-stdlib/\n\nEnclose any value that includes a dollar sign ($) in single quotes (') to avoid\naccidental variable interpolation.\n\nTo redact passwords from reports to PuppetDB, use the `Sensitive` data type. For\nexample, this resource protects the password:\n\n```puppet\nuser { 'foo':\n  ensure   => present,\n  password => Sensitive(\"my secret password\")\n}\n```\n\nThis results in the password being redacted from the report, as in the\n`previous_value`, `desired_value`, and `message` fields below.\n\n```yaml\n    events:\n    - !ruby/object:Puppet::Transaction::Event\n      audited: false\n      property: password\n      previous_value: \"[redacted]\"\n      desired_value: \"[redacted]\"\n      historical_value:\n      message: changed [redacted] to [redacted]\n      name: :password_changed\n      status: success\n      time: 2017-05-17 16:06:02.934398293 -07:00\n      redacted: true\n      corrective_change: false\n    corrective_change: false\n```",
          "required_features"=>"manages_passwords"
        },
        {
          "name"=>"password_max_age",
          "description"=>"The maximum number of days a password may be used before it must be changed.",
          "required_features"=>"manages_password_age"
        },
        {
          "name"=>"password_min_age",
          "description"=>"The minimum number of days a password must be used before it may be changed.",
          "required_features"=>"manages_password_age"
        },
        {
          "name"=>"password_warn_days",
          "description"=>"The number of days before a password is going to expire (see the maximum password age) during which the user should be warned.",
          "required_features"=>"manages_password_age"
        },
        {
          "name"=>"profiles",
          "description"=>"The profiles the user has.  Multiple profiles should be\nspecified as an array.",
          "required_features"=>"manages_solaris_rbac"
        },
        {
          "name"=>"project",
          "description"=>"The name of the project associated with a user.",
          "required_features"=>"manages_solaris_rbac"
        },
        {
          "name"=>"roles",
          "description"=>"The roles the user has.  Multiple roles should be\nspecified as an array.",
          "required_features"=>"manages_roles"
        },
        {
          "name"=>"salt",
          "description"=>"This is the 32-byte salt used to generate the PBKDF2 password used in\nOS X. This field is required for managing passwords on OS X >= 10.8.",
          "required_features"=>"manages_password_salt"
        },
        {
          "name"=>"shell",
          "description"=>"The user's login shell.  The shell must exist and be\nexecutable.\n\nThis attribute cannot be managed on Windows systems.",
          "required_features"=>"manages_shell"
        },
        {
          "name"=>"uid",
          "description"=>"The user ID; must be specified numerically. If no user ID is\nspecified when creating a new user, then one will be chosen\nautomatically. This will likely result in the same user having\ndifferent UIDs on different systems, which is not recommended. This is\nespecially noteworthy when managing the same user on both Darwin and\nother platforms, since Puppet does UID generation on Darwin, but\nthe underlying tools do so on other platforms.\n\nOn Windows, this property is read-only and will return the user's\nsecurity identifier (SID)."
        }
      ],
      "parameters"=>[
        {
          "name"=>"allowdupe",
          "description"=>"Whether to allow duplicate UIDs.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "default"=>"false"
        },
        {
          "name"=>"attribute_membership",
          "description"=>"Whether specified attribute value pairs should be treated as the\n**complete list** (`inclusive`) or the **minimum list** (`minimum`) of\nattribute/value pairs for the user.",
          "values"=>[
            "inclusive",
            "minimum"
          ],
          "default"=>"minimum"
        },
        {
          "name"=>"auth_membership",
          "description"=>"Whether specified auths should be considered the **complete list**\n(`inclusive`) or the **minimum list** (`minimum`) of auths the user\nhas. This setting is specific to managing Solaris authorizations.",
          "values"=>[
            "inclusive",
            "minimum"
          ],
          "default"=>"minimum"
        },
        {
          "name"=>"forcelocal",
          "description"=>"Forces the management of local accounts when accounts are also\nbeing managed by some other Name Service Switch (NSS). For AIX, refer to the `ia_load_module` parameter.\n\nThis option relies on your operating system's implementation of `luser*` commands, such as `luseradd` , and `lgroupadd`, `lusermod`. The `forcelocal` option could behave unpredictably in some circumstances. If the tools it depends on are not available, it might have no effect at all.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "required_features"=>"manages_local_users_and_groups",
          "default"=>"false"
        },
        {
          "name"=>"ia_load_module",
          "description"=>"The name of the I&A module to use to manage this user.\nThis should be set to `files` if managing local users.",
          "required_features"=>"manages_aix_lam"
        },
        {
          "name"=>"key_membership",
          "description"=>"Whether specified key/value pairs should be considered the\n**complete list** (`inclusive`) or the **minimum list** (`minimum`) of\nthe user's attributes.",
          "values"=>[
            "inclusive",
            "minimum"
          ],
          "default"=>"minimum"
        },
        {
          "name"=>"managehome",
          "description"=>"Whether to manage the home directory when Puppet creates or removes the user.\nThis creates the home directory if Puppet also creates the user account, and deletes the\nhome directory if Puppet also removes the user account.\n\nThis parameter has no effect unless Puppet is also creating or removing the user in the\nresource at the same time. For instance, Puppet creates a home directory for a managed\nuser if `ensure => present` and the user does not exist at the time of the Puppet run.\nIf the home directory is then deleted manually, Puppet will not recreate it on the next\nrun.\n\nNote that on Windows, this manages creation/deletion of the user profile instead of the\nhome directory. The user profile is stored in the `C:\\Users\\<username>` directory.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "default"=>"false"
        },
        {
          "name"=>"membership",
          "description"=>"If `minimum` is specified, Puppet will ensure that the user is a\nmember of all specified groups, but will not remove any other groups\nthat the user is a part of.\n\nIf `inclusive` is specified, Puppet will ensure that the user is a\nmember of **only** specified groups.",
          "values"=>[
            "inclusive",
            "minimum"
          ],
          "default"=>"minimum"
        },
        {
          "name"=>"name",
          "description"=>"The user name. While naming limitations vary by operating system,\nit is advisable to restrict names to the lowest common denominator,\nwhich is a maximum of 8 characters beginning with a letter.\n\nNote that Puppet considers user names to be case-sensitive, regardless\nof the platform's own rules; be sure to always use the same case when\nreferring to a given user.",
          "isnamevar"=>true
        },
        {
          "name"=>"profile_membership",
          "description"=>"Whether specified roles should be treated as the **complete list**\n(`inclusive`) or the **minimum list** (`minimum`) of roles\nof which the user is a member.",
          "values"=>[
            "inclusive",
            "minimum"
          ],
          "default"=>"minimum"
        },
        {
          "name"=>"provider",
          "description"=>"The specific backend to use for this `user` resource. You will seldom need to specify this --- Puppet will usually discover the appropriate provider for your platform."
        },
        {
          "name"=>"purge_ssh_keys",
          "description"=>"Whether to purge authorized SSH keys for this user if they are not managed\nwith the `ssh_authorized_key` resource type. This parameter is a noop if the\nssh_authorized_key type is not available.\n\nAllowed values are:\n\n* `false` (default) --- don't purge SSH keys for this user.\n* `true` --- look for keys in the `.ssh/authorized_keys` file in the user's\n  home directory. Purge any keys that aren't managed as `ssh_authorized_key`\n  resources.\n* An array of file paths --- look for keys in all of the files listed. Purge\n  any keys that aren't managed as `ssh_authorized_key` resources. If any of\n  these paths starts with `~` or `%h`, that token will be replaced with\n  the user's home directory.",
          "values"=>[
            "true",
            "false"
          ],
          "default"=>"false"
        },
        {
          "name"=>"role_membership",
          "description"=>"Whether specified roles should be considered the **complete list**\n(`inclusive`) or the **minimum list** (`minimum`) of roles the user\nhas.",
          "values"=>[
            "inclusive",
            "minimum"
          ],
          "default"=>"minimum"
        },
        {
          "name"=>"system",
          "description"=>"Whether the user is a system user, according to the OS's criteria;\non most platforms, a UID less than or equal to 500 indicates a system\nuser. This parameter is only used when the resource is created and will\nnot affect the UID when the user is present.",
          "values"=>[
            "true",
            "false",
            "yes",
            "no"
          ],
          "default"=>"false"
        }
      ],
      "features"=>[
        {
          "name"=>"allows_duplicates",
          "description"=>"The provider supports duplicate users with the same UID."
        },
        {
          "name"=>"manages_aix_lam",
          "description"=>"The provider can manage AIX Loadable Authentication Module (LAM) system."
        },
        {
          "name"=>"manages_expiry",
          "description"=>"The provider can manage the expiry date for a user."
        },
        {
          "name"=>"manages_homedir",
          "description"=>"The provider can create and remove home directories."
        },
        {
          "name"=>"manages_local_users_and_groups",
          "description"=>"Allows local users to be managed on systems that also use some other remote Name Service Switch (NSS) method of managing accounts."
        },
        {
          "name"=>"manages_loginclass",
          "description"=>"The provider can manage the login class for a user."
        },
        {
          "name"=>"manages_password_age",
          "description"=>"The provider can set age requirements and restrictions for passwords."
        },
        {
          "name"=>"manages_password_salt",
          "description"=>"The provider can set a password salt. This is for providers that implement PBKDF2 passwords with salt properties."
        },
        {
          "name"=>"manages_passwords",
          "description"=>"The provider can modify user passwords, by accepting a password hash."
        },
        {
          "name"=>"manages_roles",
          "description"=>"The provider can manage roles"
        },
        {
          "name"=>"manages_shell",
          "description"=>"The provider allows for setting shell and validates if possible"
        },
        {
          "name"=>"manages_solaris_rbac",
          "description"=>"The provider can manage normal users"
        },
        {
          "name"=>"system_users",
          "description"=>"The provider allows you to create system users with lower UIDs."
        }
      ],
      "providers"=>[
        {
          "name"=>"aix",
          "type_name"=>"user",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/aix.rb",
          "line"=>17,
          "docstring"=>{
            "text"=>"User management for AIX."
          },
          "confines"=>{
            "operatingsystem"=>"aix"
          },
          "features"=>[
            "manages_aix_lam",
            "manages_homedir",
            "manages_passwords",
            "manages_shell",
            "manages_expiry",
            "manages_password_age",
            "manages_local_users_and_groups"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "aix"
              ]
            ]
          ],
          "commands"=>{
            "list"=>"/usr/sbin/lsuser",
            "add"=>"/usr/bin/mkuser",
            "delete"=>"/usr/sbin/rmuser",
            "modify"=>"/usr/bin/chuser",
            "chpasswd"=>"/bin/chpasswd"
          }
        },
        {
          "name"=>"directoryservice",
          "type_name"=>"user",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/directoryservice.rb",
          "line"=>5,
          "docstring"=>{
            "text"=>"User management on OS X."
          },
          "confines"=>{
            "operatingsystem"=>"darwin",
            "feature"=>"cfpropertylist"
          },
          "features"=>[
            "manages_passwords",
            "manages_password_salt",
            "manages_shell"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "darwin"
              ]
            ]
          ],
          "commands"=>{
            "uuidgen"=>"/usr/bin/uuidgen",
            "dsimport"=>"/usr/bin/dsimport",
            "dscl"=>"/usr/bin/dscl",
            "dscacheutil"=>"/usr/bin/dscacheutil"
          }
        },
        {
          "name"=>"hpuxuseradd",
          "type_name"=>"user",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/hpux.rb",
          "line"=>1,
          "docstring"=>{
            "text"=>"User management for HP-UX. This provider uses the undocumented `-F`\nswitch to HP-UX's special `usermod` binary to work around the fact that\nits standard `usermod` cannot make changes while the user is logged in.\nNew functionality provides for changing trusted computing passwords and\nresetting password expirations under trusted computing."
          },
          "confines"=>{
            "operatingsystem"=>"hp-ux"
          },
          "features"=>[
            "manages_homedir",
            "allows_duplicates",
            "manages_passwords"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "hp-ux"
              ]
            ]
          ],
          "commands"=>{
            "modify"=>"/usr/sam/lbin/usermod.sam",
            "delete"=>"/usr/sam/lbin/userdel.sam",
            "add"=>"/usr/sam/lbin/useradd.sam"
          }
        },
        {
          "name"=>"ldap",
          "type_name"=>"user",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/ldap.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"User management via LDAP.\n\nThis provider requires that you have valid values for all of the\nLDAP-related settings in `puppet.conf`, including `ldapbase`.  You will\nalmost definitely need settings for `ldapuser` and `ldappassword` in order\nfor your clients to write to LDAP.\n\nNote that this provider will automatically generate a UID for you if\nyou do not specify one, but it is a potentially expensive operation,\nas it iterates across all existing users to pick the appropriate next one."
          },
          "confines"=>{
            "feature"=>"ldap",
            "false"=>"(Puppet[:ldapuser] == \"\")"
          },
          "features"=>[
            "manages_passwords",
            "manages_shell"
          ]
        },
        {
          "name"=>"openbsd",
          "type_name"=>"user",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/openbsd.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"User management via `useradd` and its ilk for OpenBSD. Note that you\nwill need to install Ruby's shadow password library (package known as\n`ruby-shadow`) if you wish to manage user passwords."
          },
          "confines"=>{
            "operatingsystem"=>"openbsd"
          },
          "features"=>[
            "manages_homedir",
            "manages_expiry",
            "system_users",
            "manages_shell"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "openbsd"
              ]
            ]
          ],
          "commands"=>{
            "add"=>"useradd",
            "delete"=>"userdel",
            "modify"=>"usermod",
            "password"=>"passwd"
          }
        },
        {
          "name"=>"pw",
          "type_name"=>"user",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/pw.rb",
          "line"=>4,
          "docstring"=>{
            "text"=>"User management via `pw` on FreeBSD and DragonFly BSD."
          },
          "confines"=>{
            "operatingsystem"=>"[:freebsd, :dragonfly]"
          },
          "features"=>[
            "manages_homedir",
            "allows_duplicates",
            "manages_passwords",
            "manages_expiry",
            "manages_shell"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "[:freebsd, :dragonfly]"
              ]
            ]
          ],
          "commands"=>{
            "pw"=>"pw"
          }
        },
        {
          "name"=>"user_role_add",
          "type_name"=>"user",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/user_role_add.rb",
          "line"=>5,
          "docstring"=>{
            "text"=>"User and role management on Solaris, via `useradd` and `roleadd`."
          },
          "features"=>[
            "manages_homedir",
            "allows_duplicates",
            "manages_solaris_rbac",
            "manages_roles",
            "manages_passwords",
            "manages_password_age",
            "manages_shell"
          ],
          "defaults"=>[
            [
              [
                "osfamily",
                "solaris"
              ]
            ]
          ],
          "commands"=>{
            "add"=>"useradd",
            "delete"=>"userdel",
            "modify"=>"usermod",
            "password"=>"passwd",
            "role_add"=>"roleadd",
            "role_delete"=>"roledel",
            "role_modify"=>"rolemod"
          }
        },
        {
          "name"=>"useradd",
          "type_name"=>"user",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/useradd.rb",
          "line"=>7,
          "docstring"=>{
            "text"=>"User management via `useradd` and its ilk.  Note that you will need to\ninstall Ruby's shadow password library (often known as `ruby-libshadow`)\nif you wish to manage user passwords."
          },
          "features"=>[
            "manages_homedir",
            "allows_duplicates",
            "manages_expiry",
            "manages_shell"
          ],
          "commands"=>{
            "add"=>"useradd",
            "delete"=>"userdel",
            "modify"=>"usermod",
            "password"=>"chage"
          }
        },
        {
          "name"=>"windows_adsi",
          "type_name"=>"user",
          "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/windows_adsi.rb",
          "line"=>3,
          "docstring"=>{
            "text"=>"Local user management for Windows."
          },
          "confines"=>{
            "operatingsystem"=>"windows"
          },
          "features"=>[
            "manages_homedir",
            "manages_passwords",
            "manages_roles"
          ],
          "defaults"=>[
            [
              [
                "operatingsystem",
                "windows"
              ]
            ]
          ]
        }
      ]
    },
    {
      "name"=>"whit",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/type/whit.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Whits are internal artifacts of Puppet's current implementation, and\nPuppet suppresses their appearance in all logs. We make no guarantee of\nthe whit's continued existence, and it should never be used in an actual\nmanifest. Use the `anchor` type from the puppetlabs-stdlib module if you\nneed arbitrary whit-like no-op resources."
      },
      "parameters"=>[
        {
          "name"=>"name",
          "description"=>"The name of the whit, because it must have one.",
          "isnamevar"=>true
        }
      ]
    }
  ],
  "providers"=>[
    {
      "name"=>"aix",
      "type_name"=>"user",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/aix.rb",
      "line"=>17,
      "docstring"=>{
        "text"=>"User management for AIX."
      },
      "confines"=>{
        "operatingsystem"=>"aix"
      },
      "features"=>[
        "manages_aix_lam",
        "manages_homedir",
        "manages_passwords",
        "manages_shell",
        "manages_expiry",
        "manages_password_age",
        "manages_local_users_and_groups"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "aix"
          ]
        ]
      ],
      "commands"=>{
        "list"=>"/usr/sbin/lsuser",
        "add"=>"/usr/bin/mkuser",
        "delete"=>"/usr/sbin/rmuser",
        "modify"=>"/usr/bin/chuser",
        "chpasswd"=>"/bin/chpasswd"
      }
    },
    {
      "name"=>"aix",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/aix.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Installation from an AIX software directory, using the AIX `installp`\ncommand.  The `source` parameter is required for this provider, and should\nbe set to the absolute path (on the puppet agent machine) of a directory\ncontaining one or more BFF package files.\n\nThe `installp` command will generate a table of contents file (named `.toc`)\nin this directory, and the `name` parameter (or resource title) that you\nspecify for your `package` resource must match a package name that exists\nin the `.toc` file.\n\nNote that package downgrades are *not* supported; if your resource specifies\na specific version number and there is already a newer version of the package\ninstalled on the machine, the resource will fail with an error message."
      },
      "confines"=>{
        "operatingsystem"=>"[ :aix ]"
      },
      "features"=>[
        "versionable"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "aix"
          ]
        ]
      ],
      "commands"=>{
        "lslpp"=>"/usr/bin/lslpp",
        "installp"=>"/usr/sbin/installp"
      }
    },
    {
      "name"=>"aix",
      "type_name"=>"group",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/group/aix.rb",
      "line"=>5,
      "docstring"=>{
        "text"=>"Group management for AIX."
      },
      "confines"=>{
        "operatingsystem"=>"aix"
      },
      "features"=>[
        "manages_aix_lam",
        "manages_members",
        "manages_local_users_and_groups"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "aix"
          ]
        ]
      ],
      "commands"=>{
        "list"=>"/usr/sbin/lsgroup",
        "add"=>"/usr/bin/mkgroup",
        "delete"=>"/usr/sbin/rmgroup",
        "modify"=>"/usr/bin/chgroup"
      }
    },
    {
      "name"=>"appdmg",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/appdmg.rb",
      "line"=>17,
      "docstring"=>{
        "text"=>"Package management which copies application bundles to a target."
      },
      "confines"=>{
        "operatingsystem"=>"darwin",
        "feature"=>"cfpropertylist"
      },
      "commands"=>{
        "hdiutil"=>"/usr/bin/hdiutil",
        "curl"=>"/usr/bin/curl",
        "ditto"=>"/usr/bin/ditto"
      }
    },
    {
      "name"=>"apple",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/apple.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Package management based on OS X's built-in packaging system.  This is\nessentially the simplest and least functional package system in existence --\nit only supports installation; no deletion or upgrades.  The provider will\nautomatically add the `.pkg` extension, so leave that off when specifying\nthe package name."
      },
      "confines"=>{
        "operatingsystem"=>"darwin"
      },
      "commands"=>{
        "installer"=>"/usr/sbin/installer"
      }
    },
    {
      "name"=>"apt",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/apt.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Package management via `apt-get`.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to apt-get.\nThese options should be specified as an array where each element is either a\n string or a hash."
      },
      "features"=>[
        "versionable",
        "install_options",
        "virtual_packages"
      ],
      "defaults"=>[
        [
          [
            "osfamily",
            "debian"
          ]
        ]
      ],
      "commands"=>{
        "aptget"=>"/usr/bin/apt-get",
        "aptcache"=>"/usr/bin/apt-cache",
        "aptmark"=>"/usr/bin/apt-mark",
        "preseed"=>"/usr/bin/debconf-set-selections"
      }
    },
    {
      "name"=>"aptitude",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/aptitude.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Package management via `aptitude`."
      },
      "features"=>[
        "versionable"
      ],
      "commands"=>{
        "aptitude"=>"/usr/bin/aptitude",
        "aptcache"=>"/usr/bin/apt-cache"
      }
    },
    {
      "name"=>"aptrpm",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/aptrpm.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Package management via `apt-get` ported to `rpm`."
      },
      "features"=>[
        "versionable"
      ],
      "commands"=>{
        "aptget"=>"apt-get",
        "aptcache"=>"apt-cache",
        "rpm"=>"rpm"
      }
    },
    {
      "name"=>"base",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/base.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"The simplest form of Unix service support.\n\nYou have to specify enough about your service for this to work; the\nminimum you can specify is a binary for starting the process, and this\nsame binary will be searched for in the process table to stop the\nservice.  As with `init`-style services, it is preferable to specify start,\nstop, and status commands."
      },
      "commands"=>{
        "kill"=>"kill"
      }
    },
    {
      "name"=>"blastwave",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/blastwave.rb",
      "line"=>2,
      "docstring"=>{
        "text"=>"Package management using Blastwave.org's `pkg-get` command on Solaris."
      },
      "confines"=>{
        "osfamily"=>"solaris"
      },
      "commands"=>{
        "pkgget"=>"pkgget"
      }
    },
    {
      "name"=>"bsd",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/bsd.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Generic BSD form of `init`-style service management with `rc.d`.\n\nUses `rc.conf.d` for service enabling and disabling."
      },
      "confines"=>{
        "operatingsystem"=>"[:freebsd, :dragonfly]"
      }
    },
    {
      "name"=>"daemontools",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/daemontools.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Daemontools service management.\n\nThis provider manages daemons supervised by D.J. Bernstein daemontools.\nWhen detecting the service directory it will check, in order of preference:\n\n* `/service`\n* `/etc/service`\n* `/var/lib/svscan`\n\nThe daemon directory should be in one of the following locations:\n\n* `/var/lib/service`\n* `/etc`\n\n...or this can be overridden in the resource's attributes:\n\n    service { 'myservice':\n      provider => 'daemontools',\n      path     => '/path/to/daemons',\n    }\n\nThis provider supports out of the box:\n\n* start/stop (mapped to enable/disable)\n* enable/disable\n* restart\n* status\n\nIf a service has `ensure => \"running\"`, it will link /path/to/daemon to\n/path/to/service, which will automatically enable the service.\n\nIf a service has `ensure => \"stopped\"`, it will only shut down the service, not\nremove the `/path/to/service` link."
      },
      "commands"=>{
        "svc"=>"/usr/bin/svc",
        "svstat"=>"/usr/bin/svstat"
      }
    },
    {
      "name"=>"debian",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/debian.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Debian's form of `init`-style management.\n\nThe only differences from `init` are support for enabling and disabling\nservices via `update-rc.d` and the ability to determine enabled status via\n`invoke-rc.d`."
      },
      "confines"=>{
        "false"=>"Puppet::FileSystem.exist?('/proc/1/comm') && Puppet::FileSystem.read('/proc/1/comm').include?('systemd')"
      },
      "defaults"=>[
        [
          [
            "operatingsystem",
            "cumuluslinux"
          ],
          [
            "operatingsystemmajrelease",
            "['1','2']"
          ]
        ],
        [
          [
            "operatingsystem",
            "debian"
          ],
          [
            "operatingsystemmajrelease",
            "['5','6','7']"
          ]
        ],
        [
          [
            "operatingsystem",
            "devuan"
          ]
        ]
      ],
      "commands"=>{
        "update_rc"=>"/usr/sbin/update-rc.d",
        "invoke_rc"=>"/usr/sbin/invoke-rc.d",
        "service"=>"/usr/sbin/service"
      }
    },
    {
      "name"=>"directoryservice",
      "type_name"=>"group",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/group/directoryservice.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Group management using DirectoryService on OS X."
      },
      "confines"=>{
        "operatingsystem"=>"darwin"
      },
      "features"=>[
        "manages_members"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "darwin"
          ]
        ]
      ],
      "commands"=>{
        "dscl"=>"/usr/bin/dscl"
      }
    },
    {
      "name"=>"directoryservice",
      "type_name"=>"user",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/directoryservice.rb",
      "line"=>5,
      "docstring"=>{
        "text"=>"User management on OS X."
      },
      "confines"=>{
        "operatingsystem"=>"darwin",
        "feature"=>"cfpropertylist"
      },
      "features"=>[
        "manages_passwords",
        "manages_password_salt",
        "manages_shell"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "darwin"
          ]
        ]
      ],
      "commands"=>{
        "uuidgen"=>"/usr/bin/uuidgen",
        "dsimport"=>"/usr/bin/dsimport",
        "dscl"=>"/usr/bin/dscl",
        "dscacheutil"=>"/usr/bin/dscacheutil"
      }
    },
    {
      "name"=>"dnf",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/dnf.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Support via `dnf`.\n\nUsing this provider's `uninstallable` feature will not remove dependent packages. To\nremove dependent packages with this provider use the `purgeable` feature, but note this\nfeature is destructive and should be used with the utmost care.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to dnf.\nThese options should be specified as an array where each element is either\n a string or a hash."
      },
      "features"=>[
        "install_options",
        "versionable",
        "virtual_packages",
        "install_only"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "fedora"
          ]
        ],
        [
          [
            "osfamily",
            "redhat"
          ]
        ]
      ],
      "commands"=>{
        "cmd"=>"dnf",
        "rpm"=>"rpm"
      }
    },
    {
      "name"=>"dnfmodule",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/dnfmodule.rb",
      "line"=>13,
      "docstring"=>{
        "text"=>""
      },
      "features"=>[
        "installable",
        "uninstallable",
        "versionable",
        "supports_flavors",
        "disableable"
      ],
      "commands"=>{
        "dnf"=>"/usr/bin/dnf"
      }
    },
    {
      "name"=>"dpkg",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/dpkg.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Package management via `dpkg`.  Because this only uses `dpkg`\nand not `apt`, you must specify the source of any packages you want\nto manage."
      },
      "features"=>[
        "holdable",
        "virtual_packages"
      ],
      "commands"=>{
        "dpkg"=>"/usr/bin/dpkg",
        "dpkg_deb"=>"/usr/bin/dpkg-deb",
        "dpkgquery"=>"/usr/bin/dpkg-query"
      }
    },
    {
      "name"=>"fink",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/fink.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Package management via `fink`."
      },
      "features"=>[
        "versionable"
      ],
      "commands"=>{
        "fink"=>"/sw/bin/fink",
        "aptget"=>"/sw/bin/apt-get",
        "aptcache"=>"/sw/bin/apt-cache",
        "dpkgquery"=>"/sw/bin/dpkg-query"
      }
    },
    {
      "name"=>"freebsd",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/freebsd.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"The specific form of package management on FreeBSD.  This is an\nextremely quirky packaging system, in that it freely mixes between\nports and packages.  Apparently all of the tools are written in Ruby,\nso there are plans to rewrite this support to directly use those\nlibraries."
      },
      "confines"=>{
        "operatingsystem"=>"freebsd"
      },
      "commands"=>{
        "pkginfo"=>"/usr/sbin/pkg_info",
        "pkgadd"=>"/usr/sbin/pkg_add",
        "pkgdelete"=>"/usr/sbin/pkg_delete"
      }
    },
    {
      "name"=>"freebsd",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/freebsd.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Provider for FreeBSD and DragonFly BSD. Uses the `rcvar` argument of init scripts and parses/edits rc files."
      },
      "confines"=>{
        "operatingsystem"=>"[:freebsd, :dragonfly]"
      },
      "defaults"=>[
        [
          [
            "operatingsystem",
            "[:freebsd, :dragonfly]"
          ]
        ]
      ]
    },
    {
      "name"=>"gem",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/gem.rb",
      "line"=>7,
      "docstring"=>{
        "text"=>"Ruby Gem support. If a URL is passed via `source`, then that URL is\nappended to the list of remote gem repositories; to ensure that only the\nspecified source is used, also pass `--clear-sources` via `install_options`.\nIf source is present but is not a valid URL, it will be interpreted as the\npath to a local gem file. If source is not present, the gem will be\ninstalled from the default gem repositories. Note that to modify this for Windows, it has to be a valid URL.\n\nThis provider supports the `install_options` and `uninstall_options` attributes,\nwhich allow command-line flags to be passed to the gem command.\nThese options should be specified as an array where each element is either a\nstring or a hash."
      },
      "features"=>[
        "versionable",
        "install_options",
        "uninstall_options",
        "targetable",
        "version_ranges"
      ]
    },
    {
      "name"=>"gentoo",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/gentoo.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Gentoo's form of `init`-style service management.\n\nUses `rc-update` for service enabling and disabling."
      },
      "confines"=>{
        "operatingsystem"=>"gentoo"
      },
      "commands"=>{
        "update"=>"/sbin/rc-update"
      }
    },
    {
      "name"=>"groupadd",
      "type_name"=>"group",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/group/groupadd.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Group management via `groupadd` and its ilk. The default for most platforms."
      },
      "commands"=>{
        "add"=>"groupadd",
        "delete"=>"groupdel",
        "modify"=>"groupmod"
      }
    },
    {
      "name"=>"hpux",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/hpux.rb",
      "line"=>5,
      "docstring"=>{
        "text"=>"HP-UX's packaging system."
      },
      "confines"=>{
        "operatingsystem"=>"hp-ux"
      },
      "defaults"=>[
        [
          [
            "operatingsystem",
            "hp-ux"
          ]
        ]
      ],
      "commands"=>{
        "swinstall"=>"/usr/sbin/swinstall",
        "swlist"=>"/usr/sbin/swlist",
        "swremove"=>"/usr/sbin/swremove"
      }
    },
    {
      "name"=>"hpuxuseradd",
      "type_name"=>"user",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/hpux.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"User management for HP-UX. This provider uses the undocumented `-F`\nswitch to HP-UX's special `usermod` binary to work around the fact that\nits standard `usermod` cannot make changes while the user is logged in.\nNew functionality provides for changing trusted computing passwords and\nresetting password expirations under trusted computing."
      },
      "confines"=>{
        "operatingsystem"=>"hp-ux"
      },
      "features"=>[
        "manages_homedir",
        "allows_duplicates",
        "manages_passwords"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "hp-ux"
          ]
        ]
      ],
      "commands"=>{
        "modify"=>"/usr/sam/lbin/usermod.sam",
        "delete"=>"/usr/sam/lbin/userdel.sam",
        "add"=>"/usr/sam/lbin/useradd.sam"
      }
    },
    {
      "name"=>"init",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/init.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Standard `init`-style service management."
      },
      "confines"=>{
        "true"=>"begin\n      os = Facter.value(:operatingsystem).downcase\n      family = Facter.value(:osfamily).downcase\n      !(os == 'debian' || os == 'ubuntu' || family == 'redhat')\n  end"
      }
    },
    {
      "name"=>"launchd",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/launchd.rb",
      "line"=>2,
      "docstring"=>{
        "text"=>"This provider manages jobs with `launchd`, which is the default service\nframework for Mac OS X (and may be available for use on other platforms).\n\nFor more information, see the `launchd` man page:\n\n* <https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man8/launchd.8.html>\n\nThis provider reads plists out of the following directories:\n\n* `/System/Library/LaunchDaemons`\n* `/System/Library/LaunchAgents`\n* `/Library/LaunchDaemons`\n* `/Library/LaunchAgents`\n\n...and builds up a list of services based upon each plist's \"Label\" entry.\n\nThis provider supports:\n\n* ensure => running/stopped,\n* enable => true/false\n* status\n* restart\n\nHere is how the Puppet states correspond to `launchd` states:\n\n* stopped --- job unloaded\n* started --- job loaded\n* enabled --- 'Disable' removed from job plist file\n* disabled --- 'Disable' added to job plist file\n\nNote that this allows you to do something `launchctl` can't do, which is to\nbe in a state of \"stopped/enabled\" or \"running/disabled\".\n\nNote that this provider does not support overriding 'restart'"
      },
      "confines"=>{
        "operatingsystem"=>"darwin",
        "feature"=>"cfpropertylist"
      },
      "features"=>[
        "enableable",
        "refreshable"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "darwin"
          ]
        ]
      ],
      "commands"=>{
        "launchctl"=>"/bin/launchctl"
      }
    },
    {
      "name"=>"ldap",
      "type_name"=>"group",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/group/ldap.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Group management via LDAP.\n\nThis provider requires that you have valid values for all of the\nLDAP-related settings in `puppet.conf`, including `ldapbase`.  You will\nalmost definitely need settings for `ldapuser` and `ldappassword` in order\nfor your clients to write to LDAP.\n\nNote that this provider will automatically generate a GID for you if you do\nnot specify one, but it is a potentially expensive operation, as it\niterates across all existing groups to pick the appropriate next one."
      },
      "confines"=>{
        "feature"=>"ldap",
        "false"=>"(Puppet[:ldapuser] == \"\")"
      }
    },
    {
      "name"=>"ldap",
      "type_name"=>"user",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/ldap.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"User management via LDAP.\n\nThis provider requires that you have valid values for all of the\nLDAP-related settings in `puppet.conf`, including `ldapbase`.  You will\nalmost definitely need settings for `ldapuser` and `ldappassword` in order\nfor your clients to write to LDAP.\n\nNote that this provider will automatically generate a UID for you if\nyou do not specify one, but it is a potentially expensive operation,\nas it iterates across all existing users to pick the appropriate next one."
      },
      "confines"=>{
        "feature"=>"ldap",
        "false"=>"(Puppet[:ldapuser] == \"\")"
      },
      "features"=>[
        "manages_passwords",
        "manages_shell"
      ]
    },
    {
      "name"=>"macports",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/macports.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Package management using MacPorts on OS X.\n\nSupports MacPorts versions and revisions, but not variants.\nVariant preferences may be specified using\n[the MacPorts variants.conf file](http://guide.macports.org/chunked/internals.configuration-files.html#internals.configuration-files.variants-conf).\n\nWhen specifying a version in the Puppet DSL, only specify the version, not the revision.\nRevisions are only used internally for ensuring the latest version/revision of a port."
      },
      "confines"=>{
        "operatingsystem"=>"darwin"
      },
      "features"=>[
        "installable",
        "uninstallable",
        "upgradeable",
        "versionable"
      ]
    },
    {
      "name"=>"nim",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/nim.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Installation from an AIX NIM LPP source.  The `source` parameter is required\nfor this provider, and should specify the name of a NIM `lpp_source` resource\nthat is visible to the puppet agent machine.  This provider supports the\nmanagement of both BFF/installp and RPM packages.\n\nNote that package downgrades are *not* supported; if your resource specifies\na specific version number and there is already a newer version of the package\ninstalled on the machine, the resource will fail with an error message."
      },
      "confines"=>{
        "exists"=>"/etc/niminfo"
      },
      "features"=>[
        "versionable"
      ],
      "commands"=>{
        "nimclient"=>"/usr/sbin/nimclient",
        "lslpp"=>"/usr/bin/lslpp",
        "rpm"=>"rpm"
      }
    },
    {
      "name"=>"openbsd",
      "type_name"=>"user",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/openbsd.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"User management via `useradd` and its ilk for OpenBSD. Note that you\nwill need to install Ruby's shadow password library (package known as\n`ruby-shadow`) if you wish to manage user passwords."
      },
      "confines"=>{
        "operatingsystem"=>"openbsd"
      },
      "features"=>[
        "manages_homedir",
        "manages_expiry",
        "system_users",
        "manages_shell"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "openbsd"
          ]
        ]
      ],
      "commands"=>{
        "add"=>"useradd",
        "delete"=>"userdel",
        "modify"=>"usermod",
        "password"=>"passwd"
      }
    },
    {
      "name"=>"openbsd",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/openbsd.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Provider for OpenBSD's rc.d daemon control scripts"
      },
      "confines"=>{
        "operatingsystem"=>"openbsd"
      },
      "features"=>[
        "flaggable"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "openbsd"
          ]
        ]
      ],
      "commands"=>{
        "rcctl"=>"/usr/sbin/rcctl"
      }
    },
    {
      "name"=>"openbsd",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/openbsd.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"OpenBSD's form of `pkg_add` support.\n\nThis provider supports the `install_options` and `uninstall_options`\nattributes, which allow command-line flags to be passed to pkg_add and pkg_delete.\nThese options should be specified as an array where each element is either a\n string or a hash."
      },
      "confines"=>{
        "operatingsystem"=>"openbsd"
      },
      "features"=>[
        "versionable",
        "install_options",
        "uninstall_options",
        "upgradeable",
        "supports_flavors"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "openbsd"
          ]
        ]
      ],
      "commands"=>{
        "pkginfo"=>"pkg_info",
        "pkgadd"=>"pkg_add",
        "pkgdelete"=>"pkg_delete"
      }
    },
    {
      "name"=>"openrc",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/openrc.rb",
      "line"=>2,
      "docstring"=>{
        "text"=>"Support for Gentoo's OpenRC initskripts\n\nUses rc-update, rc-status and rc-service to manage services."
      },
      "defaults"=>[
        [
          [
            "operatingsystem",
            "gentoo"
          ]
        ],
        [
          [
            "operatingsystem",
            "funtoo"
          ]
        ]
      ],
      "commands"=>{
        "rcservice"=>"/sbin/rc-service",
        "rcupdate"=>"/sbin/rc-update"
      }
    },
    {
      "name"=>"openwrt",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/openwrt.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Support for OpenWrt flavored init scripts.\n\nUses /etc/init.d/service_name enable, disable, and enabled."
      },
      "confines"=>{
        "operatingsystem"=>"openwrt"
      },
      "features"=>[
        "enableable"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "openwrt"
          ]
        ]
      ]
    },
    {
      "name"=>"opkg",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/opkg.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Opkg packaging support. Common on OpenWrt and OpenEmbedded platforms"
      },
      "confines"=>{
        "operatingsystem"=>"openwrt"
      },
      "defaults"=>[
        [
          [
            "operatingsystem",
            "openwrt"
          ]
        ]
      ],
      "commands"=>{
        "opkg"=>"opkg"
      }
    },
    {
      "name"=>"pacman",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pacman.rb",
      "line"=>5,
      "docstring"=>{
        "text"=>"Support for the Package Manager Utility (pacman) used in Archlinux.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to pacman.\nThese options should be specified as an array where each element is either a string or a hash."
      },
      "confines"=>{
        "operatingsystem"=>"[:archlinux, :manjarolinux]"
      },
      "features"=>[
        "install_options",
        "uninstall_options",
        "upgradeable",
        "virtual_packages"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "[:archlinux, :manjarolinux]"
          ]
        ]
      ],
      "commands"=>{
        "pacman"=>"/usr/bin/pacman"
      }
    },
    {
      "name"=>"pip",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pip.rb",
      "line"=>8,
      "docstring"=>{
        "text"=>"Python packages via `pip`.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to pip.\nThese options should be specified as an array where each element is either a string or a hash."
      },
      "features"=>[
        "installable",
        "uninstallable",
        "upgradeable",
        "versionable",
        "version_ranges",
        "install_options",
        "targetable"
      ]
    },
    {
      "name"=>"pip2",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pip2.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Python packages via `pip2`.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to pip2.\nThese options should be specified as an array where each element is either a string or a hash."
      },
      "features"=>[
        "installable",
        "uninstallable",
        "upgradeable",
        "versionable",
        "install_options",
        "targetable"
      ]
    },
    {
      "name"=>"pip3",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pip3.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Python packages via `pip3`.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to pip3.\nThese options should be specified as an array where each element is either a string or a hash."
      },
      "features"=>[
        "installable",
        "uninstallable",
        "upgradeable",
        "versionable",
        "install_options",
        "targetable"
      ]
    },
    {
      "name"=>"pkg",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pkg.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"OpenSolaris image packaging system. See pkg(5) for more information.\n\nThis provider supports the `install_options` attribute, which allows\ncommand-line flags to be passed to pkg. These options should be specified as an\narray where each element is either a string or a hash."
      },
      "confines"=>{
        "osfamily"=>"solaris"
      },
      "features"=>[
        "versionable",
        "upgradable",
        "holdable",
        "install_options"
      ],
      "defaults"=>[
        [
          [
            "osfamily",
            "solaris"
          ],
          [
            "kernelrelease",
            "['5.11', '5.12']"
          ]
        ]
      ],
      "commands"=>{
        "pkg"=>"/usr/bin/pkg"
      }
    },
    {
      "name"=>"pkgdmg",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pkgdmg.rb",
      "line"=>15,
      "docstring"=>{
        "text"=>"Package management based on Apple's Installer.app and DiskUtility.app.\n\nThis provider works by checking the contents of a DMG image for Apple pkg or\nmpkg files. Any number of pkg or mpkg files may exist in the root directory\nof the DMG file system, and Puppet will install all of them. Subdirectories\nare not checked for packages.\n\nThis provider can also accept plain .pkg (but not .mpkg) files in addition\nto .dmg files.\n\nNotes:\n\n* The `source` attribute is mandatory. It must be either a local disk path\n  or an HTTP, HTTPS, or FTP URL to the package.\n* The `name` of the resource must be the filename (without path) of the DMG file.\n* When installing the packages from a DMG, this provider writes a file to\n  disk at `/var/db/.puppet_pkgdmg_installed_NAME`. If that file is present,\n  Puppet assumes all packages from that DMG are already installed.\n* This provider is not versionable and uses DMG filenames to determine\n  whether a package has been installed. Thus, to install new a version of a\n  package, you must create a new DMG with a different filename."
      },
      "confines"=>{
        "operatingsystem"=>"darwin",
        "feature"=>"cfpropertylist"
      },
      "defaults"=>[
        [
          [
            "operatingsystem",
            "darwin"
          ]
        ]
      ],
      "commands"=>{
        "installer"=>"/usr/sbin/installer",
        "hdiutil"=>"/usr/bin/hdiutil",
        "curl"=>"/usr/bin/curl"
      }
    },
    {
      "name"=>"pkgin",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pkgin.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Package management using pkgin, a binary package manager for pkgsrc."
      },
      "features"=>[
        "installable",
        "uninstallable",
        "upgradeable",
        "versionable"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "[ :smartos, :netbsd ]"
          ]
        ]
      ],
      "commands"=>{
        "pkgin"=>"pkgin"
      }
    },
    {
      "name"=>"pkgng",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pkgng.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"A PkgNG provider for FreeBSD and DragonFly."
      },
      "confines"=>{
        "operatingsystem"=>"[:freebsd, :dragonfly]"
      },
      "features"=>[
        "versionable",
        "upgradeable",
        "install_options"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "[:freebsd, :dragonfly]"
          ]
        ]
      ],
      "commands"=>{
        "pkg"=>"/usr/local/sbin/pkg"
      }
    },
    {
      "name"=>"pkgutil",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/pkgutil.rb",
      "line"=>2,
      "docstring"=>{
        "text"=>"Package management using Peter Bonivart's ``pkgutil`` command on Solaris."
      },
      "confines"=>{
        "osfamily"=>"solaris"
      }
    },
    {
      "name"=>"portage",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/portage.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Provides packaging support for Gentoo's portage system.\n\nThis provider supports the `install_options` and `uninstall_options` attributes, which allows command-line\nflags to be passed to emerge. These options should be specified as an array where each element is either a string or a hash."
      },
      "confines"=>{
        "osfamily"=>"gentoo"
      },
      "features"=>[
        "install_options",
        "purgeable",
        "reinstallable",
        "uninstall_options",
        "versionable",
        "virtual_packages"
      ],
      "defaults"=>[
        [
          [
            "osfamily",
            "gentoo"
          ]
        ]
      ]
    },
    {
      "name"=>"ports",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/ports.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Support for FreeBSD's ports.  Note that this, too, mixes packages and ports."
      },
      "commands"=>{
        "portupgrade"=>"/usr/local/sbin/portupgrade",
        "portversion"=>"/usr/local/sbin/portversion",
        "portuninstall"=>"/usr/local/sbin/pkg_deinstall",
        "portinfo"=>"/usr/sbin/pkg_info"
      }
    },
    {
      "name"=>"portupgrade",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/portupgrade.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Support for FreeBSD's ports using the portupgrade ports management software.\nUse the port's full origin as the resource name. eg (ports-mgmt/portupgrade)\nfor the portupgrade port."
      },
      "commands"=>{
        "portupgrade"=>"/usr/local/sbin/portupgrade",
        "portinstall"=>"/usr/local/sbin/portinstall",
        "portversion"=>"/usr/local/sbin/portversion",
        "portuninstall"=>"/usr/local/sbin/pkg_deinstall",
        "portinfo"=>"/usr/sbin/pkg_info"
      }
    },
    {
      "name"=>"posix",
      "type_name"=>"exec",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/exec/posix.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Executes external binaries directly, without passing through a shell or\nperforming any interpolation. This is a safer and more predictable way\nto execute most commands, but prevents the use of globbing and shell\nbuilt-ins (including control logic like \"for\" and \"if\" statements)."
      },
      "confines"=>{
        "feature"=>"posix"
      },
      "features"=>[
        "umask"
      ],
      "defaults"=>[
        [
          [
            "feature",
            "posix"
          ]
        ]
      ]
    },
    {
      "name"=>"posix",
      "type_name"=>"file",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/file/posix.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Uses POSIX functionality to manage file ownership and permissions."
      },
      "confines"=>{
        "feature"=>"posix"
      },
      "features"=>[
        "manages_symlinks"
      ]
    },
    {
      "name"=>"puppet_gem",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/puppet_gem.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Puppet Ruby Gem support. This provider is useful for managing\ngems needed by the ruby provided in the puppet-agent package."
      },
      "features"=>[
        "versionable",
        "install_options",
        "uninstall_options"
      ]
    },
    {
      "name"=>"puppetserver_gem",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/puppetserver_gem.rb",
      "line"=>8,
      "docstring"=>{
        "text"=>"Puppet Server Ruby Gem support. If a URL is passed via `source`, then\nthat URL is appended to the list of remote gem repositories which by default\ncontains rubygems.org; To ensure that only the specified source is used also\npass `--clear-sources` in via `install_options`; if a source is present but\nis not a valid URL, it will be interpreted as the path to a local gem file.\nIf source is not present at all, the gem will be installed from the default\ngem repositories."
      },
      "confines"=>{
        "feature"=>"hocon",
        "fips_enabled"=>"false"
      },
      "features"=>[
        "versionable",
        "install_options",
        "uninstall_options"
      ]
    },
    {
      "name"=>"pw",
      "type_name"=>"user",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/pw.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"User management via `pw` on FreeBSD and DragonFly BSD."
      },
      "confines"=>{
        "operatingsystem"=>"[:freebsd, :dragonfly]"
      },
      "features"=>[
        "manages_homedir",
        "allows_duplicates",
        "manages_passwords",
        "manages_expiry",
        "manages_shell"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "[:freebsd, :dragonfly]"
          ]
        ]
      ],
      "commands"=>{
        "pw"=>"pw"
      }
    },
    {
      "name"=>"pw",
      "type_name"=>"group",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/group/pw.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Group management via `pw` on FreeBSD and DragonFly BSD."
      },
      "confines"=>{
        "operatingsystem"=>"[:freebsd, :dragonfly]"
      },
      "features"=>[
        "manages_members"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "[:freebsd, :dragonfly]"
          ]
        ]
      ],
      "commands"=>{
        "pw"=>"pw"
      }
    },
    {
      "name"=>"rcng",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/rcng.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"RCng service management with rc.d"
      },
      "confines"=>{
        "operatingsystem"=>"[:netbsd, :cargos]"
      },
      "defaults"=>[
        [
          [
            "operatingsystem",
            "[:netbsd, :cargos]"
          ]
        ]
      ]
    },
    {
      "name"=>"redhat",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/redhat.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Red Hat's (and probably many others') form of `init`-style service\nmanagement. Uses `chkconfig` for service enabling and disabling."
      },
      "defaults"=>[
        [
          [
            "osfamily",
            "redhat"
          ]
        ],
        [
          [
            "osfamily",
            "suse"
          ],
          [
            "operatingsystemmajrelease",
            "[\"10\", \"11\"]"
          ]
        ]
      ],
      "commands"=>{
        "chkconfig"=>"/sbin/chkconfig",
        "service"=>"/sbin/service"
      }
    },
    {
      "name"=>"rpm",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/rpm.rb",
      "line"=>5,
      "docstring"=>{
        "text"=>"RPM packaging support; should work anywhere with a working `rpm`\nbinary.\n\nThis provider supports the `install_options` and `uninstall_options`\nattributes, which allow command-line flags to be passed to rpm.\nThese options should be specified as an array where each element is either a string or a hash."
      },
      "features"=>[
        "versionable",
        "install_options",
        "uninstall_options",
        "virtual_packages",
        "install_only"
      ],
      "commands"=>{
        "rpm"=>"rpm"
      }
    },
    {
      "name"=>"rug",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/rug.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Support for suse `rug` package manager."
      },
      "confines"=>{
        "operatingsystem"=>"[:suse, :sles]"
      },
      "features"=>[
        "versionable"
      ],
      "commands"=>{
        "rug"=>"/usr/bin/rug",
        "rpm"=>"rpm"
      }
    },
    {
      "name"=>"runit",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/runit.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Runit service management.\n\nThis provider manages daemons running supervised by Runit.\nWhen detecting the service directory it will check, in order of preference:\n\n* `/service`\n* `/etc/service`\n* `/var/service`\n\nThe daemon directory should be in one of the following locations:\n\n* `/etc/sv`\n* `/var/lib/service`\n\nor this can be overridden in the service resource parameters:\n\n    service { 'myservice':\n      provider => 'runit',\n      path     => '/path/to/daemons',\n    }\n\nThis provider supports out of the box:\n\n* start/stop\n* enable/disable\n* restart\n* status"
      },
      "commands"=>{
        "sv"=>"/usr/bin/sv"
      }
    },
    {
      "name"=>"service",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/service.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"The simplest form of service support."
      }
    },
    {
      "name"=>"shell",
      "type_name"=>"exec",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/exec/shell.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Passes the provided command through `/bin/sh`; only available on\nPOSIX systems. This allows the use of shell globbing and built-ins, and\ndoes not require that the path to a command be fully-qualified. Although\nthis can be more convenient than the `posix` provider, it also means that\nyou need to be more careful with escaping; as ever, with great power comes\netc. etc.\n\nThis provider closely resembles the behavior of the `exec` type\nin Puppet 0.25.x."
      },
      "confines"=>{
        "feature"=>"posix"
      }
    },
    {
      "name"=>"smf",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/smf.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Support for Sun's new Service Management Framework.\n\nWhen managing the enable property, this provider will try to preserve\nthe previous ensure state per the enableable semantics. On Solaris,\nenabling a service starts it up while disabling a service stops it. Thus,\nthere's a chance for this provider to execute two operations when managing\nthe enable property. For example, if enable is set to true and the ensure\nstate is stopped, this provider will manage the service using two operations:\none to enable the service which will start it up, and another to stop the\nservice (without affecting its enabled status).\n\nBy specifying `manifest => \"/path/to/service.xml\"`, the SMF manifest will\nbe imported if it does not exist."
      },
      "confines"=>{
        "osfamily"=>"solaris"
      },
      "features"=>[
        "refreshable"
      ],
      "defaults"=>[
        [
          [
            "osfamily",
            "solaris"
          ]
        ]
      ],
      "commands"=>{
        "adm"=>"/usr/sbin/svcadm",
        "svcs"=>"/usr/bin/svcs",
        "svccfg"=>"/usr/sbin/svccfg"
      }
    },
    {
      "name"=>"src",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/src.rb",
      "line"=>4,
      "docstring"=>{
        "text"=>"Support for AIX's System Resource controller.\n\nServices are started/stopped based on the `stopsrc` and `startsrc`\ncommands, and some services can be refreshed with `refresh` command.\n\nEnabling and disabling services is not supported, as it requires\nmodifications to `/etc/inittab`. Starting and stopping groups of subsystems\nis not yet supported."
      },
      "confines"=>{
        "operatingsystem"=>"aix"
      },
      "features"=>[
        "refreshable"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "aix"
          ]
        ]
      ]
    },
    {
      "name"=>"sun",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/sun.rb",
      "line"=>5,
      "docstring"=>{
        "text"=>"Sun's packaging system.  Requires that you specify the source for\nthe packages you're managing.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to pkgadd.\nThese options should be specified as an array where each element is either a string\n or a hash."
      },
      "confines"=>{
        "osfamily"=>"solaris"
      },
      "features"=>[
        "install_options"
      ],
      "defaults"=>[
        [
          [
            "osfamily",
            "solaris"
          ]
        ]
      ],
      "commands"=>{
        "pkginfo"=>"/usr/bin/pkginfo",
        "pkgadd"=>"/usr/sbin/pkgadd",
        "pkgrm"=>"/usr/sbin/pkgrm"
      }
    },
    {
      "name"=>"sunfreeware",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/sunfreeware.rb",
      "line"=>2,
      "docstring"=>{
        "text"=>"Package management using sunfreeware.com's `pkg-get` command on Solaris.\nAt this point, support is exactly the same as `blastwave` support and\nhas not actually been tested."
      },
      "confines"=>{
        "osfamily"=>"solaris"
      },
      "commands"=>{
        "pkgget"=>"pkg-get"
      }
    },
    {
      "name"=>"systemd",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/systemd.rb",
      "line"=>5,
      "docstring"=>{
        "text"=>"Manages `systemd` services using `systemctl`.\n\nBecause `systemd` defaults to assuming the `.service` unit type, the suffix\nmay be omitted.  Other unit types (such as `.path`) may be managed by\nproviding the proper suffix."
      },
      "confines"=>{
        "true"=>"Puppet::FileSystem.exist?('/proc/1/comm') && Puppet::FileSystem.read('/proc/1/comm').include?('systemd')"
      },
      "defaults"=>[
        [
          [
            "osfamily",
            "[:archlinux]"
          ]
        ],
        [
          [
            "osfamily",
            "redhat"
          ],
          [
            "operatingsystemmajrelease",
            "[\"7\", \"8\"]"
          ]
        ],
        [
          [
            "osfamily",
            "redhat"
          ],
          [
            "operatingsystem",
            "fedora"
          ]
        ],
        [
          [
            "osfamily",
            "suse"
          ]
        ],
        [
          [
            "osfamily",
            "coreos"
          ]
        ],
        [
          [
            "operatingsystem",
            "amazon"
          ],
          [
            "operatingsystemmajrelease",
            "[\"2\"]"
          ]
        ],
        [
          [
            "operatingsystem",
            "debian"
          ]
        ],
        [
          [
            "operatingsystem",
            "LinuxMint"
          ]
        ],
        [
          [
            "operatingsystem",
            "ubuntu"
          ]
        ],
        [
          [
            "operatingsystem",
            "cumuluslinux"
          ],
          [
            "operatingsystemmajrelease",
            "[\"3\", \"4\"]"
          ]
        ]
      ],
      "commands"=>{
        "systemctl"=>"systemctl"
      }
    },
    {
      "name"=>"tdnf",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/tdnf.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Support via `tdnf`.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to tdnf.\nThese options should be spcified as a string (e.g. '--flag'), a hash (e.g. {'--flag' => 'value'}), or an\narray where each element is either a string or a hash."
      },
      "features"=>[
        "install_options",
        "versionable",
        "virtual_packages"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "PhotonOS"
          ]
        ]
      ],
      "commands"=>{
        "cmd"=>"tdnf",
        "rpm"=>"rpm"
      }
    },
    {
      "name"=>"up2date",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/up2date.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Support for Red Hat's proprietary `up2date` package update\nmechanism."
      },
      "confines"=>{
        "osfamily"=>"redhat"
      },
      "defaults"=>[
        [
          [
            "osfamily",
            "redhat"
          ],
          [
            "lsbdistrelease",
            "[\"2.1\", \"3\", \"4\"]"
          ]
        ]
      ],
      "commands"=>{
        "up2date"=>"/usr/sbin/up2date-nox"
      }
    },
    {
      "name"=>"upstart",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/upstart.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Ubuntu service management with `upstart`.\n\nThis provider manages `upstart` jobs on Ubuntu. For `upstart` documentation,\nsee <http://upstart.ubuntu.com/>."
      },
      "confines"=>{
        "any"=>"[\n    Facter.value(:operatingsystem) == 'Ubuntu',\n    (Facter.value(:osfamily) == 'RedHat' and Facter.value(:operatingsystemrelease) =~ /^6\\./),\n    (Facter.value(:operatingsystem) == 'Amazon' and Facter.value(:operatingsystemmajrelease) =~ /\\d{4}/),\n    Facter.value(:operatingsystem) == 'LinuxMint',\n  ]",
        "true"=>"lambda { has_initctl? }"
      },
      "features"=>[
        "enableable"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "ubuntu"
          ],
          [
            "operatingsystemmajrelease",
            "[\"10.04\", \"12.04\", \"14.04\", \"14.10\"]"
          ]
        ],
        [
          [
            "operatingsystem",
            "LinuxMint"
          ],
          [
            "operatingsystemmajrelease",
            "[\"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\"]"
          ]
        ]
      ],
      "commands"=>{
        "start"=>"/sbin/start",
        "stop"=>"/sbin/stop",
        "restart"=>"/sbin/restart",
        "status_exec"=>"/sbin/status",
        "initctl"=>"/sbin/initctl"
      }
    },
    {
      "name"=>"urpmi",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/urpmi.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Support via `urpmi`."
      },
      "features"=>[
        "versionable"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "[:mandriva, :mandrake]"
          ]
        ]
      ],
      "commands"=>{
        "urpmi"=>"urpmi",
        "urpmq"=>"urpmq",
        "rpm"=>"rpm",
        "urpme"=>"urpme"
      }
    },
    {
      "name"=>"user_role_add",
      "type_name"=>"user",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/user_role_add.rb",
      "line"=>5,
      "docstring"=>{
        "text"=>"User and role management on Solaris, via `useradd` and `roleadd`."
      },
      "features"=>[
        "manages_homedir",
        "allows_duplicates",
        "manages_solaris_rbac",
        "manages_roles",
        "manages_passwords",
        "manages_password_age",
        "manages_shell"
      ],
      "defaults"=>[
        [
          [
            "osfamily",
            "solaris"
          ]
        ]
      ],
      "commands"=>{
        "add"=>"useradd",
        "delete"=>"userdel",
        "modify"=>"usermod",
        "password"=>"passwd",
        "role_add"=>"roleadd",
        "role_delete"=>"roledel",
        "role_modify"=>"rolemod"
      }
    },
    {
      "name"=>"useradd",
      "type_name"=>"user",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/useradd.rb",
      "line"=>7,
      "docstring"=>{
        "text"=>"User management via `useradd` and its ilk.  Note that you will need to\ninstall Ruby's shadow password library (often known as `ruby-libshadow`)\nif you wish to manage user passwords."
      },
      "features"=>[
        "manages_homedir",
        "allows_duplicates",
        "manages_expiry",
        "manages_shell"
      ],
      "commands"=>{
        "add"=>"useradd",
        "delete"=>"userdel",
        "modify"=>"usermod",
        "password"=>"chage"
      }
    },
    {
      "name"=>"windows",
      "type_name"=>"file",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/file/windows.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Uses Microsoft Windows functionality to manage file ownership and permissions."
      },
      "confines"=>{
        "operatingsystem"=>"windows"
      }
    },
    {
      "name"=>"windows",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/windows.rb",
      "line"=>5,
      "docstring"=>{
        "text"=>"Windows package management.\n\nThis provider supports either MSI or self-extracting executable installers.\n\nThis provider requires a `source` attribute when installing the package.\nIt accepts paths to local files, mapped drives, or UNC paths.\n\nThis provider supports the `install_options` and `uninstall_options`\nattributes, which allow command-line flags to be passed to the installer.\nThese options should be specified as an array where each element is either\na string or a hash.\n\nIf the executable requires special arguments to perform a silent install or\nuninstall, then the appropriate arguments should be specified using the\n`install_options` or `uninstall_options` attributes, respectively.  Puppet\nwill automatically quote any option that contains spaces."
      },
      "confines"=>{
        "operatingsystem"=>"windows"
      },
      "features"=>[
        "installable",
        "uninstallable",
        "install_options",
        "uninstall_options",
        "versionable"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "windows"
          ]
        ]
      ]
    },
    {
      "name"=>"windows",
      "type_name"=>"service",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/service/windows.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Support for Windows Service Control Manager (SCM). This provider can\nstart, stop, enable, and disable services, and the SCM provides working\nstatus methods for all services.\n\nControl of service groups (dependencies) is not yet supported, nor is running\nservices as a specific user."
      },
      "confines"=>{
        "operatingsystem"=>"windows"
      },
      "features"=>[
        "refreshable",
        "configurable_timeout",
        "manages_logon_credentials"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "windows"
          ]
        ]
      ]
    },
    {
      "name"=>"windows",
      "type_name"=>"exec",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/exec/windows.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Execute external binaries on Windows systems. As with the `posix`\nprovider, this provider directly calls the command with the arguments\ngiven, without passing it through a shell or performing any interpolation.\nTo use shell built-ins --- that is, to emulate the `shell` provider on\nWindows --- a command must explicitly invoke the shell:\n\n    exec {'echo foo':\n      command => 'cmd.exe /c echo \"foo\"',\n    }\n\nIf no extension is specified for a command, Windows will use the `PATHEXT`\nenvironment variable to locate the executable.\n\n**Note on PowerShell scripts:** PowerShell's default `restricted`\nexecution policy doesn't allow it to run saved scripts. To run PowerShell\nscripts, specify the `remotesigned` execution policy as part of the\ncommand:\n\n    exec { 'test':\n      path    => 'C:/Windows/System32/WindowsPowerShell/v1.0',\n      command => 'powershell -executionpolicy remotesigned -file C:/test.ps1',\n    }"
      },
      "confines"=>{
        "operatingsystem"=>"windows"
      },
      "defaults"=>[
        [
          [
            "operatingsystem",
            "windows"
          ]
        ]
      ]
    },
    {
      "name"=>"windows_adsi",
      "type_name"=>"group",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/group/windows_adsi.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Local group management for Windows. Group members can be both users and groups.\nAdditionally, local groups can contain domain users."
      },
      "confines"=>{
        "operatingsystem"=>"windows"
      },
      "features"=>[
        "manages_members"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "windows"
          ]
        ]
      ]
    },
    {
      "name"=>"windows_adsi",
      "type_name"=>"user",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/user/windows_adsi.rb",
      "line"=>3,
      "docstring"=>{
        "text"=>"Local user management for Windows."
      },
      "confines"=>{
        "operatingsystem"=>"windows"
      },
      "features"=>[
        "manages_homedir",
        "manages_passwords",
        "manages_roles"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "windows"
          ]
        ]
      ]
    },
    {
      "name"=>"yum",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/yum.rb",
      "line"=>5,
      "docstring"=>{
        "text"=>"Support via `yum`.\n\nUsing this provider's `uninstallable` feature will not remove dependent packages. To\nremove dependent packages with this provider use the `purgeable` feature, but note this\nfeature is destructive and should be used with the utmost care.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to yum.\nThese options should be specified as an array where each element is either a string or a hash."
      },
      "features"=>[
        "install_options",
        "versionable",
        "virtual_packages",
        "install_only"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "amazon"
          ]
        ],
        [
          [
            "osfamily",
            "redhat"
          ],
          [
            "operatingsystemmajrelease",
            "(4..7).to_a"
          ]
        ]
      ],
      "commands"=>{
        "cmd"=>"yum",
        "rpm"=>"rpm"
      }
    },
    {
      "name"=>"zypper",
      "type_name"=>"package",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/provider/package/zypper.rb",
      "line"=>1,
      "docstring"=>{
        "text"=>"Support for SuSE `zypper` package manager. Found in SLES10sp2+ and SLES11.\n\nThis provider supports the `install_options` attribute, which allows command-line flags to be passed to zypper.\nThese options should be specified as an array where each element is either a\nstring or a hash."
      },
      "confines"=>{
        "operatingsystem"=>"[:suse, :sles, :sled, :opensuse]"
      },
      "features"=>[
        "versionable",
        "install_options",
        "virtual_packages"
      ],
      "defaults"=>[
        [
          [
            "operatingsystem",
            "[:suse, :sles, :sled, :opensuse]"
          ]
        ]
      ],
      "commands"=>{
        "zypper"=>"/usr/bin/zypper"
      }
    }
  ],
  "puppet_functions"=>[
    {
      "name"=>"abs",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/abs.rb",
      "line"=>33,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"abs(Numeric $val)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"val"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"abs(String $val)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"val"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns the absolute value of a Numeric value, for example -34.56 becomes\n34.56. Takes a single `Integer` or `Float` value as an argument.\n\n*Deprecated behavior*\n\nFor backwards compatibility reasons this function also works when given a\nnumber in `String` format such that it first attempts to covert it to either a `Float` or\nan `Integer` and then taking the absolute value of the result. Only strings representing\na number in decimal format is supported - an error is raised if\nvalue is not decimal (using base 10). Leading 0 chars in the string\nare ignored. A floating point value in string form can use some forms of\nscientific notation but not all.\n\nCallers should convert strings to `Numeric` before calling\nthis function to have full control over the conversion.\n\n```puppet\nabs(Numeric($str_val))\n```\n\nIt is worth noting that `Numeric` can convert to absolute value\ndirectly as in the following examples:\n\n```puppet\nNumeric($strval, true)     # Converts to absolute Integer or Float\nInteger($strval, 10, true) # Converts to absolute Integer using base 10 (decimal)\nInteger($strval, 16, true) # Converts to absolute Integer using base 16 (hex)\nFloat($strval, true)       # Converts to absolute Float\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Converting to Numeric before calling"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Absolute value and String to Numeric"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"abs(Numeric $val)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"val"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"abs"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"abs(String $val)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"val"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"abs"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:abs) do\n  dispatch :on_numeric do\n    param 'Numeric', :val\n  end\n\n  dispatch :on_string do\n    param 'String', :val\n  end\n\n  def on_numeric(x)\n    x.abs\n  end\n\n  def on_string(x)\n    Puppet.warn_once('deprecations', 'abs_function_numeric_coerce_string',\n      _(\"The abs() function's auto conversion of String to Numeric is deprecated - change to convert input before calling\"))\n\n    # These patterns for conversion are backwards compatible with the stdlib\n    # version of this function.\n    #\n    if x =~ %r{^-?(?:\\d+)(?:\\.\\d+){1}$}\n      x.to_f.abs\n    elsif x =~ %r{^-?\\d+$}\n      x.to_i.abs\n    else\n      raise(ArgumentError, 'abs(): Requires float or integer to work with - was given non decimal string')\n    end\n  end\nend"
    },
    {
      "name"=>"alert",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/alert.rb",
      "line"=>2,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"alert(Any *$values)",
          "docstring"=>{
            "text"=>"Logs a message on the server at level `alert`.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"The values to log.",
                "types"=>[
                  "Any"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Undef"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Logs a message on the server at level `alert`.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"The values to log.",
            "types"=>[
              "Any"
            ],
            "name"=>"*values"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Undef"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:alert, Puppet::Functions::InternalFunction) do\n  # @param values The values to log.\n  # @return [Undef]\n  dispatch :alert do\n    scope_param\n    repeated_param 'Any', :values\n    return_type 'Undef'\n  end\n\n  def alert(scope, *values)\n    Puppet::Util::Log.log_func(scope, :alert, values)\n  end\nend"
    },
    {
      "name"=>"all",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/all.rb",
      "line"=>62,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"all(Hash[Any, Any] $hash, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Any, Any]"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"all(Hash[Any, Any] $hash, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Any, Any]"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"all(Iterable $enumerable, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"all(Iterable $enumerable, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Runs a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nrepeatedly using each value in a data structure until the lambda returns a non \"truthy\" value which\nmakes the function return `false`, or if the end of the iteration is reached, `true` is returned.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array, hash, or other iterable object that the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n`$data.all |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`all($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\n```puppet\n# For the array $data, run a lambda that checks that all values are multiples of 10\n$data = [10, 20, 30]\nnotice $data.all |$item| { $item % 10 == 0 }\n```\n\nWould notice `true`.\n\nWhen the first argument is a `Hash`, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]`.\n\n```puppet\n# For the hash $data, run a lambda using each item as a key-value array\n$data = { 'a_0'=> 10, 'b_1' => 20 }\nnotice $data.all |$item| { $item[1] % 10 == 0  }\n```\n\nWould notice `true` if all values in the hash are multiples of 10.\n\nWhen the lambda accepts two arguments, the first argument gets the index in an array\nor the key from a hash, and the second argument the value.\n\n\n```puppet\n# Check that all values are a multiple of 10 and keys start with 'abc'\n$data = {abc_123 => 10, abc_42 => 20, abc_blue => 30}\nnotice $data.all |$key, $value| { $value % 10 == 0  and $key =~ /^abc/ }\n```\n\nWould notice true.\n\nFor an general examples that demonstrates iteration, see the Puppet\n[iteration](https://puppet.com/docs/puppet/latest/lang_iteration.html)\ndocumentation.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `all` function"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `all` function with an Array and a one-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `all` function with a `Hash` and a one-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `all` function with a hash and a two-parameter lambda"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"all(Hash[Any, Any] $hash, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Any, Any]"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"all"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"all(Hash[Any, Any] $hash, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Any, Any]"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"all"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"all(Iterable $enumerable, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"all"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"all(Iterable $enumerable, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"all"
          },
          {
            "tag_name"=>"since",
            "text"=>"5.2.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:all) do\n  dispatch :all_Hash_2 do\n    param 'Hash[Any, Any]', :hash\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :all_Hash_1 do\n    param 'Hash[Any, Any]', :hash\n    block_param 'Callable[1,1]', :block\n  end\n\n  dispatch :all_Enumerable_2 do\n    param 'Iterable', :enumerable\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :all_Enumerable_1 do\n    param 'Iterable', :enumerable\n    block_param 'Callable[1,1]', :block\n  end\n\n  def all_Hash_1(hash)\n    hash.each_pair.all? { |x| yield(x) }\n  end\n\n  def all_Hash_2(hash)\n    hash.each_pair.all? { |x,y| yield(x,y) }\n  end\n\n  def all_Enumerable_1(enumerable)\n    Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable).all? { |e| yield(e) }\n  end\n\n  def all_Enumerable_2(enumerable)\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n    if enum.hash_style?\n      enum.all? { |entry| yield(*entry) }\n    else\n      enum.each_with_index { |e, i| return false unless yield(i, e) }\n      true\n    end\n  end\nend"
    },
    {
      "name"=>"annotate",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/annotate.rb",
      "line"=>66,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"annotate(Type[Annotation] $type, Any $value, Optional[Callable[0, 0]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Type[Annotation]"
                ],
                "name"=>"type"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[0, 0]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"annotate(Type[Annotation] $type, Any $value, Variant[Enum[clear],Hash[Pcore::MemberName,Any]] $annotation_hash)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Type[Annotation]"
                ],
                "name"=>"type"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Variant[Enum[clear],Hash[Pcore::MemberName,Any]]"
                ],
                "name"=>"annotation_hash"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"annotate(Type[Pcore] $type, Any $value, Hash[Type[Annotation], Hash[Pcore::MemberName,Any]] $annotations)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Type[Pcore]"
                ],
                "name"=>"type"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Type[Annotation], Hash[Pcore::MemberName,Any]]"
                ],
                "name"=>"annotations"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Handles annotations on objects. The function can be used in four different ways.\n\nWith two arguments, an `Annotation` type and an object, the function returns the annotation\nfor the object of the given type, or `undef` if no such annotation exists.\n\n```puppet\n$annotation = Mod::NickNameAdapter.annotate(o)\n\n$annotation = annotate(Mod::NickNameAdapter.annotate, o)\n```\n\nWith three arguments, an `Annotation` type, an object, and a block, the function returns the\nannotation for the object of the given type, or annotates it with a new annotation initialized\nfrom the hash returned by the given block when no such annotation exists. The block will not\nbe called when an annotation of the given type is already present.\n\n```puppet\n$annotation = Mod::NickNameAdapter.annotate(o) || { { 'nick_name' => 'Buddy' } }\n\n$annotation = annotate(Mod::NickNameAdapter.annotate, o) || { { 'nick_name' => 'Buddy' } }\n```\n\nWith three arguments, an `Annotation` type, an object, and an `Hash`, the function will annotate\nthe given object with a new annotation of the given type that is initialized from the given hash.\nAn existing annotation of the given type is discarded.\n\n```puppet\n$annotation = Mod::NickNameAdapter.annotate(o, { 'nick_name' => 'Buddy' })\n\n$annotation = annotate(Mod::NickNameAdapter.annotate, o, { 'nick_name' => 'Buddy' })\n```\n\nWith three arguments, an `Annotation` type, an object, and an the string `clear`, the function will\nclear the annotation of the given type in the given object. The old annotation is returned if\nit existed.\n\n```puppet\n$annotation = Mod::NickNameAdapter.annotate(o, clear)\n\n$annotation = annotate(Mod::NickNameAdapter.annotate, o, clear)\n```\n\nWith three arguments, the type `Pcore`, an object, and a Hash of hashes keyed by `Annotation` types,\nthe function will annotate the given object with all types used as keys in the given hash. Each annotation\nis initialized with the nested hash for the respective type. The annotated object is returned.\n\n```puppet\n  $person = Pcore.annotate(Mod::Person({'name' => 'William'}), {\n    Mod::NickNameAdapter >= { 'nick_name' => 'Bill' },\n    Mod::HobbiesAdapter => { 'hobbies' => ['Ham Radio', 'Philatelist'] }\n  })\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `annotate` with two arguments"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `annotate` with two arguments and a block"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `annotate` with three arguments where third argument is a Hash"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `annotate` with three arguments where third argument is the string 'clear'"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Add multiple annotations to a new instance of `Mod::Person` using the `Pcore` type."
          },
          {
            "tag_name"=>"overload",
            "signature"=>"annotate(Type[Annotation] $type, Any $value, Optional[Callable[0, 0]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Type[Annotation]"
                  ],
                  "name"=>"type"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"value"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[0, 0]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"annotate"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"annotate(Type[Annotation] $type, Any $value, Variant[Enum[clear],Hash[Pcore::MemberName,Any]] $annotation_hash)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Type[Annotation]"
                  ],
                  "name"=>"type"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"value"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Variant[Enum[clear],Hash[Pcore::MemberName,Any]]"
                  ],
                  "name"=>"annotation_hash"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"annotate"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"annotate(Type[Pcore] $type, Any $value, Hash[Type[Annotation], Hash[Pcore::MemberName,Any]] $annotations)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Type[Pcore]"
                  ],
                  "name"=>"type"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"value"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Type[Annotation], Hash[Pcore::MemberName,Any]]"
                  ],
                  "name"=>"annotations"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"annotate"
          },
          {
            "tag_name"=>"since",
            "text"=>"5.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:annotate) do\n  dispatch :annotate do\n    param 'Type[Annotation]', :type\n    param 'Any', :value\n    optional_block_param 'Callable[0, 0]', :block\n  end\n\n  dispatch :annotate_new do\n    param 'Type[Annotation]', :type\n    param 'Any', :value\n    param 'Variant[Enum[clear],Hash[Pcore::MemberName,Any]]', :annotation_hash\n  end\n\n  dispatch :annotate_multi do\n    param 'Type[Pcore]', :type\n    param 'Any', :value\n    param 'Hash[Type[Annotation], Hash[Pcore::MemberName,Any]]', :annotations\n  end\n\n  # @param type [Annotation] the annotation type\n  # @param value [Object] the value to annotate\n  # @param block [Proc] optional block to produce the annotation hash\n  #\n  def annotate(type, value, &block)\n    type.implementation_class.annotate(value, &block)\n  end\n\n  # @param type [Annotation] the annotation type\n  # @param value [Object] the value to annotate\n  # @param annotation_hash [Hash{String => Object}] the annotation hash\n  #\n  def annotate_new(type, value, annotation_hash)\n    type.implementation_class.annotate_new(value, annotation_hash)\n  end\n\n  # @param type [Type] the Pcore type\n  # @param value [Object] the value to annotate\n  # @param annotations [Hash{Annotation => Hash{String => Object}}] hash of annotation hashes\n  #\n  def annotate_multi(type, value, annotations)\n    type.implementation_class.annotate(value, annotations)\n  end\nend"
    },
    {
      "name"=>"any",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/any.rb",
      "line"=>67,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"any(Hash[Any, Any] $hash, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Any, Any]"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"any(Hash[Any, Any] $hash, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Any, Any]"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"any(Iterable $enumerable, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"any(Iterable $enumerable, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Runs a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nrepeatedly using each value in a data structure until the lambda returns a \"truthy\" value which\nmakes the function return `true`, or if the end of the iteration is reached, false is returned.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array, hash, or other iterable object that the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n`$data.any |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`any($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\n```puppet\n# For the array $data, run a lambda that checks if an unknown hash contains those keys\n$data = [\"routers\", \"servers\", \"workstations\"]\n$looked_up = lookup('somekey', Hash)\nnotice $data.any |$item| { $looked_up[$item] }\n```\n\nWould notice `true` if the looked up hash had a value that is neither `false` nor `undef` for at least\none of the keys. That is, it is equivalent to the expression\n`$looked_up[routers] || $looked_up[servers] || $looked_up[workstations]`.\n\nWhen the first argument is a `Hash`, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]`.\n\n```puppet\n# For the hash $data, run a lambda using each item as a key-value array.\n$data = {\"rtr\" => \"Router\", \"svr\" => \"Server\", \"wks\" => \"Workstation\"}\n$looked_up = lookup('somekey', Hash)\nnotice $data.any |$item| { $looked_up[$item[0]] }\n```\n\nWould notice `true` if the looked up hash had a value for one of the wanted key that is\nneither `false` nor `undef`.\n\nWhen the lambda accepts two arguments, the first argument gets the index in an array\nor the key from a hash, and the second argument the value.\n\n\n```puppet\n# Check if there is an even numbered index that has a non String value\n$data = [key1, 1, 2, 2]\nnotice $data.any |$index, $value| { $index % 2 == 0 and $value !~ String }\n```\n\nWould notice true as the index `2` is even and not a `String`\n\nFor an general examples that demonstrates iteration, see the Puppet\n[iteration](https://puppet.com/docs/puppet/latest/lang_iteration.html)\ndocumentation.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `any` function"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `any` function with an Array and a one-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `any` function with a `Hash` and a one-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `any` function with an array and a two-parameter lambda"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"any(Hash[Any, Any] $hash, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Any, Any]"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"any"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"any(Hash[Any, Any] $hash, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Any, Any]"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"any"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"any(Iterable $enumerable, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"any"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"any(Iterable $enumerable, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"any"
          },
          {
            "tag_name"=>"since",
            "text"=>"5.2.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:any) do\n  dispatch :any_Hash_2 do\n    param 'Hash[Any, Any]', :hash\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :any_Hash_1 do\n    param 'Hash[Any, Any]', :hash\n    block_param 'Callable[1,1]', :block\n  end\n\n  dispatch :any_Enumerable_2 do\n    param 'Iterable', :enumerable\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :any_Enumerable_1 do\n    param 'Iterable', :enumerable\n    block_param 'Callable[1,1]', :block\n  end\n\n  def any_Hash_1(hash)\n    hash.each_pair.any? { |x| yield(x) }\n  end\n\n  def any_Hash_2(hash)\n    hash.each_pair.any? { |x,y| yield(x, y) }\n  end\n\n  def any_Enumerable_1(enumerable)\n    Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable).any? { |e| yield(e) }\n  end\n\n  def any_Enumerable_2(enumerable)\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n    if enum.hash_style?\n      enum.any? { |entry| yield(*entry) }\n    else\n      enum.each_with_index { |e, i| return true if yield(i, e) }\n      false\n    end\n  end\nend"
    },
    {
      "name"=>"assert_type",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/assert_type.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"assert_type()",
          "docstring"=>{
            "text"=>"Returns the given value if it is of the given\n[data type](https://puppet.com/docs/puppet/latest/lang_data.html), or\notherwise either raises an error or executes an optional two-parameter\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html).\n\nThe function takes two mandatory arguments, in this order:\n\n1. The expected data type.\n2. A value to compare against the expected data type.\n\n**Example**: Using `assert_type`\n\n~~~ puppet\n$raw_username = 'Amy Berry'\n\n# Assert that $raw_username is a non-empty string and assign it to $valid_username.\n$valid_username = assert_type(String[1], $raw_username)\n\n# $valid_username contains \"Amy Berry\".\n# If $raw_username was an empty string or a different data type, the Puppet run would\n# fail with an \"Expected type does not match actual\" error.\n~~~\n\nYou can use an optional lambda to provide enhanced feedback. The lambda takes two\nmandatory parameters, in this order:\n\n1. The expected data type as described in the function's first argument.\n2. The actual data type of the value.\n\n**Example**: Using `assert_type` with a warning and default value\n\n~~~ puppet\n$raw_username = 'Amy Berry'\n\n# Assert that $raw_username is a non-empty string and assign it to $valid_username.\n# If it isn't, output a warning describing the problem and use a default value.\n$valid_username = assert_type(String[1], $raw_username) |$expected, $actual| {\n  warning( \"The username should be \\'${expected}\\', not \\'${actual}\\'. Using 'anonymous'.\" )\n  'anonymous'\n}\n\n# $valid_username contains \"Amy Berry\".\n# If $raw_username was an empty string, the Puppet run would set $valid_username to\n# \"anonymous\" and output a warning: \"The username should be 'String[1, default]', not\n# 'String[0, 0]'. Using 'anonymous'.\"\n~~~\n\nFor more information about data types, see the\n[documentation](https://puppet.com/docs/puppet/latest/lang_data.html).\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns the given value if it is of the given\n[data type](https://puppet.com/docs/puppet/latest/lang_data.html), or\notherwise either raises an error or executes an optional two-parameter\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html).\n\nThe function takes two mandatory arguments, in this order:\n\n1. The expected data type.\n2. A value to compare against the expected data type.\n\n**Example**: Using `assert_type`\n\n~~~ puppet\n$raw_username = 'Amy Berry'\n\n# Assert that $raw_username is a non-empty string and assign it to $valid_username.\n$valid_username = assert_type(String[1], $raw_username)\n\n# $valid_username contains \"Amy Berry\".\n# If $raw_username was an empty string or a different data type, the Puppet run would\n# fail with an \"Expected type does not match actual\" error.\n~~~\n\nYou can use an optional lambda to provide enhanced feedback. The lambda takes two\nmandatory parameters, in this order:\n\n1. The expected data type as described in the function's first argument.\n2. The actual data type of the value.\n\n**Example**: Using `assert_type` with a warning and default value\n\n~~~ puppet\n$raw_username = 'Amy Berry'\n\n# Assert that $raw_username is a non-empty string and assign it to $valid_username.\n# If it isn't, output a warning describing the problem and use a default value.\n$valid_username = assert_type(String[1], $raw_username) |$expected, $actual| {\n  warning( \"The username should be \\'${expected}\\', not \\'${actual}\\'. Using 'anonymous'.\" )\n  'anonymous'\n}\n\n# $valid_username contains \"Amy Berry\".\n# If $raw_username was an empty string, the Puppet run would set $valid_username to\n# \"anonymous\" and output a warning: \"The username should be 'String[1, default]', not\n# 'String[0, 0]'. Using 'anonymous'.\"\n~~~\n\nFor more information about data types, see the\n[documentation](https://puppet.com/docs/puppet/latest/lang_data.html).\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :assert_type,\n  :type => :rvalue,\n  :arity => -3,\n  :doc => <<DOC\nReturns the given value if it is of the given\n[data type](https://puppet.com/docs/puppet/latest/lang_data.html), or\notherwise either raises an error or executes an optional two-parameter\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html).\n\nThe function takes two mandatory arguments, in this order:\n\n1. The expected data type.\n2. A value to compare against the expected data type.\n\n**Example**: Using `assert_type`\n\n~~~ puppet\n$raw_username = 'Amy Berry'\n\n# Assert that $raw_username is a non-empty string and assign it to $valid_username.\n$valid_username = assert_type(String[1], $raw_username)\n\n# $valid_username contains \"Amy Berry\".\n# If $raw_username was an empty string or a different data type, the Puppet run would\n# fail with an \"Expected type does not match actual\" error.\n~~~\n\nYou can use an optional lambda to provide enhanced feedback. The lambda takes two\nmandatory parameters, in this order:\n\n1. The expected data type as described in the function's first argument.\n2. The actual data type of the value.\n\n**Example**: Using `assert_type` with a warning and default value\n\n~~~ puppet\n$raw_username = 'Amy Berry'\n\n# Assert that $raw_username is a non-empty string and assign it to $valid_username.\n# If it isn't, output a warning describing the problem and use a default value.\n$valid_username = assert_type(String[1], $raw_username) |$expected, $actual| {\n  warning( \"The username should be \\'${expected}\\', not \\'${actual}\\'. Using 'anonymous'.\" )\n  'anonymous'\n}\n\n# $valid_username contains \"Amy Berry\".\n# If $raw_username was an empty string, the Puppet run would set $valid_username to\n# \"anonymous\" and output a warning: \"The username should be 'String[1, default]', not\n# 'String[0, 0]'. Using 'anonymous'.\"\n~~~\n\nFor more information about data types, see the\n[documentation](https://puppet.com/docs/puppet/latest/lang_data.html).\n\n- Since 4.0.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('assert_type')\nend"
    },
    {
      "name"=>"assert_type",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/assert_type.rb",
      "line"=>53,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"assert_type(Type $type, Any $value, Optional[Callable[Type, Type]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Type"
                ],
                "name"=>"type"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[Type, Type]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"assert_type(String $type_string, Any $value, Optional[Callable[Type, Type]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"type_string"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[Type, Type]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns the given value if it is of the given\n[data type](https://puppet.com/docs/puppet/latest/lang_data.html), or\notherwise either raises an error or executes an optional two-parameter\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html).\n\nThe function takes two mandatory arguments, in this order:\n\n1. The expected data type.\n2. A value to compare against the expected data type.\n\n```puppet\n$raw_username = 'Amy Berry'\n\n# Assert that $raw_username is a non-empty string and assign it to $valid_username.\n$valid_username = assert_type(String[1], $raw_username)\n\n# $valid_username contains \"Amy Berry\".\n# If $raw_username was an empty string or a different data type, the Puppet run would\n# fail with an \"Expected type does not match actual\" error.\n```\n\nYou can use an optional lambda to provide enhanced feedback. The lambda takes two\nmandatory parameters, in this order:\n\n1. The expected data type as described in the function's first argument.\n2. The actual data type of the value.\n\n```puppet\n$raw_username = 'Amy Berry'\n\n# Assert that $raw_username is a non-empty string and assign it to $valid_username.\n# If it isn't, output a warning describing the problem and use a default value.\n$valid_username = assert_type(String[1], $raw_username) |$expected, $actual| {\n  warning( \"The username should be \\'${expected}\\', not \\'${actual}\\'. Using 'anonymous'.\" )\n  'anonymous'\n}\n\n# $valid_username contains \"Amy Berry\".\n# If $raw_username was an empty string, the Puppet run would set $valid_username to\n# \"anonymous\" and output a warning: \"The username should be 'String[1, default]', not\n# 'String[0, 0]'. Using 'anonymous'.\"\n```\n\nFor more information about data types, see the\n[documentation](https://puppet.com/docs/puppet/latest/lang_data.html).",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `assert_type`"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `assert_type` with a warning and default value"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"assert_type(Type $type, Any $value, Optional[Callable[Type, Type]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Type"
                  ],
                  "name"=>"type"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"value"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[Type, Type]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"assert_type"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"assert_type(String $type_string, Any $value, Optional[Callable[Type, Type]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"type_string"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"value"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[Type, Type]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"assert_type"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:assert_type) do\n  dispatch :assert_type do\n    param 'Type', :type\n    param 'Any', :value\n    optional_block_param 'Callable[Type, Type]', :block\n  end\n\n  dispatch :assert_type_s do\n    param 'String', :type_string\n    param 'Any', :value\n    optional_block_param 'Callable[Type, Type]', :block\n  end\n\n  # @param type [Type] the type the value must be an instance of\n  # @param value [Object] the value to assert\n  #\n  def assert_type(type, value)\n    unless Puppet::Pops::Types::TypeCalculator.instance?(type,value)\n      inferred_type = Puppet::Pops::Types::TypeCalculator.infer_set(value)\n      if block_given?\n        # Give the inferred type to allow richer comparison in the given block (if generalized\n        # information is lost).\n        #\n        value = yield(type, inferred_type)\n      else\n        raise Puppet::Pops::Types::TypeAssertionError.new(\n          Puppet::Pops::Types::TypeMismatchDescriber.singleton.describe_mismatch('assert_type():', type, inferred_type),\n          type, inferred_type)\n      end\n    end\n    value\n  end\n\n  # @param type_string [String] the type the value must be an instance of given in String form\n  # @param value [Object] the value to assert\n  #\n  def assert_type_s(type_string, value, &proc)\n    t = Puppet::Pops::Types::TypeParser.singleton.parse(type_string)\n    block_given? ? assert_type(t, value, &proc) : assert_type(t, value)\n  end\nend"
    },
    {
      "name"=>"binary_file",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/binary_file.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"binary_file()",
          "docstring"=>{
            "text"=>"Loads a binary file from a module or file system and returns its contents as a Binary.\n\nThe argument to this function should be a `<MODULE NAME>/<FILE>`\nreference, which will load `<FILE>` from a module's `files`\ndirectory. (For example, the reference `mysql/mysqltuner.pl` will load the\nfile `<MODULES DIRECTORY>/mysql/files/mysqltuner.pl`.)\n\nThis function also accepts an absolute file path that allows reading\nbinary file content from anywhere on disk.\n\nAn error is raised if the given file does not exists.\n\nTo search for the existence of files, use the `find_file()` function.\n\n- since 4.8.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Loads a binary file from a module or file system and returns its contents as a Binary.\n\nThe argument to this function should be a `<MODULE NAME>/<FILE>`\nreference, which will load `<FILE>` from a module's `files`\ndirectory. (For example, the reference `mysql/mysqltuner.pl` will load the\nfile `<MODULES DIRECTORY>/mysql/files/mysqltuner.pl`.)\n\nThis function also accepts an absolute file path that allows reading\nbinary file content from anywhere on disk.\n\nAn error is raised if the given file does not exists.\n\nTo search for the existence of files, use the `find_file()` function.\n\n- since 4.8.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :binary_file,\n  :type => :rvalue,\n  :arity => 1,\n:doc => <<-DOC\nLoads a binary file from a module or file system and returns its contents as a Binary.\n\nThe argument to this function should be a `<MODULE NAME>/<FILE>`\nreference, which will load `<FILE>` from a module's `files`\ndirectory. (For example, the reference `mysql/mysqltuner.pl` will load the\nfile `<MODULES DIRECTORY>/mysql/files/mysqltuner.pl`.)\n\nThis function also accepts an absolute file path that allows reading\nbinary file content from anywhere on disk.\n\nAn error is raised if the given file does not exists.\n\nTo search for the existence of files, use the `find_file()` function.\n\n- since 4.8.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('binary_file')\nend"
    },
    {
      "name"=>"binary_file",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/binary_file.rb",
      "line"=>18,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"binary_file(String $path)",
          "docstring"=>{
            "text"=>"Loads a binary file from a module or file system and returns its contents as a `Binary`.\nThe argument to this function should be a `<MODULE NAME>/<FILE>`\nreference, which will load `<FILE>` from a module's `files`\ndirectory. (For example, the reference `mysql/mysqltuner.pl` will load the\nfile `<MODULES DIRECTORY>/mysql/files/mysqltuner.pl`.)\n\nThis function also accepts an absolute file path that allows reading\nbinary file content from anywhere on disk.\n\nAn error is raised if the given file does not exists.\n\nTo search for the existence of files, use the `find_file()` function.\n\n- since 4.8.0",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"path"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Loads a binary file from a module or file system and returns its contents as a `Binary`.\nThe argument to this function should be a `<MODULE NAME>/<FILE>`\nreference, which will load `<FILE>` from a module's `files`\ndirectory. (For example, the reference `mysql/mysqltuner.pl` will load the\nfile `<MODULES DIRECTORY>/mysql/files/mysqltuner.pl`.)\n\nThis function also accepts an absolute file path that allows reading\nbinary file content from anywhere on disk.\n\nAn error is raised if the given file does not exists.\n\nTo search for the existence of files, use the `find_file()` function.\n\n- since 4.8.0",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "String"
            ],
            "name"=>"path"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.8.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:binary_file, Puppet::Functions::InternalFunction) do\n  dispatch :binary_file do\n    scope_param\n    param 'String', :path\n  end\n\n  def binary_file(scope, unresolved_path)\n    path = Puppet::Parser::Files.find_file(unresolved_path, scope.compiler.environment)\n    unless path && Puppet::FileSystem.exist?(path)\n      #TRANSLATORS the string \"binary_file()\" should not be translated\n      raise Puppet::ParseError, _(\"binary_file(): The given file '%{unresolved_path}' does not exist\") % { unresolved_path: unresolved_path }\n    end\n    Puppet::Pops::Types::PBinaryType::Binary.from_binary_string(Puppet::FileSystem.binread(path))\n  end\nend"
    },
    {
      "name"=>"break",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/break.rb",
      "line"=>34,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"break()",
          "docstring"=>{
            "text"=>"Breaks an innermost iteration as if it encountered an end of input.\nThis function does not return to the caller.\n\nThe signal produced to stop the iteration bubbles up through\nthe call stack until either terminating the innermost iteration or\nraising an error if the end of the call stack is reached.\n\nThe break() function does not accept an argument.\n\n```puppet\n$data = [1,2,3]\nnotice $data.map |$x| { if $x == 3 { break() } $x*10 }\n```\n\nWould notice the value `[10, 20]`\n\n```puppet\nfunction break_if_even($x) {\n  if $x % 2 == 0 { break() }\n}\n$data = [1,2,3]\nnotice $data.map |$x| { break_if_even($x); $x*10 }\n```\nWould notice the value `[10]`\n\n* Also see functions `next` and `return`",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `break`"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using a nested `break`"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Breaks an innermost iteration as if it encountered an end of input.\nThis function does not return to the caller.\n\nThe signal produced to stop the iteration bubbles up through\nthe call stack until either terminating the innermost iteration or\nraising an error if the end of the call stack is reached.\n\nThe break() function does not accept an argument.\n\n```puppet\n$data = [1,2,3]\nnotice $data.map |$x| { if $x == 3 { break() } $x*10 }\n```\n\nWould notice the value `[10, 20]`\n\n```puppet\nfunction break_if_even($x) {\n  if $x % 2 == 0 { break() }\n}\n$data = [1,2,3]\nnotice $data.map |$x| { break_if_even($x); $x*10 }\n```\nWould notice the value `[10]`\n\n* Also see functions `next` and `return`",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `break`"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using a nested `break`"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.8.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:break) do\n  dispatch :break_impl do\n  end\n\n  def break_impl()\n    # get file, line if available, else they are set to nil\n    file, line = Puppet::Pops::PuppetStack.top_of_stack\n\n    # PuppetStopIteration contains file and line and is a StopIteration exception\n    # so it can break a Ruby Kernel#loop or enumeration\n    #\n    raise Puppet::Pops::Evaluator::PuppetStopIteration.new(file, line)\n  end\nend"
    },
    {
      "name"=>"break",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/break.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"break()",
          "docstring"=>{
            "text"=>"Breaks the innermost iteration as if it encountered an end of input.\nThis function does not return to the caller.\n\nThe signal produced to stop the iteration bubbles up through\nthe call stack until either terminating the innermost iteration or\nraising an error if the end of the call stack is reached.\n\nThe break() function does not accept an argument.\n\n**Example:** Using `break`\n\n```puppet\n$data = [1,2,3]\nnotice $data.map |$x| { if $x == 3 { break() } $x*10 }\n```\n\nWould notice the value `[10, 20]`\n\n**Example:** Using a nested `break`\n\n```puppet\nfunction break_if_even($x) {\n  if $x % 2 == 0 { break() }\n}\n$data = [1,2,3]\nnotice $data.map |$x| { break_if_even($x); $x*10 }\n```\nWould notice the value `[10]`\n\n* Also see functions `next` and `return`\n* Since 4.8.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Breaks the innermost iteration as if it encountered an end of input.\nThis function does not return to the caller.\n\nThe signal produced to stop the iteration bubbles up through\nthe call stack until either terminating the innermost iteration or\nraising an error if the end of the call stack is reached.\n\nThe break() function does not accept an argument.\n\n**Example:** Using `break`\n\n```puppet\n$data = [1,2,3]\nnotice $data.map |$x| { if $x == 3 { break() } $x*10 }\n```\n\nWould notice the value `[10, 20]`\n\n**Example:** Using a nested `break`\n\n```puppet\nfunction break_if_even($x) {\n  if $x % 2 == 0 { break() }\n}\n$data = [1,2,3]\nnotice $data.map |$x| { break_if_even($x); $x*10 }\n```\nWould notice the value `[10]`\n\n* Also see functions `next` and `return`\n* Since 4.8.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :break,\n  :arity => 0,\n  :doc => <<-DOC\nBreaks the innermost iteration as if it encountered an end of input.\nThis function does not return to the caller.\n\nThe signal produced to stop the iteration bubbles up through\nthe call stack until either terminating the innermost iteration or\nraising an error if the end of the call stack is reached.\n\nThe break() function does not accept an argument.\n\n**Example:** Using `break`\n\n```puppet\n$data = [1,2,3]\nnotice $data.map |$x| { if $x == 3 { break() } $x*10 }\n```\n\nWould notice the value `[10, 20]`\n\n**Example:** Using a nested `break`\n\n```puppet\nfunction break_if_even($x) {\n  if $x % 2 == 0 { break() }\n}\n$data = [1,2,3]\nnotice $data.map |$x| { break_if_even($x); $x*10 }\n```\nWould notice the value `[10]`\n\n* Also see functions `next` and `return`\n* Since 4.8.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('break')\nend"
    },
    {
      "name"=>"call",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/call.rb",
      "line"=>58,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"call(String $function_name, Any *$arguments, Optional[Callable] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"function_name"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"*arguments"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"call(Deferred $deferred)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Deferred"
                ],
                "name"=>"deferred"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Calls an arbitrary Puppet function by name.\n\nThis function takes one mandatory argument and one or more optional arguments:\n\n1. A string corresponding to a function name.\n2. Any number of arguments to be passed to the called function.\n3. An optional lambda, if the function being called supports it.\n\nThis function can also be used to resolve a `Deferred` given as\nthe only argument to the function (does not accept arguments nor\na block).\n\n```puppet\n$a = 'notice'\ncall($a, 'message')\n```\n\n```puppet\n$a = 'each'\n$b = [1,2,3]\ncall($a, $b) |$item| {\n notify { $item: }\n}\n```\n\nThe `call` function can be used to call either Ruby functions or Puppet language\nfunctions.\n\nWhen used with `Deferred` values, the deferred value can either describe\na function call, or a dig into a variable.\n\n```puppet\n$d = Deferred('join', [[1,2,3], ':']) # A future call to join that joins the arguments 1,2,3 with ':'\nnotice($d.call())\n```\n\nWould notice the string \"1:2:3\".\n\n```puppet\n$d = Deferred('$facts', ['processors', 'count'])\nnotice($d.call())\n```\n\nWould notice the value of `$facts['processors']['count']` at the time when the `call` is made.\n\n* Deferred values supported since Puppet 6.0",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `call` function"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `call` function with a lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Resolving a deferred function call"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Resolving a deferred variable value with optional dig into its structure"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"call(String $function_name, Any *$arguments, Optional[Callable] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"function_name"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"*arguments"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"call"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"call(Deferred $deferred)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Deferred"
                  ],
                  "name"=>"deferred"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"call"
          },
          {
            "tag_name"=>"since",
            "text"=>"5.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:call, Puppet::Functions::InternalFunction) do\n  dispatch :call_impl_block do\n    scope_param\n    param 'String', :function_name\n    repeated_param 'Any', :arguments\n    optional_block_param\n  end\n\n  dispatch :call_deferred do\n    scope_param\n    param 'Deferred', :deferred\n  end\n\n  def call_impl_block(scope, function_name, *args, &block)\n    # The call function must be able to call functions loaded by any loader visible from the calling scope.\n    Puppet::Pops::Parser::EvaluatingParser.new.evaluator.external_call_function(function_name, args, scope, &block)\n  end\n\n  def call_deferred(scope, deferred)\n    Puppet::Pops::Evaluator::DeferredResolver.resolve(deferred, scope.compiler)\n  end\n\nend"
    },
    {
      "name"=>"camelcase",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/camelcase.rb",
      "line"=>31,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"camelcase(Numeric $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"camelcase(String $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"camelcase(Iterable[Variant[String, Numeric]] $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable[Variant[String, Numeric]]"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Creates a Camel Case version of a String\n\nThis function is compatible with the stdlib function with the same name.\n\nThe function does the following:\n* For a `String` the conversion replaces all combinations of *_<char>* with an upcased version of the\n  character following the _.  This is done using Ruby system locale which handles some, but not all\n  special international up-casing rules (for example German double-s ß is upcased to \"Ss\").\n* For an `Iterable[Variant[String, Numeric]]` (for example an `Array`) each value is capitalized and the conversion is not recursive.\n* If the value is `Numeric` it is simply returned (this is for backwards compatibility).\n* An error is raised for all other data types.\n* The result will not contain any underscore characters.\n\nPlease note: This function relies directly on Ruby's String implementation and as such may not be entirely UTF8 compatible.\nTo ensure best compatibility please use this function with Ruby 2.4.0 or greater - https://bugs.ruby-lang.org/issues/10085.\n\n```puppet\n'hello_friend'.camelcase()\ncamelcase('hello_friend')\n```\nWould both result in `\"HelloFriend\"`\n\n```puppet\n['abc_def', 'bcd_xyz'].camelcase()\ncamelcase(['abc_def', 'bcd_xyz'])\n```\nWould both result in `['AbcDef', 'BcdXyz']`",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Camelcase a String"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Camelcase of strings in an Array"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"camelcase(Numeric $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"camelcase"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"camelcase(String $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"camelcase"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"camelcase(Iterable[Variant[String, Numeric]] $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable[Variant[String, Numeric]]"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"camelcase"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:camelcase) do\n\n  dispatch :on_numeric do\n    param 'Numeric', :arg\n  end\n\n  dispatch :on_string do\n    param 'String', :arg\n  end\n\n  dispatch :on_iterable do\n    param 'Iterable[Variant[String, Numeric]]', :arg\n  end\n\n  # unit function - since the old implementation skipped Numeric values\n  def on_numeric(n)\n    n\n  end\n\n  def on_string(s)\n    s.split('_').map {|x| x.capitalize }.join('')\n  end\n\n  def on_iterable(a)\n    a.map {|x| do_camelcase(x) }\n  end\n\n  def do_camelcase(x)\n    # x can only be a String or Numeric because type constraints have been automatically applied\n    x.is_a?(String) ? on_string(x) : x\n  end\nend"
    },
    {
      "name"=>"capitalize",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/capitalize.rb",
      "line"=>30,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"capitalize(Numeric $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"capitalize(String $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"capitalize(Iterable[Variant[String, Numeric]] $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable[Variant[String, Numeric]]"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Capitalizes the first character of a String, or the first character of every String in an Iterable value (such as an Array).\n\nThis function is compatible with the stdlib function with the same name.\n\nThe function does the following:\n* For a `String`, a string with its first character in upper case version is returned. \n  This is done using Ruby system locale which handles some, but not all\n  special international up-casing rules (for example German double-s ß is capitalized to \"Ss\").\n* For an `Iterable[Variant[String, Numeric]]` (for example an `Array`) each value is capitalized and the conversion is not recursive.\n* If the value is `Numeric` it is simply returned (this is for backwards compatibility).\n* An error is raised for all other data types.\n\nPlease note: This function relies directly on Ruby's String implementation and as such may not be entirely UTF8 compatible.\nTo ensure best compatibility please use this function with Ruby 2.4.0 or greater - https://bugs.ruby-lang.org/issues/10085.\n\n```puppet\n'hello'.capitalize()\nupcase('hello')\n```\nWould both result in \"Hello\"\n\n```puppet\n['abc', 'bcd'].capitalize()\ncapitalize(['abc', 'bcd'])\n```\nWould both result in ['Abc', 'Bcd']",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Capitalizing a String"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Capitalizing strings in an Array"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"capitalize(Numeric $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"capitalize"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"capitalize(String $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"capitalize"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"capitalize(Iterable[Variant[String, Numeric]] $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable[Variant[String, Numeric]]"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"capitalize"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:capitalize) do\n\n  dispatch :on_numeric do\n    param 'Numeric', :arg\n  end\n\n  dispatch :on_string do\n    param 'String', :arg\n  end\n\n  dispatch :on_iterable do\n    param 'Iterable[Variant[String, Numeric]]', :arg\n  end\n\n  # unit function - since the old implementation skipped Numeric values\n  def on_numeric(n)\n    n\n  end\n\n  def on_string(s)\n    s.capitalize\n  end\n\n  def on_iterable(a)\n    a.map {|x| do_capitalize(x) }\n  end\n\n  def do_capitalize(x)\n    # x can only be a String or Numeric because type constraints have been automatically applied\n    x.is_a?(String) ? x.capitalize : x\n  end\nend"
    },
    {
      "name"=>"ceiling",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/ceiling.rb",
      "line"=>12,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"ceiling(Numeric $val)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"val"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"ceiling(String $val)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"val"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns the smallest `Integer` greater or equal to the argument.\nTakes a single numeric value as an argument.\n\nThis function is backwards compatible with the same function in stdlib\nand accepts a `Numeric` value. A `String` that can be converted\nto a floating point number can also be used in this version - but this\nis deprecated.\n\nIn general convert string input to `Numeric` before calling this function\nto have full control over how the conversion is done.",
        "tags"=>[
          {
            "tag_name"=>"overload",
            "signature"=>"ceiling(Numeric $val)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"val"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"ceiling"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"ceiling(String $val)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"val"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"ceiling"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:ceiling) do\n  dispatch :on_numeric do\n    param 'Numeric', :val\n  end\n\n  dispatch :on_string do\n    param 'String', :val\n  end\n\n  def on_numeric(x)\n    x.ceil\n  end\n\n  def on_string(x)\n    Puppet.warn_once('deprecations', 'ceiling_function_numeric_coerce_string',\n      _(\"The ceiling() function's auto conversion of String to Float is deprecated - change to convert input before calling\"))\n\n    begin\n      Float(x).ceil\n    rescue TypeError, ArgumentError => _e\n      # TRANSLATORS: 'ceiling' is a name and should not be translated\n      raise(ArgumentError, _('ceiling(): cannot convert given value to a floating point value.'))\n    end\n  end\n\nend"
    },
    {
      "name"=>"chomp",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/chomp.rb",
      "line"=>26,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"chomp(Numeric $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"chomp(String $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"chomp(Iterable[Variant[String, Numeric]] $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable[Variant[String, Numeric]]"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns a new string with the record separator character(s) removed.\nThe record separator is the line ending characters `\\r` and `\\n`.\n\nThis function is compatible with the stdlib function with the same name.\n\nThe function does the following:\n* For a `String` the conversion removes `\\r\\n`, `\\n` or `\\r` from the end of a string.\n* For an `Iterable[Variant[String, Numeric]]` (for example an `Array`) each value is processed and the conversion is not recursive.\n* If the value is `Numeric` it is simply returned (this is for backwards compatibility).\n* An error is raised for all other data types.\n\n```puppet\n\"hello\\r\\n\".chomp()\nchomp(\"hello\\r\\n\")\n```\nWould both result in `\"hello\"`\n\n```puppet\n[\"hello\\r\\n\", \"hi\\r\\n\"].chomp()\nchomp([\"hello\\r\\n\", \"hi\\r\\n\"])\n```\nWould both result in `['hello', 'hi']`",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Removing line endings"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Removing line endings in an array"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"chomp(Numeric $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"chomp"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"chomp(String $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"chomp"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"chomp(Iterable[Variant[String, Numeric]] $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable[Variant[String, Numeric]]"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"chomp"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:chomp) do\n\n  dispatch :on_numeric do\n    param 'Numeric', :arg\n  end\n\n  dispatch :on_string do\n    param 'String', :arg\n  end\n\n  dispatch :on_iterable do\n    param 'Iterable[Variant[String, Numeric]]', :arg\n  end\n\n  # unit function - since the old implementation skipped Numeric values\n  def on_numeric(n)\n    n\n  end\n\n  def on_string(s)\n    s.chomp\n  end\n\n  def on_iterable(a)\n    a.map {|x| do_chomp(x) }\n  end\n\n  def do_chomp(x)\n    # x can only be a String or Numeric because type constraints have been automatically applied\n    x.is_a?(String) ? x.chomp : x\n  end\nend"
    },
    {
      "name"=>"chop",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/chop.rb",
      "line"=>36,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"chop(Numeric $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"chop(String $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"chop(Iterable[Variant[String, Numeric]] $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable[Variant[String, Numeric]]"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns a new string with the last character removed.\nIf the string ends with `\\r\\n`, both characters are removed. Applying chop to an empty\nstring returns an empty string. If you wish to merely remove record\nseparators then you should use the `chomp` function.\n\nThis function is compatible with the stdlib function with the same name.\n\nThe function does the following:\n* For a `String` the conversion removes the last character, or if it ends with \\r\\n` it removes both. If String is empty\n  an empty string is returned.\n* For an `Iterable[Variant[String, Numeric]]` (for example an `Array`) each value is processed and the conversion is not recursive.\n* If the value is `Numeric` it is simply returned (this is for backwards compatibility).\n* An error is raised for all other data types.\n\n```puppet\n\"hello\\r\\n\".chop()\nchop(\"hello\\r\\n\")\n```\nWould both result in `\"hello\"`\n\n```puppet\n\"hello\".chop()\nchop(\"hello\")\n```\nWould both result in `\"hell\"`\n\n```puppet\n[\"hello\\r\\n\", \"hi\\r\\n\"].chop()\nchop([\"hello\\r\\n\", \"hi\\r\\n\"])\n```\nWould both result in `['hello', 'hi']`",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Removing line endings"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Removing last char"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Removing last char in an array"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"chop(Numeric $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"chop"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"chop(String $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"chop"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"chop(Iterable[Variant[String, Numeric]] $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable[Variant[String, Numeric]]"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"chop"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:chop) do\n\n  dispatch :on_numeric do\n    param 'Numeric', :arg\n  end\n\n  dispatch :on_string do\n    param 'String', :arg\n  end\n\n  dispatch :on_iterable do\n    param 'Iterable[Variant[String, Numeric]]', :arg\n  end\n\n  # unit function - since the old implementation skipped Numeric values\n  def on_numeric(n)\n    n\n  end\n\n  def on_string(s)\n    s.chop\n  end\n\n  def on_iterable(a)\n    a.map {|x| do_chop(x) }\n  end\n\n  def do_chop(x)\n    # x can only be a String or Numeric because type constraints have been automatically applied\n    x.is_a?(String) ? x.chop : x\n  end\nend"
    },
    {
      "name"=>"compare",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/compare.rb",
      "line"=>12,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"compare(Numeric $a, Numeric $b)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"a"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"b"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"compare(String $a, String $b, Optional[Boolean] $ignore_case)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"a"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"b"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Boolean]"
                ],
                "name"=>"ignore_case"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"compare(Semver $a, Semver $b)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Semver"
                ],
                "name"=>"a"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Semver"
                ],
                "name"=>"b"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"compare(Numeric $a, Variant[Timespan, Timestamp] $b)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"a"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Variant[Timespan, Timestamp]"
                ],
                "name"=>"b"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"compare(Timestamp $a, Variant[Timestamp, Numeric] $b)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Timestamp"
                ],
                "name"=>"a"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Variant[Timestamp, Numeric]"
                ],
                "name"=>"b"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"compare(Timespan $a, Variant[Timespan, Numeric] $b)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Timespan"
                ],
                "name"=>"a"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Variant[Timespan, Numeric]"
                ],
                "name"=>"b"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Compares two values and returns -1, 0 or 1 if first value is smaller, equal or larger than the second value.\nThe compare function accepts arguments of the data types `String`, `Numeric`, `Timespan`, `Timestamp`, and `Semver`,\nsuch that:\n\n* two of the same data type can be compared\n* `Timespan` and `Timestamp` can be compared with each other and with `Numeric`\n\nWhen comparing two `String` values the comparison can be made to consider case by passing a third (optional)\nboolean `false` value - the default is `true` which ignores case as the comparison operators\nin the Puppet Language.",
        "tags"=>[
          {
            "tag_name"=>"overload",
            "signature"=>"compare(Numeric $a, Numeric $b)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"a"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"b"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"compare"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"compare(String $a, String $b, Optional[Boolean] $ignore_case)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"a"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"b"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Boolean]"
                  ],
                  "name"=>"ignore_case"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"compare"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"compare(Semver $a, Semver $b)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Semver"
                  ],
                  "name"=>"a"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Semver"
                  ],
                  "name"=>"b"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"compare"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"compare(Numeric $a, Variant[Timespan, Timestamp] $b)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"a"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Variant[Timespan, Timestamp]"
                  ],
                  "name"=>"b"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"compare"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"compare(Timestamp $a, Variant[Timestamp, Numeric] $b)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Timestamp"
                  ],
                  "name"=>"a"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Variant[Timestamp, Numeric]"
                  ],
                  "name"=>"b"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"compare"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"compare(Timespan $a, Variant[Timespan, Numeric] $b)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Timespan"
                  ],
                  "name"=>"a"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Variant[Timespan, Numeric]"
                  ],
                  "name"=>"b"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"compare"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:compare) do\n  local_types do\n    type 'TimeComparable = Variant[Numeric, Timespan, Timestamp]'\n    type 'Comparable = Variant[String, Semver, TimeComparable]'\n  end\n\n  dispatch :on_numeric do\n    param 'Numeric', :a\n    param 'Numeric', :b\n  end\n\n  dispatch :on_string do\n    param 'String', :a\n    param 'String', :b\n    optional_param 'Boolean', :ignore_case\n  end\n\n  dispatch :on_version do\n    param 'Semver', :a\n    param 'Semver', :b\n  end\n\n  dispatch :on_time_num_first do\n    param 'Numeric', :a\n    param 'Variant[Timespan, Timestamp]', :b\n  end\n\n  dispatch :on_timestamp do\n    param 'Timestamp', :a\n    param 'Variant[Timestamp, Numeric]', :b\n  end\n\n  dispatch :on_timespan do\n    param 'Timespan', :a\n    param 'Variant[Timespan, Numeric]', :b\n  end\n\n  argument_mismatch :on_error do\n    param 'Comparable', :a\n    param 'Comparable', :b\n    repeated_param 'Any', :ignore_case\n  end\n\n  argument_mismatch :on_not_comparable do\n    param 'Any', :a\n    param 'Any', :b\n    repeated_param 'Any', :ignore_case\n  end\n\n  def on_numeric(a, b)\n    a <=> b\n  end\n\n  def on_string(a, b, ignore_case = true)\n    if ignore_case\n      a.casecmp(b)\n    else\n      a <=> b\n    end\n  end\n\n  def on_version(a, b)\n    a <=> b\n  end\n\n  def on_time_num_first(a, b)\n    # Time data types can compare against Numeric but not the other way around\n    # the comparison is therefore done in reverse and the answer is inverted.\n    -(b <=> a)\n  end\n\n  def on_timespan(a, b)\n    a <=> b\n  end\n\n  def on_timestamp(a, b)\n    a <=> b\n  end\n\n  def on_not_comparable(a, b, *ignore_case)\n    # TRANSLATORS 'compare' is a name\n    _(\"compare(): Non comparable type. Only values of the types Numeric, String, Semver, Timestamp and Timestamp can be compared. Got %{type_a} and %{type_b}\") % {\n      type_a: type_label(a), type_b: type_label(b)\n    }\n  end\n\n  def on_error(a, b, *ignore_case)\n    if !ignore_case.empty?\n      unless a.is_a?(String) && b.is_a?(String)\n        # TRANSLATORS 'compare' is a name\n        return _(\"compare(): The third argument (ignore case) can only be used when comparing strings\")\n      end\n      unless ignore_case.size == 1\n        # TRANSLATORS 'compare' is a name\n        return _(\"compare(): Accepts at most 3 arguments, got %{actual_number}\") % {actual_number: 2 + ignore_case.size}\n      end\n      unless ignore_case[0].is_a?(Boolean)\n        # TRANSLATORS 'compare' is a name\n        return _(\"compare(): The third argument (ignore case) must be a Boolean. Got %{type}\") % { type: type_label(ignore_case[0]) }\n      end\n    end\n\n    if a.class != b.class\n      # TRANSLATORS 'compare' is a name\n      return _(\"compare(): Can only compare values of the same type (or for Timestamp/Timespan also against Numeric). Got %{type_a} and %{type_b}\") % {\n        type_a: type_label(a), type_b: type_label(b)\n      }\n    end\n  end\n\n  def type_label(x)\n    Puppet::Pops::Model::ModelLabelProvider.new.label(x)\n  end\nend"
    },
    {
      "name"=>"contain",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/contain.rb",
      "line"=>21,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"contain(Any *$names)",
          "docstring"=>{
            "text"=>"Makes one or more classes be contained inside the current class.\nIf any of these classes are undeclared, they will be declared as if\nthere were declared with the `include` function.\nAccepts a class name, an array of class names, or a comma-separated\nlist of class names.\n\nA contained class will not be applied before the containing class is\nbegun, and will be finished before the containing class is finished.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use `Class` and `Resource` `Type`-values that are produced by\nevaluating resource and relationship expressions.\n\nThe function returns an array of references to the classes that were contained thus\nallowing the function call to `contain` to directly continue.\n\n- Since 4.0.0 support for `Class` and `Resource` `Type`-values, absolute names\n- Since 4.7.0 a value of type `Array[Type[Class[n]]]` is returned with all the contained classes",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"*names"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Makes one or more classes be contained inside the current class.\nIf any of these classes are undeclared, they will be declared as if\nthere were declared with the `include` function.\nAccepts a class name, an array of class names, or a comma-separated\nlist of class names.\n\nA contained class will not be applied before the containing class is\nbegun, and will be finished before the containing class is finished.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use `Class` and `Resource` `Type`-values that are produced by\nevaluating resource and relationship expressions.\n\nThe function returns an array of references to the classes that were contained thus\nallowing the function call to `contain` to directly continue.\n\n- Since 4.0.0 support for `Class` and `Resource` `Type`-values, absolute names\n- Since 4.7.0 a value of type `Array[Type[Class[n]]]` is returned with all the contained classes",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Any"
            ],
            "name"=>"*names"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:contain, Puppet::Functions::InternalFunction) do\n  dispatch :contain do\n    scope_param\n    # The function supports what the type system sees as Ruby runtime objects, and\n    # they cannot be parameterized to find what is actually valid instances.\n    # The validation is instead done in the function body itself via a call to\n    # `transform_and_assert_classnames` on the calling scope.\n    required_repeated_param 'Any', :names\n  end\n\n  def contain(scope, *classes)\n    if Puppet[:tasks]\n      raise Puppet::ParseErrorWithIssue.from_issue_and_stack(\n        Puppet::Pops::Issues::CATALOG_OPERATION_NOT_SUPPORTED_WHEN_SCRIPTING,\n        {:operation => 'contain'})\n    end\n\n    # Make call patterns uniform and protected against nested arrays, also make\n    # names absolute if so desired.\n    classes = scope.transform_and_assert_classnames(classes.flatten)\n\n    result = classes.map {|name| Puppet::Pops::Types::TypeFactory.host_class(name) }\n    containing_resource = scope.resource\n\n    # This is the same as calling the include function but faster and does not rely on the include\n    # function.\n    (scope.compiler.evaluate_classes(classes, scope, false) || []).each do |resource|\n      if ! scope.catalog.edge?(containing_resource, resource)\n        scope.catalog.add_edge(containing_resource, resource)\n      end\n    end\n    # Result is an Array[Class, 1, n] which allows chaining other operations\n    result\n  end\nend"
    },
    {
      "name"=>"contain",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/contain.rb",
      "line"=>4,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"contain()",
          "docstring"=>{
            "text"=>"Contain one or more classes inside the current class. If any of\nthese classes are undeclared, they will be declared as if called with the\n`include` function. Accepts a class name, an array of class names, or a\ncomma-separated list of class names.\n\nA contained class will not be applied before the containing class is\nbegun, and will be finished before the containing class is finished.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use Class and Resource Type values that are produced by\nevaluating resource and relationship expressions.\n\nThe function returns an array of references to the classes that were contained thus\nallowing the function call to `contain` to directly continue.\n\n- Since 4.0.0 support for Class and Resource Type values, absolute names\n- Since 4.7.0 an Array[Type[Class[n]]] is returned with all the contained classes",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Contain one or more classes inside the current class. If any of\nthese classes are undeclared, they will be declared as if called with the\n`include` function. Accepts a class name, an array of class names, or a\ncomma-separated list of class names.\n\nA contained class will not be applied before the containing class is\nbegun, and will be finished before the containing class is finished.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use Class and Resource Type values that are produced by\nevaluating resource and relationship expressions.\n\nThe function returns an array of references to the classes that were contained thus\nallowing the function call to `contain` to directly continue.\n\n- Since 4.0.0 support for Class and Resource Type values, absolute names\n- Since 4.7.0 an Array[Type[Class[n]]] is returned with all the contained classes",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :contain,\n  :arity => -2,\n  :doc => \"Contain one or more classes inside the current class. If any of\nthese classes are undeclared, they will be declared as if called with the\n`include` function. Accepts a class name, an array of class names, or a\ncomma-separated list of class names.\n\nA contained class will not be applied before the containing class is\nbegun, and will be finished before the containing class is finished.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use Class and Resource Type values that are produced by\nevaluating resource and relationship expressions.\n\nThe function returns an array of references to the classes that were contained thus\nallowing the function call to `contain` to directly continue.\n\n- Since 4.0.0 support for Class and Resource Type values, absolute names\n- Since 4.7.0 an Array[Type[Class[n]]] is returned with all the contained classes\n\"\n) do |classes|\n  # Call the 4.x version of this function in case 3.x ruby code uses this function\n  Puppet.warn_once('deprecations', '3xfunction#contain', _(\"Calling function_contain via the Scope class is deprecated. Use Scope#call_function instead\"))\n  call_function('contain', classes)\nend"
    },
    {
      "name"=>"convert_to",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/convert_to.rb",
      "line"=>22,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"convert_to(Any $value, Type $type, Optional[Any] *$args, Optional[Callable[1,1]] &$block)",
          "docstring"=>{
            "text"=>"The `convert_to(value, type)` is a convenience function that does the same as `new(type, value)`.\nThe difference in the argument ordering allows it to be used in chained style for\nimproved readability \"left to right\".\n\nWhen the function is given a lambda, it is called with the converted value, and the function\nreturns what the lambda returns, otherwise the converted value.\n\n```puppet\n  # The harder to read variant:\n  # Using new operator - that is \"calling the type\" with operator ()\n  Hash(Array(\"abc\").map |$i,$v| { [$i, $v] })\n\n  # The easier to read variant:\n  # using 'convert_to'\n  \"abc\".convert_to(Array).map |$i,$v| { [$i, $v] }.convert_to(Hash)\n```",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"'convert_to' instead of 'new'"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Type"
                ],
                "name"=>"type"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Any]"
                ],
                "name"=>"*args"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[1,1]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"The `convert_to(value, type)` is a convenience function that does the same as `new(type, value)`.\nThe difference in the argument ordering allows it to be used in chained style for\nimproved readability \"left to right\".\n\nWhen the function is given a lambda, it is called with the converted value, and the function\nreturns what the lambda returns, otherwise the converted value.\n\n```puppet\n  # The harder to read variant:\n  # Using new operator - that is \"calling the type\" with operator ()\n  Hash(Array(\"abc\").map |$i,$v| { [$i, $v] })\n\n  # The easier to read variant:\n  # using 'convert_to'\n  \"abc\".convert_to(Array).map |$i,$v| { [$i, $v] }.convert_to(Hash)\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"'convert_to' instead of 'new'"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Any"
            ],
            "name"=>"value"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Type"
            ],
            "name"=>"type"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Any]"
            ],
            "name"=>"*args"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Callable[1,1]]"
            ],
            "name"=>"&block"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"5.4.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:convert_to) do\n  dispatch :convert_to do\n    param 'Any', :value\n    param 'Type', :type\n    optional_repeated_param 'Any', :args\n    optional_block_param 'Callable[1,1]', :block\n  end\n\n  def convert_to(value, type, *args, &block)\n    result = call_function('new', type, value, *args)\n    block_given? ? yield(result) : result\n  end\nend"
    },
    {
      "name"=>"create_resources",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/create_resources.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"create_resources()",
          "docstring"=>{
            "text"=>"Converts a hash into a set of resources and adds them to the catalog.\n\n**Note**: Use this function selectively. It's generally better to write resources in\n [Puppet](https://puppet.com/docs/puppet/latest/lang_resources.html), as\n resources created with `create_resource` are difficult to read and troubleshoot.\n\nThis function takes two mandatory arguments: a resource type, and a hash describing\na set of resources. The hash should be in the form `{title => {parameters} }`:\n\n    # A hash of user resources:\n    $myusers = {\n      'nick' => { uid    => '1330',\n                  gid    => allstaff,\n                  groups => ['developers', 'operations', 'release'], },\n      'dan'  => { uid    => '1308',\n                  gid    => allstaff,\n                  groups => ['developers', 'prosvc', 'release'], },\n    }\n\n    create_resources(user, $myusers)\n\nA third, optional parameter may be given, also as a hash:\n\n    $defaults = {\n      'ensure'   => present,\n      'provider' => 'ldap',\n    }\n\n    create_resources(user, $myusers, $defaults)\n\nThe values given on the third argument are added to the parameters of each resource\npresent in the set given on the second argument. If a parameter is present on both\nthe second and third arguments, the one on the second argument takes precedence.\n\nThis function can be used to create defined resources and classes, as well\nas native resources.\n\nVirtual and Exported resources may be created by prefixing the type name\nwith @ or @@ respectively. For example, the $myusers hash may be exported\nin the following manner:\n\n    create_resources(\"@@user\", $myusers)\n\nThe $myusers may be declared as virtual resources using:\n\n    create_resources(\"@user\", $myusers)\n\nNote that `create_resources` filters out parameter values that are `undef` so that normal\ndata binding and Puppet default value expressions are considered (in that order) for the\nfinal value of a parameter (just as when setting a parameter to `undef` in a Puppet language\nresource declaration).",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Converts a hash into a set of resources and adds them to the catalog.\n\n**Note**: Use this function selectively. It's generally better to write resources in\n [Puppet](https://puppet.com/docs/puppet/latest/lang_resources.html), as\n resources created with `create_resource` are difficult to read and troubleshoot.\n\nThis function takes two mandatory arguments: a resource type, and a hash describing\na set of resources. The hash should be in the form `{title => {parameters} }`:\n\n    # A hash of user resources:\n    $myusers = {\n      'nick' => { uid    => '1330',\n                  gid    => allstaff,\n                  groups => ['developers', 'operations', 'release'], },\n      'dan'  => { uid    => '1308',\n                  gid    => allstaff,\n                  groups => ['developers', 'prosvc', 'release'], },\n    }\n\n    create_resources(user, $myusers)\n\nA third, optional parameter may be given, also as a hash:\n\n    $defaults = {\n      'ensure'   => present,\n      'provider' => 'ldap',\n    }\n\n    create_resources(user, $myusers, $defaults)\n\nThe values given on the third argument are added to the parameters of each resource\npresent in the set given on the second argument. If a parameter is present on both\nthe second and third arguments, the one on the second argument takes precedence.\n\nThis function can be used to create defined resources and classes, as well\nas native resources.\n\nVirtual and Exported resources may be created by prefixing the type name\nwith @ or @@ respectively. For example, the $myusers hash may be exported\nin the following manner:\n\n    create_resources(\"@@user\", $myusers)\n\nThe $myusers may be declared as virtual resources using:\n\n    create_resources(\"@user\", $myusers)\n\nNote that `create_resources` filters out parameter values that are `undef` so that normal\ndata binding and Puppet default value expressions are considered (in that order) for the\nfinal value of a parameter (just as when setting a parameter to `undef` in a Puppet language\nresource declaration).",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:create_resources, :arity => -3, :doc => <<-'ENDHEREDOC') do |args|\n    Converts a hash into a set of resources and adds them to the catalog.\n    \n    **Note**: Use this function selectively. It's generally better to write resources in\n     [Puppet](https://puppet.com/docs/puppet/latest/lang_resources.html), as\n     resources created with `create_resource` are difficult to read and troubleshoot.\n\n    This function takes two mandatory arguments: a resource type, and a hash describing\n    a set of resources. The hash should be in the form `{title => {parameters} }`:\n\n        # A hash of user resources:\n        $myusers = {\n          'nick' => { uid    => '1330',\n                      gid    => allstaff,\n                      groups => ['developers', 'operations', 'release'], },\n          'dan'  => { uid    => '1308',\n                      gid    => allstaff,\n                      groups => ['developers', 'prosvc', 'release'], },\n        }\n\n        create_resources(user, $myusers)\n\n    A third, optional parameter may be given, also as a hash:\n\n        $defaults = {\n          'ensure'   => present,\n          'provider' => 'ldap',\n        }\n\n        create_resources(user, $myusers, $defaults)\n\n    The values given on the third argument are added to the parameters of each resource\n    present in the set given on the second argument. If a parameter is present on both\n    the second and third arguments, the one on the second argument takes precedence.\n\n    This function can be used to create defined resources and classes, as well\n    as native resources.\n\n    Virtual and Exported resources may be created by prefixing the type name\n    with @ or @@ respectively. For example, the $myusers hash may be exported\n    in the following manner:\n\n        create_resources(\"@@user\", $myusers)\n\n    The $myusers may be declared as virtual resources using:\n\n        create_resources(\"@user\", $myusers)\n\n    Note that `create_resources` filters out parameter values that are `undef` so that normal\n    data binding and Puppet default value expressions are considered (in that order) for the\n    final value of a parameter (just as when setting a parameter to `undef` in a Puppet language\n    resource declaration).\n  ENDHEREDOC\n  if Puppet[:tasks]\n    raise Puppet::ParseErrorWithIssue.from_issue_and_stack(\n      Puppet::Pops::Issues::CATALOG_OPERATION_NOT_SUPPORTED_WHEN_SCRIPTING,\n      {:operation => 'create_resources'})\n  end\n\n  raise ArgumentError, (_(\"create_resources(): wrong number of arguments (%{count}; must be 2 or 3)\") % { count: args.length }) if args.length > 3\n  raise ArgumentError, (_('create_resources(): second argument must be a hash')) unless args[1].is_a?(Hash)\n  if args.length == 3\n    raise ArgumentError, (_('create_resources(): third argument, if provided, must be a hash')) unless args[2].is_a?(Hash)\n  end\n\n  type, instances, defaults = args\n  defaults ||= {}\n  type_name = type.sub(/^@{1,2}/, '').downcase\n\n  # Get file/line information from the Puppet stack (where call comes from in Puppet source)\n  # If relayed via other Puppet functions in ruby that do not nest their calls, the source position\n  # will be in the original Puppet source.\n  #\n  file, line = Puppet::Pops::PuppetStack.top_of_stack\n\n  if type.start_with? '@@'\n    exported = true\n    virtual = true\n  elsif type.start_with? '@'\n    virtual = true\n  end\n\n  if type_name == 'class' && (exported || virtual)\n    # cannot find current evaluator, so use another\n    evaluator = Puppet::Pops::Parser::EvaluatingParser.new.evaluator\n    # optionally fails depending on configured severity of issue\n    evaluator.runtime_issue(Puppet::Pops::Issues::CLASS_NOT_VIRTUALIZABLE)\n  end\n\n  instances.map do |title, params|\n    # Add support for iteration if title is an array\n    resource_titles = title.is_a?(Array) ? title  : [title]\n    Puppet::Pops::Evaluator::Runtime3ResourceSupport.create_resources(\n      file, line,\n      self,\n      virtual, exported,\n      type_name,\n      resource_titles,\n      defaults.merge(params).map do |name, value|\n        value = nil if value == :undef\n        Puppet::Parser::Resource::Param.new(\n          :name   => name,\n          :value  => value, # wide open to various data types, must be correct\n          :source => self.source, # TODO: support :line => line, :file => file,\n          :add    => false\n        )\n      end.compact\n      )\n  end.flatten.compact\nend"
    },
    {
      "name"=>"crit",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/crit.rb",
      "line"=>2,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"crit(Any *$values)",
          "docstring"=>{
            "text"=>"Logs a message on the server at level `crit`.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"The values to log.",
                "types"=>[
                  "Any"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Undef"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Logs a message on the server at level `crit`.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"The values to log.",
            "types"=>[
              "Any"
            ],
            "name"=>"*values"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Undef"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:crit, Puppet::Functions::InternalFunction) do\n  # @param values The values to log.\n  # @return [Undef]\n  dispatch :crit do\n    scope_param\n    repeated_param 'Any', :values\n    return_type 'Undef'\n  end\n\n  def crit(scope, *values)\n    Puppet::Util::Log.log_func(scope, :crit, values)\n  end\nend"
    },
    {
      "name"=>"debug",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/debug.rb",
      "line"=>2,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"debug(Any *$values)",
          "docstring"=>{
            "text"=>"Logs a message on the server at level `debug`.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"The values to log.",
                "types"=>[
                  "Any"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Undef"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Logs a message on the server at level `debug`.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"The values to log.",
            "types"=>[
              "Any"
            ],
            "name"=>"*values"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Undef"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:debug, Puppet::Functions::InternalFunction) do\n  # @param values The values to log.\n  # @return [Undef]\n  dispatch :debug do\n    scope_param\n    repeated_param 'Any', :values\n    return_type 'Undef'\n  end\n\n  def debug(scope, *values)\n    Puppet::Util::Log.log_func(scope, :debug, values)\n  end\nend"
    },
    {
      "name"=>"defined",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/defined.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"defined()",
          "docstring"=>{
            "text"=>"Determines whether a given class or resource type is defined and returns a Boolean\nvalue. You can also use `defined` to determine whether a specific resource is defined,\nor whether a variable has a value (including `undef`, as opposed to the variable never\nbeing declared or assigned).\n\nThis function takes at least one string argument, which can be a class name, type name,\nresource reference, or variable reference of the form `'$name'`.\n\nThe `defined` function checks both native and defined types, including types\nprovided by modules. Types and classes are matched by their names. The function matches\nresource declarations by using resource references.\n\n**Examples**: Different types of `defined` function matches\n\n~~~ puppet\n# Matching resource types\ndefined(\"file\")\ndefined(\"customtype\")\n\n# Matching defines and classes\ndefined(\"foo\")\ndefined(\"foo::bar\")\n\n# Matching variables\ndefined('$name')\n\n# Matching declared resources\ndefined(File['/tmp/file'])\n~~~\n\nPuppet depends on the configuration's evaluation order when checking whether a resource\nis declared.\n\n**Example**: Importance of evaluation order when using `defined`\n\n~~~ puppet\n# Assign values to $is_defined_before and $is_defined_after using identical `defined`\n# functions.\n\n$is_defined_before = defined(File['/tmp/file'])\n\nfile { \"/tmp/file\":\n  ensure => present,\n}\n\n$is_defined_after = defined(File['/tmp/file'])\n\n# $is_defined_before returns false, but $is_defined_after returns true.\n~~~\n\nThis order requirement only refers to evaluation order. The order of resources in the\nconfiguration graph (e.g. with `before` or `require`) does not affect the `defined`\nfunction's behavior.\n\n> **Warning:** Avoid relying on the result of the `defined` function in modules, as you\n> might not be able to guarantee the evaluation order well enough to produce consistent\n> results. This can cause other code that relies on the function's result to behave\n> inconsistently or fail.\n\nIf you pass more than one argument to `defined`, the function returns `true` if _any_\nof the arguments are defined. You can also match resources by type, allowing you to\nmatch conditions of different levels of specificity, such as whether a specific resource\nis of a specific data type.\n\n**Example**: Matching multiple resources and resources by different types with `defined`\n\n~~~ puppet\nfile { \"/tmp/file1\":\n  ensure => file,\n}\n\n$tmp_file = file { \"/tmp/file2\":\n  ensure => file,\n}\n\n# Each of these statements return `true` ...\ndefined(File['/tmp/file1'])\ndefined(File['/tmp/file1'],File['/tmp/file2'])\ndefined(File['/tmp/file1'],File['/tmp/file2'],File['/tmp/file3'])\n# ... but this returns `false`.\ndefined(File['/tmp/file3'])\n\n# Each of these statements returns `true` ...\ndefined(Type[Resource['file','/tmp/file2']])\ndefined(Resource['file','/tmp/file2'])\ndefined(File['/tmp/file2'])\ndefined('$tmp_file')\n# ... but each of these returns `false`.\ndefined(Type[Resource['exec','/tmp/file2']])\ndefined(Resource['exec','/tmp/file2'])\ndefined(File['/tmp/file3'])\ndefined('$tmp_file2')\n~~~\n\n- Since 2.7.0\n- Since 3.6.0 variable reference and future parser types\n- Since 3.8.1 type specific requests with future parser\n- Since 4.0.0 includes all future parser features",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Determines whether a given class or resource type is defined and returns a Boolean\nvalue. You can also use `defined` to determine whether a specific resource is defined,\nor whether a variable has a value (including `undef`, as opposed to the variable never\nbeing declared or assigned).\n\nThis function takes at least one string argument, which can be a class name, type name,\nresource reference, or variable reference of the form `'$name'`.\n\nThe `defined` function checks both native and defined types, including types\nprovided by modules. Types and classes are matched by their names. The function matches\nresource declarations by using resource references.\n\n**Examples**: Different types of `defined` function matches\n\n~~~ puppet\n# Matching resource types\ndefined(\"file\")\ndefined(\"customtype\")\n\n# Matching defines and classes\ndefined(\"foo\")\ndefined(\"foo::bar\")\n\n# Matching variables\ndefined('$name')\n\n# Matching declared resources\ndefined(File['/tmp/file'])\n~~~\n\nPuppet depends on the configuration's evaluation order when checking whether a resource\nis declared.\n\n**Example**: Importance of evaluation order when using `defined`\n\n~~~ puppet\n# Assign values to $is_defined_before and $is_defined_after using identical `defined`\n# functions.\n\n$is_defined_before = defined(File['/tmp/file'])\n\nfile { \"/tmp/file\":\n  ensure => present,\n}\n\n$is_defined_after = defined(File['/tmp/file'])\n\n# $is_defined_before returns false, but $is_defined_after returns true.\n~~~\n\nThis order requirement only refers to evaluation order. The order of resources in the\nconfiguration graph (e.g. with `before` or `require`) does not affect the `defined`\nfunction's behavior.\n\n> **Warning:** Avoid relying on the result of the `defined` function in modules, as you\n> might not be able to guarantee the evaluation order well enough to produce consistent\n> results. This can cause other code that relies on the function's result to behave\n> inconsistently or fail.\n\nIf you pass more than one argument to `defined`, the function returns `true` if _any_\nof the arguments are defined. You can also match resources by type, allowing you to\nmatch conditions of different levels of specificity, such as whether a specific resource\nis of a specific data type.\n\n**Example**: Matching multiple resources and resources by different types with `defined`\n\n~~~ puppet\nfile { \"/tmp/file1\":\n  ensure => file,\n}\n\n$tmp_file = file { \"/tmp/file2\":\n  ensure => file,\n}\n\n# Each of these statements return `true` ...\ndefined(File['/tmp/file1'])\ndefined(File['/tmp/file1'],File['/tmp/file2'])\ndefined(File['/tmp/file1'],File['/tmp/file2'],File['/tmp/file3'])\n# ... but this returns `false`.\ndefined(File['/tmp/file3'])\n\n# Each of these statements returns `true` ...\ndefined(Type[Resource['file','/tmp/file2']])\ndefined(Resource['file','/tmp/file2'])\ndefined(File['/tmp/file2'])\ndefined('$tmp_file')\n# ... but each of these returns `false`.\ndefined(Type[Resource['exec','/tmp/file2']])\ndefined(Resource['exec','/tmp/file2'])\ndefined(File['/tmp/file3'])\ndefined('$tmp_file2')\n~~~\n\n- Since 2.7.0\n- Since 3.6.0 variable reference and future parser types\n- Since 3.8.1 type specific requests with future parser\n- Since 4.0.0 includes all future parser features",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :defined,\n  :type => :rvalue,\n  :arity => -2,\n  :doc => <<DOC\nDetermines whether a given class or resource type is defined and returns a Boolean\nvalue. You can also use `defined` to determine whether a specific resource is defined,\nor whether a variable has a value (including `undef`, as opposed to the variable never\nbeing declared or assigned).\n\nThis function takes at least one string argument, which can be a class name, type name,\nresource reference, or variable reference of the form `'$name'`.\n\nThe `defined` function checks both native and defined types, including types\nprovided by modules. Types and classes are matched by their names. The function matches\nresource declarations by using resource references.\n\n**Examples**: Different types of `defined` function matches\n\n~~~ puppet\n# Matching resource types\ndefined(\"file\")\ndefined(\"customtype\")\n\n# Matching defines and classes\ndefined(\"foo\")\ndefined(\"foo::bar\")\n\n# Matching variables\ndefined('$name')\n\n# Matching declared resources\ndefined(File['/tmp/file'])\n~~~\n\nPuppet depends on the configuration's evaluation order when checking whether a resource\nis declared.\n\n**Example**: Importance of evaluation order when using `defined`\n\n~~~ puppet\n# Assign values to $is_defined_before and $is_defined_after using identical `defined`\n# functions.\n\n$is_defined_before = defined(File['/tmp/file'])\n\nfile { \"/tmp/file\":\n  ensure => present,\n}\n\n$is_defined_after = defined(File['/tmp/file'])\n\n# $is_defined_before returns false, but $is_defined_after returns true.\n~~~\n\nThis order requirement only refers to evaluation order. The order of resources in the\nconfiguration graph (e.g. with `before` or `require`) does not affect the `defined`\nfunction's behavior.\n\n> **Warning:** Avoid relying on the result of the `defined` function in modules, as you\n> might not be able to guarantee the evaluation order well enough to produce consistent\n> results. This can cause other code that relies on the function's result to behave\n> inconsistently or fail.\n\nIf you pass more than one argument to `defined`, the function returns `true` if _any_\nof the arguments are defined. You can also match resources by type, allowing you to\nmatch conditions of different levels of specificity, such as whether a specific resource\nis of a specific data type.\n\n**Example**: Matching multiple resources and resources by different types with `defined`\n\n~~~ puppet\nfile { \"/tmp/file1\":\n  ensure => file,\n}\n\n$tmp_file = file { \"/tmp/file2\":\n  ensure => file,\n}\n\n# Each of these statements return `true` ...\ndefined(File['/tmp/file1'])\ndefined(File['/tmp/file1'],File['/tmp/file2'])\ndefined(File['/tmp/file1'],File['/tmp/file2'],File['/tmp/file3'])\n# ... but this returns `false`.\ndefined(File['/tmp/file3'])\n\n# Each of these statements returns `true` ...\ndefined(Type[Resource['file','/tmp/file2']])\ndefined(Resource['file','/tmp/file2'])\ndefined(File['/tmp/file2'])\ndefined('$tmp_file')\n# ... but each of these returns `false`.\ndefined(Type[Resource['exec','/tmp/file2']])\ndefined(Resource['exec','/tmp/file2'])\ndefined(File['/tmp/file3'])\ndefined('$tmp_file2')\n~~~\n\n- Since 2.7.0\n- Since 3.6.0 variable reference and future parser types\n- Since 3.8.1 type specific requests with future parser\n- Since 4.0.0 includes all future parser features\nDOC\n) do |vals|\n  Puppet::Parser::Functions::Error.is4x('defined')\nend"
    },
    {
      "name"=>"defined",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/defined.rb",
      "line"=>102,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"defined(Variant[String, Type[CatalogEntry], Type[Type[CatalogEntry]]] *$vals)",
          "docstring"=>{
            "text"=>"Determines whether a given class or resource type is defined and returns a Boolean\nvalue. You can also use `defined` to determine whether a specific resource is defined,\nor whether a variable has a value (including `undef`, as opposed to the variable never\nbeing declared or assigned).\n\nThis function takes at least one string argument, which can be a class name, type name,\nresource reference, or variable reference of the form `'$name'`. (Note that the `$` sign\nis included in the string which must be in single quotes to prevent the `$` character\nto be interpreted as interpolation.\n\nThe `defined` function checks both native and defined types, including types\nprovided by modules. Types and classes are matched by their names. The function matches\nresource declarations by using resource references.\n\n```puppet\n# Matching resource types\ndefined(\"file\")\ndefined(\"customtype\")\n\n# Matching defines and classes\ndefined(\"foo\")\ndefined(\"foo::bar\")\n\n# Matching variables (note the single quotes)\ndefined('$name')\n\n# Matching declared resources\ndefined(File['/tmp/file'])\n```\n\nPuppet depends on the configuration's evaluation order when checking whether a resource\nis declared.\n\n```puppet\n# Assign values to $is_defined_before and $is_defined_after using identical `defined`\n# functions.\n\n$is_defined_before = defined(File['/tmp/file'])\n\nfile { \"/tmp/file\":\n  ensure => present,\n}\n\n$is_defined_after = defined(File['/tmp/file'])\n\n# $is_defined_before returns false, but $is_defined_after returns true.\n```\n\nThis order requirement only refers to evaluation order. The order of resources in the\nconfiguration graph (e.g. with `before` or `require`) does not affect the `defined`\nfunction's behavior.\n\n> **Warning:** Avoid relying on the result of the `defined` function in modules, as you\n> might not be able to guarantee the evaluation order well enough to produce consistent\n> results. This can cause other code that relies on the function's result to behave\n> inconsistently or fail.\n\nIf you pass more than one argument to `defined`, the function returns `true` if _any_\nof the arguments are defined. You can also match resources by type, allowing you to\nmatch conditions of different levels of specificity, such as whether a specific resource\nis of a specific data type.\n\n```puppet\nfile { \"/tmp/file1\":\n  ensure => file,\n}\n\n$tmp_file = file { \"/tmp/file2\":\n  ensure => file,\n}\n\n# Each of these statements return `true` ...\ndefined(File['/tmp/file1'])\ndefined(File['/tmp/file1'],File['/tmp/file2'])\ndefined(File['/tmp/file1'],File['/tmp/file2'],File['/tmp/file3'])\n# ... but this returns `false`.\ndefined(File['/tmp/file3'])\n\n# Each of these statements returns `true` ...\ndefined(Type[Resource['file','/tmp/file2']])\ndefined(Resource['file','/tmp/file2'])\ndefined(File['/tmp/file2'])\ndefined('$tmp_file')\n# ... but each of these returns `false`.\ndefined(Type[Resource['exec','/tmp/file2']])\ndefined(Resource['exec','/tmp/file2'])\ndefined(File['/tmp/file3'])\ndefined('$tmp_file2')\n```",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Different types of `defined` function matches"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Importance of evaluation order when using `defined`"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Matching multiple resources and resources by different types with `defined`"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Variant[String, Type[CatalogEntry], Type[Type[CatalogEntry]]]"
                ],
                "name"=>"*vals"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Determines whether a given class or resource type is defined and returns a Boolean\nvalue. You can also use `defined` to determine whether a specific resource is defined,\nor whether a variable has a value (including `undef`, as opposed to the variable never\nbeing declared or assigned).\n\nThis function takes at least one string argument, which can be a class name, type name,\nresource reference, or variable reference of the form `'$name'`. (Note that the `$` sign\nis included in the string which must be in single quotes to prevent the `$` character\nto be interpreted as interpolation.\n\nThe `defined` function checks both native and defined types, including types\nprovided by modules. Types and classes are matched by their names. The function matches\nresource declarations by using resource references.\n\n```puppet\n# Matching resource types\ndefined(\"file\")\ndefined(\"customtype\")\n\n# Matching defines and classes\ndefined(\"foo\")\ndefined(\"foo::bar\")\n\n# Matching variables (note the single quotes)\ndefined('$name')\n\n# Matching declared resources\ndefined(File['/tmp/file'])\n```\n\nPuppet depends on the configuration's evaluation order when checking whether a resource\nis declared.\n\n```puppet\n# Assign values to $is_defined_before and $is_defined_after using identical `defined`\n# functions.\n\n$is_defined_before = defined(File['/tmp/file'])\n\nfile { \"/tmp/file\":\n  ensure => present,\n}\n\n$is_defined_after = defined(File['/tmp/file'])\n\n# $is_defined_before returns false, but $is_defined_after returns true.\n```\n\nThis order requirement only refers to evaluation order. The order of resources in the\nconfiguration graph (e.g. with `before` or `require`) does not affect the `defined`\nfunction's behavior.\n\n> **Warning:** Avoid relying on the result of the `defined` function in modules, as you\n> might not be able to guarantee the evaluation order well enough to produce consistent\n> results. This can cause other code that relies on the function's result to behave\n> inconsistently or fail.\n\nIf you pass more than one argument to `defined`, the function returns `true` if _any_\nof the arguments are defined. You can also match resources by type, allowing you to\nmatch conditions of different levels of specificity, such as whether a specific resource\nis of a specific data type.\n\n```puppet\nfile { \"/tmp/file1\":\n  ensure => file,\n}\n\n$tmp_file = file { \"/tmp/file2\":\n  ensure => file,\n}\n\n# Each of these statements return `true` ...\ndefined(File['/tmp/file1'])\ndefined(File['/tmp/file1'],File['/tmp/file2'])\ndefined(File['/tmp/file1'],File['/tmp/file2'],File['/tmp/file3'])\n# ... but this returns `false`.\ndefined(File['/tmp/file3'])\n\n# Each of these statements returns `true` ...\ndefined(Type[Resource['file','/tmp/file2']])\ndefined(Resource['file','/tmp/file2'])\ndefined(File['/tmp/file2'])\ndefined('$tmp_file')\n# ... but each of these returns `false`.\ndefined(Type[Resource['exec','/tmp/file2']])\ndefined(Resource['exec','/tmp/file2'])\ndefined(File['/tmp/file3'])\ndefined('$tmp_file2')\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Different types of `defined` function matches"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Importance of evaluation order when using `defined`"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Matching multiple resources and resources by different types with `defined`"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Variant[String, Type[CatalogEntry], Type[Type[CatalogEntry]]]"
            ],
            "name"=>"*vals"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"2.7.0"
          },
          {
            "tag_name"=>"since",
            "text"=>"3.6.0 variable reference and future parser types"
          },
          {
            "tag_name"=>"since",
            "text"=>"3.8.1 type specific requests with future parser"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:'defined', Puppet::Functions::InternalFunction) do\n\n  dispatch :is_defined do\n    scope_param\n    required_repeated_param 'Variant[String, Type[CatalogEntry], Type[Type[CatalogEntry]]]', :vals\n  end\n\n  def is_defined(scope, *vals)\n    vals.any? do |val|\n      case val\n      when String\n        if val =~ /^\\$(.+)$/\n          scope.exist?($1)\n        else\n          case val\n          when ''\n            next nil\n          when 'main'\n            # Find the main class (known as ''), it does not have to be in the catalog\n            Puppet::Pops::Evaluator::Runtime3ResourceSupport.find_main_class(scope)\n          else\n            # Find a resource type, definition or class definition\n            Puppet::Pops::Evaluator::Runtime3ResourceSupport.find_resource_type_or_class(scope, val)\n          end\n        end\n      when Puppet::Resource\n        # Find instance of given resource type and title that is in the catalog\n        scope.compiler.findresource(val.resource_type, val.title)\n\n      when Puppet::Pops::Types::PResourceType\n        raise ArgumentError, _('The given resource type is a reference to all kind of types') if val.type_name.nil?\n        type = Puppet::Pops::Evaluator::Runtime3ResourceSupport.find_resource_type(scope, val.type_name)\n        val.title.nil? ? type : scope.compiler.findresource(type, val.title)\n\n      when Puppet::Pops::Types::PClassType\n        raise  ArgumentError, _('The given class type is a reference to all classes') if val.class_name.nil?\n        scope.compiler.findresource(:class, val.class_name)\n\n      when Puppet::Pops::Types::PTypeType\n        case val.type\n        when Puppet::Pops::Types::PResourceType\n          # It is most reasonable to take Type[File] and Type[File[foo]] to mean the same as if not wrapped in a Type\n          # Since the difference between File and File[foo] already captures the distinction of type vs instance.\n          is_defined(scope, val.type)\n\n        when Puppet::Pops::Types::PClassType\n          # Interpreted as asking if a class (and nothing else) is defined without having to be included in the catalog\n          # (this is the same as asking for just the class' name, but with the added certainty that it cannot be a defined type.\n          #\n          raise  ArgumentError, _('The given class type is a reference to all classes') if val.type.class_name.nil?\n          Puppet::Pops::Evaluator::Runtime3ResourceSupport.find_hostclass(scope, val.type.class_name)\n        end\n      else\n        raise ArgumentError, _(\"Invalid argument of type '%{value_class}' to 'defined'\") % { value_class: val.class }\n      end\n    end\n  end\nend"
    },
    {
      "name"=>"dig",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/dig.rb",
      "line"=>30,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"dig(Optional[Collection] $data, Any *$arg)",
          "docstring"=>{
            "text"=>"Returns a value for a sequence of given keys/indexes into a structure, such as\nan array or hash.\n\nThis function is used to \"dig into\" a complex data structure by\nusing a sequence of keys / indexes to access a value from which\nthe next key/index is accessed recursively.\n\nThe first encountered `undef` value or key stops the \"dig\" and `undef` is returned.\n\nAn error is raised if an attempt is made to \"dig\" into\nsomething other than an `undef` (which immediately returns `undef`), an `Array` or a `Hash`.\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {x => 100, y => 200}]}}\nnotice $data.dig('a', 'b', 1, 'x')\n```\n\nWould notice the value 100.\n\nThis is roughly equivalent to `$data['a']['b'][1]['x']`. However, a standard\nindex will return an error and cause catalog compilation failure if any parent\nof the final key (`'x'`) is `undef`. The `dig` function will return `undef`,\nrather than failing catalog compilation. This allows you to check if data\nexists in a structure without mandating that it always exists.",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `dig`"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Collection]"
                ],
                "name"=>"data"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"*arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns a value for a sequence of given keys/indexes into a structure, such as\nan array or hash.\n\nThis function is used to \"dig into\" a complex data structure by\nusing a sequence of keys / indexes to access a value from which\nthe next key/index is accessed recursively.\n\nThe first encountered `undef` value or key stops the \"dig\" and `undef` is returned.\n\nAn error is raised if an attempt is made to \"dig\" into\nsomething other than an `undef` (which immediately returns `undef`), an `Array` or a `Hash`.\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {x => 100, y => 200}]}}\nnotice $data.dig('a', 'b', 1, 'x')\n```\n\nWould notice the value 100.\n\nThis is roughly equivalent to `$data['a']['b'][1]['x']`. However, a standard\nindex will return an error and cause catalog compilation failure if any parent\nof the final key (`'x'`) is `undef`. The `dig` function will return `undef`,\nrather than failing catalog compilation. This allows you to check if data\nexists in a structure without mandating that it always exists.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `dig`"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Collection]"
            ],
            "name"=>"data"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Any"
            ],
            "name"=>"*arg"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.5.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:dig) do\n  dispatch :dig do\n    param 'Optional[Collection]', :data\n    repeated_param 'Any', :arg\n  end\n\n  def dig(data, *args)\n    walked_path = []\n    args.reduce(data) do | d, k |\n      return nil if d.nil? || k.nil?\n      if !(d.is_a?(Array) || d.is_a?(Hash))\n        t = Puppet::Pops::Types::TypeCalculator.infer(d)\n        msg = _(\"The given data does not contain a Collection at %{walked_path}, got '%{type}'\") % { walked_path: walked_path, type: t }\n        error_data = Puppet::DataTypes::Error.new(\n            msg,\n            'SLICE_ERROR',\n            {'walked_path' => walked_path, 'value_type' => t},\n            'EXPECTED_COLLECTION'\n        )\n        raise Puppet::ErrorWithData.new(error_data, msg)\n      end\n\n      walked_path << k\n      if d.is_a?(Array) && !k.is_a?(Integer)\n        t = Puppet::Pops::Types::TypeCalculator.infer(k)\n        msg = _(\"The given data requires an Integer index at %{walked_path}, got '%{type}'\") % { walked_path: walked_path, type: t }\n        error_data = Puppet::DataTypes::Error.new(\n            msg,\n            'SLICE_ERROR',\n            {'walked_path' => walked_path, 'index_type' => t},\n            'EXPECTED_INTEGER_INDEX'\n        )\n        raise Puppet::ErrorWithData.new(error_data, msg)\n      end\n      d[k]\n    end\n  end\nend"
    },
    {
      "name"=>"dig",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/dig.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"dig()",
          "docstring"=>{
            "text"=>"Returns a value for a sequence of given keys/indexes into a structure, such as\nan array or hash.\nThis function is used to \"dig into\" a complex data structure by\nusing a sequence of keys / indexes to access a value from which\nthe next key/index is accessed recursively.\n\nThe first encountered `undef` value or key stops the \"dig\" and `undef` is returned.\n\nAn error is raised if an attempt is made to \"dig\" into\nsomething other than an `undef` (which immediately returns `undef`), an `Array` or a `Hash`.\n\n\n\n**Example:** Using `dig`\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {x => 100, y => 200}]}}\nnotice $data.dig('a', 'b', 1, 'x')\n```\n\nWould notice the value 100.\n\nThis is roughly equivalent to `$data['a']['b'][1]['x']`. However, a standard\nindex will return an error and cause catalog compilation failure if any parent\nof the final key (`'x'`) is `undef`. The `dig` function will return undef,\nrather than failing catalog compilation. This allows you to check if data\nexists in a structure without mandating that it always exists.\n\n* Since 4.5.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns a value for a sequence of given keys/indexes into a structure, such as\nan array or hash.\nThis function is used to \"dig into\" a complex data structure by\nusing a sequence of keys / indexes to access a value from which\nthe next key/index is accessed recursively.\n\nThe first encountered `undef` value or key stops the \"dig\" and `undef` is returned.\n\nAn error is raised if an attempt is made to \"dig\" into\nsomething other than an `undef` (which immediately returns `undef`), an `Array` or a `Hash`.\n\n\n\n**Example:** Using `dig`\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {x => 100, y => 200}]}}\nnotice $data.dig('a', 'b', 1, 'x')\n```\n\nWould notice the value 100.\n\nThis is roughly equivalent to `$data['a']['b'][1]['x']`. However, a standard\nindex will return an error and cause catalog compilation failure if any parent\nof the final key (`'x'`) is `undef`. The `dig` function will return undef,\nrather than failing catalog compilation. This allows you to check if data\nexists in a structure without mandating that it always exists.\n\n* Since 4.5.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :dig,\n  :type => :rvalue,\n  :arity => -1,\n  :doc => <<-DOC\nReturns a value for a sequence of given keys/indexes into a structure, such as\nan array or hash.\nThis function is used to \"dig into\" a complex data structure by\nusing a sequence of keys / indexes to access a value from which\nthe next key/index is accessed recursively.\n\nThe first encountered `undef` value or key stops the \"dig\" and `undef` is returned.\n\nAn error is raised if an attempt is made to \"dig\" into\nsomething other than an `undef` (which immediately returns `undef`), an `Array` or a `Hash`.\n\n\n\n**Example:** Using `dig`\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {x => 100, y => 200}]}}\nnotice $data.dig('a', 'b', 1, 'x')\n```\n\nWould notice the value 100.\n\nThis is roughly equivalent to `$data['a']['b'][1]['x']`. However, a standard\nindex will return an error and cause catalog compilation failure if any parent\nof the final key (`'x'`) is `undef`. The `dig` function will return undef,\nrather than failing catalog compilation. This allows you to check if data\nexists in a structure without mandating that it always exists.\n\n* Since 4.5.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('dig')\nend"
    },
    {
      "name"=>"digest",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/digest.rb",
      "line"=>2,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"digest()",
          "docstring"=>{
            "text"=>"Returns a hash value from a provided string using the digest_algorithm setting from the Puppet config file.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns a hash value from a provided string using the digest_algorithm setting from the Puppet config file.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:digest, :type => :rvalue, :arity => 1, :doc => \"Returns a hash value from a provided string using the digest_algorithm setting from the Puppet config file.\") do |args|\n  algo = Puppet[:digest_algorithm]\n  Puppet::Util::Checksums.method(algo.intern).call args[0]\nend"
    },
    {
      "name"=>"downcase",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/downcase.rb",
      "line"=>46,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"downcase(Numeric $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"downcase(String $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"downcase(Array[StringData] $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array[StringData]"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"downcase(Hash[StringData, StringData] $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[StringData, StringData]"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Converts a String, Array or Hash (recursively) into lower case.\n\nThis function is compatible with the stdlib function with the same name.\n\nThe function does the following:\n* For a `String`, its lower case version is returned. This is done using Ruby system locale which handles some, but not all\n  special international up-casing rules (for example German double-s ß is upcased to \"SS\", whereas upper case double-s\n  is downcased to ß).\n* For `Array` and `Hash` the conversion to lower case is recursive and each key and value must be convertible by\n  this function.\n* When a `Hash` is converted, some keys could result in the same key - in those cases, the\n  latest key-value wins. For example if keys \"aBC\", and \"abC\" where both present, after downcase there would only be one\n  key \"abc\".\n* If the value is `Numeric` it is simply returned (this is for backwards compatibility).\n* An error is raised for all other data types.\n\nPlease note: This function relies directly on Ruby's String implementation and as such may not be entirely UTF8 compatible.\nTo ensure best compatibility please use this function with Ruby 2.4.0 or greater - https://bugs.ruby-lang.org/issues/10085.\n\n```puppet\n'HELLO'.downcase()\ndowncase('HEllO')\n```\nWould both result in \"hello\"\n\n```puppet\n['A', 'B'].downcase()\ndowncase(['A', 'B'])\n```\nWould both result in ['a', 'b']\n\n```puppet\n{'A' => 'HEllO', 'B' => 'GOODBYE'}.downcase()\n```\nWould result in `{'a' => 'hello', 'b' => 'goodbye'}`\n\n```puppet\n['A', 'B', ['C', ['D']], {'X' => 'Y'}].downcase\n```\nWould result in `['a', 'b', ['c', ['d']], {'x' => 'y'}]`",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Converting a String to lower case"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Converting an Array to lower case"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Converting a Hash to lower case"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Converting a recursive structure"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"downcase(Numeric $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"downcase"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"downcase(String $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"downcase"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"downcase(Array[StringData] $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array[StringData]"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"downcase"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"downcase(Hash[StringData, StringData] $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[StringData, StringData]"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"downcase"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:downcase) do\n  local_types do\n    type 'StringData = Variant[String, Numeric, Array[StringData], Hash[StringData, StringData]]'\n  end\n\n  dispatch :on_numeric do\n    param 'Numeric', :arg\n  end\n\n  dispatch :on_string do\n    param 'String', :arg\n  end\n\n  dispatch :on_array do\n    param 'Array[StringData]', :arg\n  end\n\n  dispatch :on_hash do\n    param 'Hash[StringData, StringData]', :arg\n  end\n\n  # unit function - since the old implementation skipped Numeric values\n  def on_numeric(n)\n    n\n  end\n\n  def on_string(s)\n    s.downcase\n  end\n\n  def on_array(a)\n    a.map {|x| do_downcase(x) }\n  end\n\n  def on_hash(h)\n    result = {}\n    h.each_pair {|k,v| result[do_downcase(k)] = do_downcase(v) }\n    result\n  end\n\n  def do_downcase(x)\n    x.is_a?(String) ? x.downcase : call_function('downcase', x)\n  end\nend"
    },
    {
      "name"=>"each",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/each.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"each()",
          "docstring"=>{
            "text"=>"Runs a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nrepeatedly using each value in a data structure, then returns the values unchanged.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array or hash the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n**Example**: Using the `each` function\n\n`$data.each |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`each($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nvalue in turn to the lambda, then returns the original values.\n\n**Example**: Using the `each` function with an array and a one-parameter lambda\n\n~~~ puppet\n# For the array $data, run a lambda that creates a resource for each item.\n$data = [\"routers\", \"servers\", \"workstations\"]\n$data.each |$item| {\n notify { $item:\n   message => $item\n }\n}\n# Puppet creates one resource for each of the three items in $data. Each resource is\n# named after the item's value and uses the item's value in a parameter.\n~~~\n\nWhen the first argument is a hash, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]` and returns the original hash.\n\n**Example**: Using the `each` function with a hash and a one-parameter lambda\n\n~~~ puppet\n# For the hash $data, run a lambda using each item as a key-value array that creates a\n# resource for each item.\n$data = {\"rtr\" => \"Router\", \"svr\" => \"Server\", \"wks\" => \"Workstation\"}\n$data.each |$items| {\n notify { $items[0]:\n   message => $items[1]\n }\n}\n# Puppet creates one resource for each of the three items in $data, each named after the\n# item's key and containing a parameter using the item's value.\n~~~\n\nWhen the first argument is an array and the lambda has two parameters, Puppet passes the\narray's indexes (enumerated from 0) in the first parameter and its values in the second\nparameter.\n\n**Example**: Using the `each` function with an array and a two-parameter lambda\n\n~~~ puppet\n# For the array $data, run a lambda using each item's index and value that creates a\n# resource for each item.\n$data = [\"routers\", \"servers\", \"workstations\"]\n$data.each |$index, $value| {\n notify { $value:\n   message => $index\n }\n}\n# Puppet creates one resource for each of the three items in $data, each named after the\n# item's value and containing a parameter using the item's index.\n~~~\n\nWhen the first argument is a hash, Puppet passes its keys to the first parameter and its\nvalues to the second parameter.\n\n**Example**: Using the `each` function with a hash and a two-parameter lambda\n\n~~~ puppet\n# For the hash $data, run a lambda using each item's key and value to create a resource\n# for each item.\n$data = {\"rtr\" => \"Router\", \"svr\" => \"Server\", \"wks\" => \"Workstation\"}\n$data.each |$key, $value| {\n notify { $key:\n   message => $value\n }\n}\n# Puppet creates one resource for each of the three items in $data, each named after the\n# item's key and containing a parameter using the item's value.\n~~~\n\nFor an example that demonstrates how to create multiple `file` resources using `each`,\nsee the Puppet\n[iteration](https://puppet.com/docs/puppet/latest/lang_iteration.html)\ndocumentation.\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Runs a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nrepeatedly using each value in a data structure, then returns the values unchanged.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array or hash the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n**Example**: Using the `each` function\n\n`$data.each |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`each($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nvalue in turn to the lambda, then returns the original values.\n\n**Example**: Using the `each` function with an array and a one-parameter lambda\n\n~~~ puppet\n# For the array $data, run a lambda that creates a resource for each item.\n$data = [\"routers\", \"servers\", \"workstations\"]\n$data.each |$item| {\n notify { $item:\n   message => $item\n }\n}\n# Puppet creates one resource for each of the three items in $data. Each resource is\n# named after the item's value and uses the item's value in a parameter.\n~~~\n\nWhen the first argument is a hash, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]` and returns the original hash.\n\n**Example**: Using the `each` function with a hash and a one-parameter lambda\n\n~~~ puppet\n# For the hash $data, run a lambda using each item as a key-value array that creates a\n# resource for each item.\n$data = {\"rtr\" => \"Router\", \"svr\" => \"Server\", \"wks\" => \"Workstation\"}\n$data.each |$items| {\n notify { $items[0]:\n   message => $items[1]\n }\n}\n# Puppet creates one resource for each of the three items in $data, each named after the\n# item's key and containing a parameter using the item's value.\n~~~\n\nWhen the first argument is an array and the lambda has two parameters, Puppet passes the\narray's indexes (enumerated from 0) in the first parameter and its values in the second\nparameter.\n\n**Example**: Using the `each` function with an array and a two-parameter lambda\n\n~~~ puppet\n# For the array $data, run a lambda using each item's index and value that creates a\n# resource for each item.\n$data = [\"routers\", \"servers\", \"workstations\"]\n$data.each |$index, $value| {\n notify { $value:\n   message => $index\n }\n}\n# Puppet creates one resource for each of the three items in $data, each named after the\n# item's value and containing a parameter using the item's index.\n~~~\n\nWhen the first argument is a hash, Puppet passes its keys to the first parameter and its\nvalues to the second parameter.\n\n**Example**: Using the `each` function with a hash and a two-parameter lambda\n\n~~~ puppet\n# For the hash $data, run a lambda using each item's key and value to create a resource\n# for each item.\n$data = {\"rtr\" => \"Router\", \"svr\" => \"Server\", \"wks\" => \"Workstation\"}\n$data.each |$key, $value| {\n notify { $key:\n   message => $value\n }\n}\n# Puppet creates one resource for each of the three items in $data, each named after the\n# item's key and containing a parameter using the item's value.\n~~~\n\nFor an example that demonstrates how to create multiple `file` resources using `each`,\nsee the Puppet\n[iteration](https://puppet.com/docs/puppet/latest/lang_iteration.html)\ndocumentation.\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :each,\n  :type => :rvalue,\n  :arity => -3,\n  :doc => <<-DOC\nRuns a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nrepeatedly using each value in a data structure, then returns the values unchanged.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array or hash the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n**Example**: Using the `each` function\n\n`$data.each |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`each($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nvalue in turn to the lambda, then returns the original values.\n\n**Example**: Using the `each` function with an array and a one-parameter lambda\n\n~~~ puppet\n# For the array $data, run a lambda that creates a resource for each item.\n$data = [\"routers\", \"servers\", \"workstations\"]\n$data.each |$item| {\n notify { $item:\n   message => $item\n }\n}\n# Puppet creates one resource for each of the three items in $data. Each resource is\n# named after the item's value and uses the item's value in a parameter.\n~~~\n\nWhen the first argument is a hash, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]` and returns the original hash.\n\n**Example**: Using the `each` function with a hash and a one-parameter lambda\n\n~~~ puppet\n# For the hash $data, run a lambda using each item as a key-value array that creates a\n# resource for each item.\n$data = {\"rtr\" => \"Router\", \"svr\" => \"Server\", \"wks\" => \"Workstation\"}\n$data.each |$items| {\n notify { $items[0]:\n   message => $items[1]\n }\n}\n# Puppet creates one resource for each of the three items in $data, each named after the\n# item's key and containing a parameter using the item's value.\n~~~\n\nWhen the first argument is an array and the lambda has two parameters, Puppet passes the\narray's indexes (enumerated from 0) in the first parameter and its values in the second\nparameter.\n\n**Example**: Using the `each` function with an array and a two-parameter lambda\n\n~~~ puppet\n# For the array $data, run a lambda using each item's index and value that creates a\n# resource for each item.\n$data = [\"routers\", \"servers\", \"workstations\"]\n$data.each |$index, $value| {\n notify { $value:\n   message => $index\n }\n}\n# Puppet creates one resource for each of the three items in $data, each named after the\n# item's value and containing a parameter using the item's index.\n~~~\n\nWhen the first argument is a hash, Puppet passes its keys to the first parameter and its\nvalues to the second parameter.\n\n**Example**: Using the `each` function with a hash and a two-parameter lambda\n\n~~~ puppet\n# For the hash $data, run a lambda using each item's key and value to create a resource\n# for each item.\n$data = {\"rtr\" => \"Router\", \"svr\" => \"Server\", \"wks\" => \"Workstation\"}\n$data.each |$key, $value| {\n notify { $key:\n   message => $value\n }\n}\n# Puppet creates one resource for each of the three items in $data, each named after the\n# item's key and containing a parameter using the item's value.\n~~~\n\nFor an example that demonstrates how to create multiple `file` resources using `each`,\nsee the Puppet\n[iteration](https://puppet.com/docs/puppet/latest/lang_iteration.html)\ndocumentation.\n\n- Since 4.0.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('each')\nend"
    },
    {
      "name"=>"each",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/each.rb",
      "line"=>97,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"each(Hash[Any, Any] $hash, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Any, Any]"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"each(Hash[Any, Any] $hash, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Any, Any]"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"each(Iterable $enumerable, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"each(Iterable $enumerable, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Runs a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nrepeatedly using each value in a data structure, then returns the values unchanged.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array, hash, or other iterable object that the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n`$data.each |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`each($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nvalue in turn to the lambda, then returns the original values.\n\n```puppet\n# For the array $data, run a lambda that creates a resource for each item.\n$data = [\"routers\", \"servers\", \"workstations\"]\n$data.each |$item| {\n notify { $item:\n   message => $item\n }\n}\n# Puppet creates one resource for each of the three items in $data. Each resource is\n# named after the item's value and uses the item's value in a parameter.\n```\n\nWhen the first argument is a hash, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]` and returns the original hash.\n\n```puppet\n# For the hash $data, run a lambda using each item as a key-value array that creates a\n# resource for each item.\n$data = {\"rtr\" => \"Router\", \"svr\" => \"Server\", \"wks\" => \"Workstation\"}\n$data.each |$items| {\n notify { $items[0]:\n   message => $items[1]\n }\n}\n# Puppet creates one resource for each of the three items in $data, each named after the\n# item's key and containing a parameter using the item's value.\n```\n\nWhen the first argument is an array and the lambda has two parameters, Puppet passes the\narray's indexes (enumerated from 0) in the first parameter and its values in the second\nparameter.\n\n```puppet\n# For the array $data, run a lambda using each item's index and value that creates a\n# resource for each item.\n$data = [\"routers\", \"servers\", \"workstations\"]\n$data.each |$index, $value| {\n notify { $value:\n   message => $index\n }\n}\n# Puppet creates one resource for each of the three items in $data, each named after the\n# item's value and containing a parameter using the item's index.\n```\n\nWhen the first argument is a hash, Puppet passes its keys to the first parameter and its\nvalues to the second parameter.\n\n```puppet\n# For the hash $data, run a lambda using each item's key and value to create a resource\n# for each item.\n$data = {\"rtr\" => \"Router\", \"svr\" => \"Server\", \"wks\" => \"Workstation\"}\n$data.each |$key, $value| {\n notify { $key:\n   message => $value\n }\n}\n# Puppet creates one resource for each of the three items in $data, each named after the\n# item's key and containing a parameter using the item's value.\n```\n\nFor an example that demonstrates how to create multiple `file` resources using `each`,\nsee the Puppet\n[iteration](https://puppet.com/docs/puppet/latest/lang_iteration.html)\ndocumentation.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `each` function"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `each` function with an array and a one-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `each` function with a hash and a one-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `each` function with an array and a two-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `each` function with a hash and a two-parameter lambda"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"each(Hash[Any, Any] $hash, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Any, Any]"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"each"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"each(Hash[Any, Any] $hash, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Any, Any]"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"each"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"each(Iterable $enumerable, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"each"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"each(Iterable $enumerable, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"each"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:each) do\n  dispatch :foreach_Hash_2 do\n    param 'Hash[Any, Any]', :hash\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :foreach_Hash_1 do\n    param 'Hash[Any, Any]', :hash\n    block_param 'Callable[1,1]', :block\n  end\n\n  dispatch :foreach_Enumerable_2 do\n    param 'Iterable', :enumerable\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :foreach_Enumerable_1 do\n    param 'Iterable', :enumerable\n    block_param 'Callable[1,1]', :block\n  end\n\n  def foreach_Hash_1(hash)\n    enumerator = hash.each_pair\n    begin\n      hash.size.times do\n        yield(enumerator.next)\n      end\n    rescue StopIteration\n    end\n    # produces the receiver\n    hash\n  end\n\n  def foreach_Hash_2(hash)\n    enumerator = hash.each_pair\n    begin\n      hash.size.times do\n        yield(*enumerator.next)\n      end\n    rescue StopIteration\n    end\n    # produces the receiver\n    hash\n  end\n\n  def foreach_Enumerable_1(enumerable)\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n      begin\n        loop { yield(enum.next) }\n      rescue StopIteration\n      end\n    # produces the receiver\n    enumerable\n  end\n\n  def foreach_Enumerable_2(enumerable)\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n    if enum.hash_style?\n      enum.each { |entry| yield(*entry) }\n    else\n      begin\n        index = 0\n        loop do\n          yield(index, enum.next)\n          index += 1\n        end\n      rescue StopIteration\n      end\n    end\n    # produces the receiver\n    enumerable\n  end\nend"
    },
    {
      "name"=>"emerg",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/emerg.rb",
      "line"=>2,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"emerg(Any *$values)",
          "docstring"=>{
            "text"=>"Logs a message on the server at level `emerg`.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"The values to log.",
                "types"=>[
                  "Any"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Undef"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Logs a message on the server at level `emerg`.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"The values to log.",
            "types"=>[
              "Any"
            ],
            "name"=>"*values"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Undef"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:emerg, Puppet::Functions::InternalFunction) do\n  # @param values The values to log.\n  # @return [Undef]\n  dispatch :emerg do\n    scope_param\n    repeated_param 'Any', :values\n    return_type 'Undef'\n  end\n\n  def emerg(scope, *values)\n    Puppet::Util::Log.log_func(scope, :emerg, values)\n  end\nend"
    },
    {
      "name"=>"empty",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/empty.rb",
      "line"=>24,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"empty(Collection $coll)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Collection"
                ],
                "name"=>"coll"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"empty(String $str)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"str"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"empty(Numeric $num)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"num"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"empty(Binary $bin)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Binary"
                ],
                "name"=>"bin"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"empty(Undef $x)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Undef"
                ],
                "name"=>"x"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns `true` if the given argument is an empty collection of values.\n\nThis function can answer if one of the following is empty:\n* `Array`, `Hash` - having zero entries\n* `String`, `Binary` - having zero length\n\nFor backwards compatibility with the stdlib function with the same name the\nfollowing data types are also accepted by the function instead of raising an error.\nUsing these is deprecated and will raise a warning:\n\n* `Numeric` - `false` is returned for all `Numeric` values.\n* `Undef` - `true` is returned for all `Undef` values.\n\n```puppet\nnotice([].empty)\nnotice(empty([]))\n# would both notice 'true'\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `empty`"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"empty(Collection $coll)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Collection"
                  ],
                  "name"=>"coll"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"empty"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"empty(String $str)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"str"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"empty"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"empty(Numeric $num)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"num"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"empty"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"empty(Binary $bin)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Binary"
                  ],
                  "name"=>"bin"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"empty"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"empty(Undef $x)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Undef"
                  ],
                  "name"=>"x"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"empty"
          },
          {
            "tag_name"=>"since",
            "text"=>"Puppet 5.5.0 - support for Binary"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:empty) do\n  dispatch :collection_empty do\n    param 'Collection', :coll\n  end\n\n  dispatch :string_empty do\n    param 'String', :str\n  end\n\n  dispatch :numeric_empty do\n    param 'Numeric', :num\n  end\n\n  dispatch :binary_empty do\n    param 'Binary', :bin\n  end\n\n  dispatch :undef_empty do\n    param 'Undef', :x\n  end\n\n  def collection_empty(coll)\n    coll.empty?\n  end\n\n  def string_empty(str)\n    str.empty?\n  end\n\n  # For compatibility reasons - return false rather than error on floats and integers\n  # (Yes, it is strange)\n  #\n  def numeric_empty(num)\n    deprecation_warning_for('Numeric')\n    false\n  end\n\n  def binary_empty(bin)\n    bin.length == 0\n  end\n\n  # For compatibility reasons - return true rather than error on undef\n  # (Yes, it is strange, but undef was passed as empty string in 3.x API)\n  #\n  def undef_empty(x)\n    true\n  end\n\n  def deprecation_warning_for(arg_type)\n    file, line = Puppet::Pops::PuppetStack.top_of_stack\n    msg = _(\"Calling function empty() with %{arg_type} value is deprecated.\") % { arg_type: arg_type }\n    Puppet.warn_once('deprecations', \"empty-from-\#{file}-\#{line}\", msg, file, line)\n  end\nend"
    },
    {
      "name"=>"epp",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/epp.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"epp()",
          "docstring"=>{
            "text"=>"Evaluates an Embedded Puppet (EPP) template file and returns the rendered text\nresult as a String.\n\n`epp('<MODULE NAME>/<TEMPLATE FILE>', <PARAMETER HASH>)`\n\nThe first argument to this function should be a `<MODULE NAME>/<TEMPLATE FILE>`\nreference, which loads `<TEMPLATE FILE>` from `<MODULE NAME>`'s `templates`\ndirectory. In most cases, the last argument is optional; if used, it should be a\n[hash](https://puppet.com/docs/puppet/latest/lang_data_hash.html) that contains parameters to\npass to the template.\n\n- See the [template](https://puppet.com/docs/puppet/latest/lang_template.html) documentation\nfor general template usage information.\n- See the [EPP syntax](https://puppet.com/docs/puppet/latest/lang_template_epp.html)\ndocumentation for examples of EPP.\n\nFor example, to call the apache module's `templates/vhost/_docroot.epp`\ntemplate and pass the `docroot` and `virtual_docroot` parameters, call the `epp`\nfunction like this:\n\n`epp('apache/vhost/_docroot.epp', { 'docroot' => '/var/www/html',\n'virtual_docroot' => '/var/www/example' })`\n\nThis function can also accept an absolute path, which can load a template file\nfrom anywhere on disk.\n\nPuppet produces a syntax error if you pass more parameters than are declared in\nthe template's parameter tag. When passing parameters to a template that\ncontains a parameter tag, use the same names as the tag's declared parameters.\n\nParameters are required only if they are declared in the called template's\nparameter tag without default values. Puppet produces an error if the `epp`\nfunction fails to pass any required parameter.\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Evaluates an Embedded Puppet (EPP) template file and returns the rendered text\nresult as a String.\n\n`epp('<MODULE NAME>/<TEMPLATE FILE>', <PARAMETER HASH>)`\n\nThe first argument to this function should be a `<MODULE NAME>/<TEMPLATE FILE>`\nreference, which loads `<TEMPLATE FILE>` from `<MODULE NAME>`'s `templates`\ndirectory. In most cases, the last argument is optional; if used, it should be a\n[hash](https://puppet.com/docs/puppet/latest/lang_data_hash.html) that contains parameters to\npass to the template.\n\n- See the [template](https://puppet.com/docs/puppet/latest/lang_template.html) documentation\nfor general template usage information.\n- See the [EPP syntax](https://puppet.com/docs/puppet/latest/lang_template_epp.html)\ndocumentation for examples of EPP.\n\nFor example, to call the apache module's `templates/vhost/_docroot.epp`\ntemplate and pass the `docroot` and `virtual_docroot` parameters, call the `epp`\nfunction like this:\n\n`epp('apache/vhost/_docroot.epp', { 'docroot' => '/var/www/html',\n'virtual_docroot' => '/var/www/example' })`\n\nThis function can also accept an absolute path, which can load a template file\nfrom anywhere on disk.\n\nPuppet produces a syntax error if you pass more parameters than are declared in\nthe template's parameter tag. When passing parameters to a template that\ncontains a parameter tag, use the same names as the tag's declared parameters.\n\nParameters are required only if they are declared in the called template's\nparameter tag without default values. Puppet produces an error if the `epp`\nfunction fails to pass any required parameter.\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:epp, :type => :rvalue, :arity => -2, :doc =>\n\"Evaluates an Embedded Puppet (EPP) template file and returns the rendered text\nresult as a String.\n\n`epp('<MODULE NAME>/<TEMPLATE FILE>', <PARAMETER HASH>)`\n\nThe first argument to this function should be a `<MODULE NAME>/<TEMPLATE FILE>`\nreference, which loads `<TEMPLATE FILE>` from `<MODULE NAME>`'s `templates`\ndirectory. In most cases, the last argument is optional; if used, it should be a\n[hash](https://puppet.com/docs/puppet/latest/lang_data_hash.html) that contains parameters to\npass to the template.\n\n- See the [template](https://puppet.com/docs/puppet/latest/lang_template.html) documentation\nfor general template usage information.\n- See the [EPP syntax](https://puppet.com/docs/puppet/latest/lang_template_epp.html)\ndocumentation for examples of EPP.\n\nFor example, to call the apache module's `templates/vhost/_docroot.epp`\ntemplate and pass the `docroot` and `virtual_docroot` parameters, call the `epp`\nfunction like this:\n\n`epp('apache/vhost/_docroot.epp', { 'docroot' => '/var/www/html',\n'virtual_docroot' => '/var/www/example' })`\n\nThis function can also accept an absolute path, which can load a template file\nfrom anywhere on disk.\n\nPuppet produces a syntax error if you pass more parameters than are declared in\nthe template's parameter tag. When passing parameters to a template that\ncontains a parameter tag, use the same names as the tag's declared parameters.\n\nParameters are required only if they are declared in the called template's\nparameter tag without default values. Puppet produces an error if the `epp`\nfunction fails to pass any required parameter.\n\n- Since 4.0.0\") do |args|\n\n  Puppet::Parser::Functions::Error.is4x('epp')\nend"
    },
    {
      "name"=>"epp",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/epp.rb",
      "line"=>37,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"epp(String $path, Optional[Hash[Pattern[/^\\w+$/], Any]] $parameters)",
          "docstring"=>{
            "text"=>"Evaluates an Embedded Puppet (EPP) template file and returns the rendered text\nresult as a String.\n\n`epp('<MODULE NAME>/<TEMPLATE FILE>', <PARAMETER HASH>)`\n\nThe first argument to this function should be a `<MODULE NAME>/<TEMPLATE FILE>`\nreference, which loads `<TEMPLATE FILE>` from `<MODULE NAME>`'s `templates`\ndirectory. In most cases, the last argument is optional; if used, it should be a\n[hash](https://puppet.com/docs/puppet/latest/lang_data_hash.html) that contains parameters to\npass to the template.\n\n- See the [template](https://puppet.com/docs/puppet/latest/lang_template.html)\ndocumentation for general template usage information.\n- See the [EPP syntax](https://puppet.com/docs/puppet/latest/lang_template_epp.html)\ndocumentation for examples of EPP.\n\nFor example, to call the apache module's `templates/vhost/_docroot.epp`\ntemplate and pass the `docroot` and `virtual_docroot` parameters, call the `epp`\nfunction like this:\n\n`epp('apache/vhost/_docroot.epp', { 'docroot' => '/var/www/html',\n'virtual_docroot' => '/var/www/example' })`\n\nThis function can also accept an absolute path, which can load a template file\nfrom anywhere on disk.\n\nPuppet produces a syntax error if you pass more parameters than are declared in\nthe template's parameter tag. When passing parameters to a template that\ncontains a parameter tag, use the same names as the tag's declared parameters.\n\nParameters are required only if they are declared in the called template's\nparameter tag without default values. Puppet produces an error if the `epp`\nfunction fails to pass any required parameter.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"path"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Hash[Pattern[/^\\w+$/], Any]]"
                ],
                "name"=>"parameters"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Variant[String, Sensitive[String]]"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Evaluates an Embedded Puppet (EPP) template file and returns the rendered text\nresult as a String.\n\n`epp('<MODULE NAME>/<TEMPLATE FILE>', <PARAMETER HASH>)`\n\nThe first argument to this function should be a `<MODULE NAME>/<TEMPLATE FILE>`\nreference, which loads `<TEMPLATE FILE>` from `<MODULE NAME>`'s `templates`\ndirectory. In most cases, the last argument is optional; if used, it should be a\n[hash](https://puppet.com/docs/puppet/latest/lang_data_hash.html) that contains parameters to\npass to the template.\n\n- See the [template](https://puppet.com/docs/puppet/latest/lang_template.html)\ndocumentation for general template usage information.\n- See the [EPP syntax](https://puppet.com/docs/puppet/latest/lang_template_epp.html)\ndocumentation for examples of EPP.\n\nFor example, to call the apache module's `templates/vhost/_docroot.epp`\ntemplate and pass the `docroot` and `virtual_docroot` parameters, call the `epp`\nfunction like this:\n\n`epp('apache/vhost/_docroot.epp', { 'docroot' => '/var/www/html',\n'virtual_docroot' => '/var/www/example' })`\n\nThis function can also accept an absolute path, which can load a template file\nfrom anywhere on disk.\n\nPuppet produces a syntax error if you pass more parameters than are declared in\nthe template's parameter tag. When passing parameters to a template that\ncontains a parameter tag, use the same names as the tag's declared parameters.\n\nParameters are required only if they are declared in the called template's\nparameter tag without default values. Puppet produces an error if the `epp`\nfunction fails to pass any required parameter.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "String"
            ],
            "name"=>"path"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Hash[Pattern[/^\\w+$/], Any]]"
            ],
            "name"=>"parameters"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Variant[String, Sensitive[String]]"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:epp, Puppet::Functions::InternalFunction) do\n\n  dispatch :epp do\n    scope_param\n    param 'String', :path\n    optional_param 'Hash[Pattern[/^\\w+$/], Any]', :parameters\n    return_type 'Variant[String, Sensitive[String]]'\n  end\n\n  def epp(scope, path, parameters = nil)\n    Puppet::Pops::Evaluator::EppEvaluator.epp(scope, path, scope.compiler.environment, parameters)\n  end\nend"
    },
    {
      "name"=>"err",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/err.rb",
      "line"=>2,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"err(Any *$values)",
          "docstring"=>{
            "text"=>"Logs a message on the server at level `err`.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"The values to log.",
                "types"=>[
                  "Any"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Undef"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Logs a message on the server at level `err`.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"The values to log.",
            "types"=>[
              "Any"
            ],
            "name"=>"*values"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Undef"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:err, Puppet::Functions::InternalFunction) do\n  # @param values The values to log.\n  # @return [Undef]\n  dispatch :err do\n    scope_param\n    repeated_param 'Any', :values\n    return_type 'Undef'\n  end\n\n  def err(scope, *values)\n    Puppet::Util::Log.log_func(scope, :err, values)\n  end\nend"
    },
    {
      "name"=>"eyaml_lookup_key",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/eyaml_lookup_key.rb",
      "line"=>7,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"eyaml_lookup_key(String[1] $key, Hash[String[1],Any] $options, Puppet::LookupContext $context)",
          "docstring"=>{
            "text"=>"The `eyaml_lookup_key` is a hiera 5 `lookup_key` data provider function.\nSee [the configuration guide documentation](https://puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#configuring-a-hierarchy-level-hiera-eyaml) for\nhow to use this function.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String[1]"
                ],
                "name"=>"key"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[String[1],Any]"
                ],
                "name"=>"options"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Puppet::LookupContext"
                ],
                "name"=>"context"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"The `eyaml_lookup_key` is a hiera 5 `lookup_key` data provider function.\nSee [the configuration guide documentation](https://puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#configuring-a-hierarchy-level-hiera-eyaml) for\nhow to use this function.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "String[1]"
            ],
            "name"=>"key"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Hash[String[1],Any]"
            ],
            "name"=>"options"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Puppet::LookupContext"
            ],
            "name"=>"context"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"5.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:eyaml_lookup_key) do\n  unless Puppet.features.hiera_eyaml?\n    raise Puppet::DataBinding::LookupError, 'Lookup using eyaml lookup_key function is only supported when the hiera_eyaml library is present'\n  end\n\n  require 'hiera/backend/eyaml/encryptor'\n  require 'hiera/backend/eyaml/utils'\n  require 'hiera/backend/eyaml/options'\n  require 'hiera/backend/eyaml/parser/parser'\n\n  dispatch :eyaml_lookup_key do\n    param 'String[1]', :key\n    param 'Hash[String[1],Any]', :options\n    param 'Puppet::LookupContext', :context\n  end\n\n  def eyaml_lookup_key(key, options, context)\n    return context.cached_value(key) if context.cache_has_key(key)\n\n    # Can't do this with an argument_mismatch dispatcher since there is no way to declare a struct that at least\n    # contains some keys but may contain other arbitrary keys.\n    unless options.include?('path')\n      #TRANSLATORS 'eyaml_lookup_key':, 'path', 'paths' 'glob', 'globs', 'mapped_paths', and lookup_key should not be translated\n      raise ArgumentError,\n        _(\"'eyaml_lookup_key': one of 'path', 'paths' 'glob', 'globs' or 'mapped_paths' must be declared in hiera.yaml\"\\\n              \" when using this lookup_key function\")\n    end\n\n    # nil key is used to indicate that the cache contains the raw content of the eyaml file\n    raw_data = context.cached_value(nil)\n    if raw_data.nil?\n      raw_data = load_data_hash(options, context)\n      context.cache(nil, raw_data)\n    end\n    context.not_found unless raw_data.include?(key)\n    context.cache(key, decrypt_value(raw_data[key], context, options, key))\n  end\n\n  def load_data_hash(options, context)\n    path = options['path']\n    context.cached_file_data(path) do |content|\n      begin\n        data = Puppet::Util::Yaml.safe_load(content, [Symbol], path)\n        if data.is_a?(Hash)\n          Puppet::Pops::Lookup::HieraConfig.symkeys_to_string(data)\n        else\n          msg = _(\"%{path}: file does not contain a valid yaml hash\") % { path: path }\n          raise Puppet::DataBinding::LookupError, msg if Puppet[:strict] == :error && data != false\n          Puppet.warning(msg)\n          {}\n        end\n      rescue Puppet::Util::Yaml::YamlLoadError => ex\n        # YamlLoadErrors include the absolute path to the file, so no need to add that\n        raise Puppet::DataBinding::LookupError, _(\"Unable to parse %{message}\") % { message: ex.message }\n      end\n    end\n  end\n\n  def decrypt_value(value, context, options, key)\n    case value\n    when String\n      decrypt(value, context, options, key)\n    when Hash\n      result = {}\n      value.each_pair { |k, v| result[context.interpolate(k)] = decrypt_value(v, context, options, key) }\n      result\n    when Array\n      value.map { |v| decrypt_value(v, context, options, key) }\n    else\n      value\n    end\n  end\n\n  def decrypt(data, context, options, key)\n    if encrypted?(data)\n      # Options must be set prior to each call to #parse since they end up as static variables in\n      # the Options class. They cannot be set once before #decrypt_value is called, since each #decrypt\n      # might cause a new lookup through interpolation. That lookup in turn, might use a different eyaml\n      # config.\n      #\n      Hiera::Backend::Eyaml::Options.set(options)\n      begin\n        tokens = Hiera::Backend::Eyaml::Parser::ParserFactory.hiera_backend_parser.parse(data)\n        data = tokens.map(&:to_plain_text).join.chomp\n      rescue StandardError => ex\n        raise Puppet::DataBinding::LookupError,\n          _(\"hiera-eyaml backend error decrypting %{data} when looking up %{key} in %{path}. Error was %{message}\") % { data: data, key: key, path: options['path'], message: ex.message }\n      end\n    end\n    context.interpolate(data)\n  end\n\n  def encrypted?(data)\n    /.*ENC\\[.*?\\]/ =~ data ? true : false\n  end\nend"
    },
    {
      "name"=>"fail",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/fail.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"fail()",
          "docstring"=>{
            "text"=>"Fail with a parse error. Any parameters will be stringified,\nconcatenated, and passed to the exception-handler.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Fail with a parse error. Any parameters will be stringified,\nconcatenated, and passed to the exception-handler.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n    :fail,\n    :arity => -1,\n    :doc   => <<DOC\nFail with a parse error. Any parameters will be stringified,\nconcatenated, and passed to the exception-handler.\nDOC\n) do |vals|\n    vals = vals.collect { |s| s.to_s }.join(\" \") if vals.is_a? Array\n    raise Puppet::ParseError, vals.to_s\nend"
    },
    {
      "name"=>"file",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/file.rb",
      "line"=>3,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"file()",
          "docstring"=>{
            "text"=>"Loads a file from a module and returns its contents as a string.\n\nThe argument to this function should be a `<MODULE NAME>/<FILE>`\nreference, which will load `<FILE>` from a module's `files`\ndirectory. (For example, the reference `mysql/mysqltuner.pl` will load the\nfile `<MODULES DIRECTORY>/mysql/files/mysqltuner.pl`.)\n\nThis function can also accept:\n\n* An absolute path, which can load a file from anywhere on disk.\n* Multiple arguments, which will return the contents of the **first** file\nfound, skipping any files that don't exist.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Loads a file from a module and returns its contents as a string.\n\nThe argument to this function should be a `<MODULE NAME>/<FILE>`\nreference, which will load `<FILE>` from a module's `files`\ndirectory. (For example, the reference `mysql/mysqltuner.pl` will load the\nfile `<MODULES DIRECTORY>/mysql/files/mysqltuner.pl`.)\n\nThis function can also accept:\n\n* An absolute path, which can load a file from anywhere on disk.\n* Multiple arguments, which will return the contents of the **first** file\nfound, skipping any files that don't exist.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :file, :arity => -2, :type => :rvalue,\n  :doc => \"Loads a file from a module and returns its contents as a string.\n\n  The argument to this function should be a `<MODULE NAME>/<FILE>`\n  reference, which will load `<FILE>` from a module's `files`\n  directory. (For example, the reference `mysql/mysqltuner.pl` will load the\n  file `<MODULES DIRECTORY>/mysql/files/mysqltuner.pl`.)\n\n  This function can also accept:\n\n  * An absolute path, which can load a file from anywhere on disk.\n  * Multiple arguments, which will return the contents of the **first** file\n  found, skipping any files that don't exist.\n  \"\n) do |vals|\n    path = nil\n    vals.each do |file|\n      found = Puppet::Parser::Files.find_file(file, compiler.environment)\n      if found && Puppet::FileSystem.exist?(found)\n        path = found\n        break\n      end\n    end\n\n    if path\n      Puppet::FileSystem.read_preserve_line_endings(path)\n    else\n      raise Puppet::ParseError, _(\"Could not find any files from %{values}\") % { values: vals.join(\", \") }\n    end\nend"
    },
    {
      "name"=>"filter",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/filter.rb",
      "line"=>73,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"filter(Hash[Any, Any] $hash, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Any, Any]"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"filter(Hash[Any, Any] $hash, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Any, Any]"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"filter(Iterable $enumerable, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"filter(Iterable $enumerable, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Applies a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nto every value in a data structure and returns an array or hash containing any elements\nfor which the lambda evaluates to a truthy value (not `false` or `undef`).\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array, hash, or other iterable object that the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n`$filtered_data = $data.filter |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`$filtered_data = filter($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nvalue in turn to the lambda and returns an array containing the results.\n\n```puppet\n# For the array $data, return an array containing the values that end with \"berry\"\n$data = [\"orange\", \"blueberry\", \"raspberry\"]\n$filtered_data = $data.filter |$items| { $items =~ /berry$/ }\n# $filtered_data = [blueberry, raspberry]\n```\n\nWhen the first argument is a hash, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]` and returns a hash containing the results.\n\n```puppet\n# For the hash $data, return a hash containing all values of keys that end with \"berry\"\n$data = { \"orange\" => 0, \"blueberry\" => 1, \"raspberry\" => 2 }\n$filtered_data = $data.filter |$items| { $items[0] =~ /berry$/ }\n# $filtered_data = {blueberry => 1, raspberry => 2}\n```\n\nWhen the first argument is an array and the lambda has two parameters, Puppet passes the\narray's indexes (enumerated from 0) in the first parameter and its values in the second\nparameter.\n\n```puppet\n# For the array $data, return an array of all keys that both end with \"berry\" and have\n# an even-numbered index\n$data = [\"orange\", \"blueberry\", \"raspberry\"]\n$filtered_data = $data.filter |$indexes, $values| { $indexes % 2 == 0 and $values =~ /berry$/ }\n# $filtered_data = [raspberry]\n```\n\nWhen the first argument is a hash, Puppet passes its keys to the first parameter and its\nvalues to the second parameter.\n\n```puppet\n# For the hash $data, return a hash of all keys that both end with \"berry\" and have\n# values less than or equal to 1\n$data = { \"orange\" => 0, \"blueberry\" => 1, \"raspberry\" => 2 }\n$filtered_data = $data.filter |$keys, $values| { $keys =~ /berry$/ and $values <= 1 }\n# $filtered_data = {blueberry => 1}\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `filter` function"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `filter` function with an array and a one-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `filter` function with a hash and a one-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `filter` function with an array and a two-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `filter` function with a hash and a two-parameter lambda"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"filter(Hash[Any, Any] $hash, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Any, Any]"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"filter"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"filter(Hash[Any, Any] $hash, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Any, Any]"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"filter"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"filter(Iterable $enumerable, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"filter"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"filter(Iterable $enumerable, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"filter"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          },
          {
            "tag_name"=>"since",
            "text"=>"6.0.0 does not filter if truthy value is returned from block"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:filter) do\n  dispatch :filter_Hash_2 do\n    param 'Hash[Any, Any]', :hash\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :filter_Hash_1 do\n    param 'Hash[Any, Any]', :hash\n    block_param 'Callable[1,1]', :block\n  end\n\n  dispatch :filter_Enumerable_2 do\n    param 'Iterable', :enumerable\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :filter_Enumerable_1 do\n    param 'Iterable', :enumerable\n    block_param 'Callable[1,1]', :block\n  end\n\n  def filter_Hash_1(hash)\n    result = hash.select {|x, y| yield([x, y]) }\n    # Ruby 1.8.7 returns Array\n    result = Hash[result] unless result.is_a? Hash\n    result\n  end\n\n  def filter_Hash_2(hash)\n    result = hash.select {|x, y| yield(x, y) }\n    # Ruby 1.8.7 returns Array\n    result = Hash[result] unless result.is_a? Hash\n    result\n  end\n\n  def filter_Enumerable_1(enumerable)\n    result = []\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n    begin\n      loop do\n        it = enum.next\n        if yield(it)\n          result << it\n        end\n      end\n    rescue StopIteration\n    end\n    result\n  end\n\n  def filter_Enumerable_2(enumerable)\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n    if enum.hash_style?\n      result = {}\n      enum.each { |k, v| result[k] = v if yield(k, v) }\n      result\n    else\n      result = []\n      begin\n        index = 0\n        loop do\n          it = enum.next\n          if yield(index, it)\n            result << it\n          end\n          index += 1\n        end\n      rescue StopIteration\n      end\n      result\n    end\n  end\nend"
    },
    {
      "name"=>"filter",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/filter.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"filter()",
          "docstring"=>{
            "text"=>"Applies a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nto every value in a data structure and returns an array or hash containing any elements\nfor which the lambda evaluates to a truthy value (not `false` or `undef`).\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array or hash the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n**Example**: Using the `filter` function\n\n`$filtered_data = $data.filter |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`$filtered_data = filter($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nvalue in turn to the lambda and returns an array containing the results.\n\n**Example**: Using the `filter` function with an array and a one-parameter lambda\n\n~~~ puppet\n# For the array $data, return an array containing the values that end with \"berry\"\n$data = [\"orange\", \"blueberry\", \"raspberry\"]\n$filtered_data = $data.filter |$items| { $items =~ /berry$/ }\n# $filtered_data = [blueberry, raspberry]\n~~~\n\nWhen the first argument is a hash, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]` and returns a hash containing the results.\n\n**Example**: Using the `filter` function with a hash and a one-parameter lambda\n\n~~~ puppet\n# For the hash $data, return a hash containing all values of keys that end with \"berry\"\n$data = { \"orange\" => 0, \"blueberry\" => 1, \"raspberry\" => 2 }\n$filtered_data = $data.filter |$items| { $items[0] =~ /berry$/ }\n# $filtered_data = {blueberry => 1, raspberry => 2}\n~~~\n\nWhen the first argument is an array and the lambda has two parameters, Puppet passes the\narray's indexes (enumerated from 0) in the first parameter and its values in the second\nparameter.\n\n**Example**: Using the `filter` function with an array and a two-parameter lambda\n\n~~~ puppet\n# For the array $data, return an array of all keys that both end with \"berry\" and have\n# an even-numbered index\n$data = [\"orange\", \"blueberry\", \"raspberry\"]\n$filtered_data = $data.filter |$indexes, $values| { $indexes % 2 == 0 and $values =~ /berry$/ }\n# $filtered_data = [raspberry]\n~~~\n\nWhen the first argument is a hash, Puppet passes its keys to the first parameter and its\nvalues to the second parameter.\n\n**Example**: Using the `filter` function with a hash and a two-parameter lambda\n\n~~~ puppet\n# For the hash $data, return a hash of all keys that both end with \"berry\" and have\n# values less than or equal to 1\n$data = { \"orange\" => 0, \"blueberry\" => 1, \"raspberry\" => 2 }\n$filtered_data = $data.filter |$keys, $values| { $keys =~ /berry$/ and $values <= 1 }\n# $filtered_data = {blueberry => 1}\n~~~\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Applies a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nto every value in a data structure and returns an array or hash containing any elements\nfor which the lambda evaluates to a truthy value (not `false` or `undef`).\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array or hash the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n**Example**: Using the `filter` function\n\n`$filtered_data = $data.filter |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`$filtered_data = filter($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nvalue in turn to the lambda and returns an array containing the results.\n\n**Example**: Using the `filter` function with an array and a one-parameter lambda\n\n~~~ puppet\n# For the array $data, return an array containing the values that end with \"berry\"\n$data = [\"orange\", \"blueberry\", \"raspberry\"]\n$filtered_data = $data.filter |$items| { $items =~ /berry$/ }\n# $filtered_data = [blueberry, raspberry]\n~~~\n\nWhen the first argument is a hash, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]` and returns a hash containing the results.\n\n**Example**: Using the `filter` function with a hash and a one-parameter lambda\n\n~~~ puppet\n# For the hash $data, return a hash containing all values of keys that end with \"berry\"\n$data = { \"orange\" => 0, \"blueberry\" => 1, \"raspberry\" => 2 }\n$filtered_data = $data.filter |$items| { $items[0] =~ /berry$/ }\n# $filtered_data = {blueberry => 1, raspberry => 2}\n~~~\n\nWhen the first argument is an array and the lambda has two parameters, Puppet passes the\narray's indexes (enumerated from 0) in the first parameter and its values in the second\nparameter.\n\n**Example**: Using the `filter` function with an array and a two-parameter lambda\n\n~~~ puppet\n# For the array $data, return an array of all keys that both end with \"berry\" and have\n# an even-numbered index\n$data = [\"orange\", \"blueberry\", \"raspberry\"]\n$filtered_data = $data.filter |$indexes, $values| { $indexes % 2 == 0 and $values =~ /berry$/ }\n# $filtered_data = [raspberry]\n~~~\n\nWhen the first argument is a hash, Puppet passes its keys to the first parameter and its\nvalues to the second parameter.\n\n**Example**: Using the `filter` function with a hash and a two-parameter lambda\n\n~~~ puppet\n# For the hash $data, return a hash of all keys that both end with \"berry\" and have\n# values less than or equal to 1\n$data = { \"orange\" => 0, \"blueberry\" => 1, \"raspberry\" => 2 }\n$filtered_data = $data.filter |$keys, $values| { $keys =~ /berry$/ and $values <= 1 }\n# $filtered_data = {blueberry => 1}\n~~~\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :filter,\n  :type => :rvalue,\n  :arity => -3,\n  :doc => <<-DOC\nApplies a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nto every value in a data structure and returns an array or hash containing any elements\nfor which the lambda evaluates to a truthy value (not `false` or `undef`).\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array or hash the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n**Example**: Using the `filter` function\n\n`$filtered_data = $data.filter |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`$filtered_data = filter($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nvalue in turn to the lambda and returns an array containing the results.\n\n**Example**: Using the `filter` function with an array and a one-parameter lambda\n\n~~~ puppet\n# For the array $data, return an array containing the values that end with \"berry\"\n$data = [\"orange\", \"blueberry\", \"raspberry\"]\n$filtered_data = $data.filter |$items| { $items =~ /berry$/ }\n# $filtered_data = [blueberry, raspberry]\n~~~\n\nWhen the first argument is a hash, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]` and returns a hash containing the results.\n\n**Example**: Using the `filter` function with a hash and a one-parameter lambda\n\n~~~ puppet\n# For the hash $data, return a hash containing all values of keys that end with \"berry\"\n$data = { \"orange\" => 0, \"blueberry\" => 1, \"raspberry\" => 2 }\n$filtered_data = $data.filter |$items| { $items[0] =~ /berry$/ }\n# $filtered_data = {blueberry => 1, raspberry => 2}\n~~~\n\nWhen the first argument is an array and the lambda has two parameters, Puppet passes the\narray's indexes (enumerated from 0) in the first parameter and its values in the second\nparameter.\n\n**Example**: Using the `filter` function with an array and a two-parameter lambda\n\n~~~ puppet\n# For the array $data, return an array of all keys that both end with \"berry\" and have\n# an even-numbered index\n$data = [\"orange\", \"blueberry\", \"raspberry\"]\n$filtered_data = $data.filter |$indexes, $values| { $indexes % 2 == 0 and $values =~ /berry$/ }\n# $filtered_data = [raspberry]\n~~~\n\nWhen the first argument is a hash, Puppet passes its keys to the first parameter and its\nvalues to the second parameter.\n\n**Example**: Using the `filter` function with a hash and a two-parameter lambda\n\n~~~ puppet\n# For the hash $data, return a hash of all keys that both end with \"berry\" and have\n# values less than or equal to 1\n$data = { \"orange\" => 0, \"blueberry\" => 1, \"raspberry\" => 2 }\n$filtered_data = $data.filter |$keys, $values| { $keys =~ /berry$/ and $values <= 1 }\n# $filtered_data = {blueberry => 1}\n~~~\n\n- Since 4.0.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('filter')\nend"
    },
    {
      "name"=>"find_file",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/find_file.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"find_file()",
          "docstring"=>{
            "text"=>"Finds an existing file from a module and returns its path.\n\nThe argument to this function should be a String as a `<MODULE NAME>/<FILE>`\nreference, which will search for `<FILE>` relative to a module's `files`\ndirectory. (For example, the reference `mysql/mysqltuner.pl` will search for the\nfile `<MODULES DIRECTORY>/mysql/files/mysqltuner.pl`.)\n\nThis function can also accept:\n\n* An absolute String path, which will check for the existence of a file from anywhere on disk.\n* Multiple String arguments, which will return the path of the **first** file\n  found, skipping non existing files.\n* An array of string paths, which will return the path of the **first** file\n  found from the given paths in the array, skipping non existing files.\n\nThe function returns `undef` if none of the given paths were found\n\n- since 4.8.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Finds an existing file from a module and returns its path.\n\nThe argument to this function should be a String as a `<MODULE NAME>/<FILE>`\nreference, which will search for `<FILE>` relative to a module's `files`\ndirectory. (For example, the reference `mysql/mysqltuner.pl` will search for the\nfile `<MODULES DIRECTORY>/mysql/files/mysqltuner.pl`.)\n\nThis function can also accept:\n\n* An absolute String path, which will check for the existence of a file from anywhere on disk.\n* Multiple String arguments, which will return the path of the **first** file\n  found, skipping non existing files.\n* An array of string paths, which will return the path of the **first** file\n  found from the given paths in the array, skipping non existing files.\n\nThe function returns `undef` if none of the given paths were found\n\n- since 4.8.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :find_file,\n  :type => :rvalue,\n  :arity => -2,\n:doc => <<-DOC\nFinds an existing file from a module and returns its path.\n\nThe argument to this function should be a String as a `<MODULE NAME>/<FILE>`\nreference, which will search for `<FILE>` relative to a module's `files`\ndirectory. (For example, the reference `mysql/mysqltuner.pl` will search for the\nfile `<MODULES DIRECTORY>/mysql/files/mysqltuner.pl`.)\n\nThis function can also accept:\n\n* An absolute String path, which will check for the existence of a file from anywhere on disk.\n* Multiple String arguments, which will return the path of the **first** file\n  found, skipping non existing files.\n* An array of string paths, which will return the path of the **first** file\n  found from the given paths in the array, skipping non existing files.\n\nThe function returns `undef` if none of the given paths were found\n\n- since 4.8.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('find_file')\nend"
    },
    {
      "name"=>"find_file",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/find_file.rb",
      "line"=>20,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"find_file(String *$paths)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"*paths"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"find_file(Array[String] *$paths_array)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array[String]"
                ],
                "name"=>"*paths_array"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Finds an existing file from a module and returns its path.\n\nThis function accepts an argument that is a String as a `<MODULE NAME>/<FILE>`\nreference, which searches for `<FILE>` relative to a module's `files`\ndirectory. (For example, the reference `mysql/mysqltuner.pl` will search for the\nfile `<MODULES DIRECTORY>/mysql/files/mysqltuner.pl`.)\n\nThis function can also accept:\n\n* An absolute String path, which checks for the existence of a file from anywhere on disk.\n* Multiple String arguments, which returns the path of the **first** file\n  found, skipping nonexistent files.\n* An array of string paths, which returns the path of the **first** file\n  found from the given paths in the array, skipping nonexistent files.\n\nThe function returns `undef` if none of the given paths were found.",
        "tags"=>[
          {
            "tag_name"=>"overload",
            "signature"=>"find_file(String *$paths)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"*paths"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"find_file"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"find_file(Array[String] *$paths_array)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array[String]"
                  ],
                  "name"=>"*paths_array"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"find_file"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.8.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:find_file, Puppet::Functions::InternalFunction) do\n  dispatch :find_file do\n    scope_param\n    repeated_param 'String', :paths\n  end\n\n  dispatch :find_file_array do\n    scope_param\n    repeated_param 'Array[String]', :paths_array\n  end\n\n  def find_file_array(scope, array)\n    find_file(scope, *array)\n  end\n\n  def find_file(scope, *args)\n    args.each do |file|\n      found = Puppet::Parser::Files.find_file(file, scope.compiler.environment)\n      if found && Puppet::FileSystem.exist?(found)\n        return found\n      end\n    end\n    nil\n  end\nend"
    },
    {
      "name"=>"find_template",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/find_template.rb",
      "line"=>39,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"find_template(String *$paths)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"*paths"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"find_template(Array[String] *$paths_array)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array[String]"
                ],
                "name"=>"*paths_array"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Finds an existing template from a module and returns its path.\n\nThis function accepts an argument that is a String as a `<MODULE NAME>/<TEMPLATE>`\nreference, which searches for `<TEMPLATE>` relative to a module's `templates`\ndirectory on the master. (For example, the reference `mymod/secret.conf.epp`\nwill search for the file `<MODULES DIRECTORY>/mymod/templates/secret.conf.epp`.)\n\nThe primary use case is for agent-side template rendering with late-bound variables\nresolved, such as from secret stores inaccessible to the master, such as\n\n```\n$variables = {\n  'password' => Deferred('vault_lookup::lookup',\n                  ['secret/mymod', 'https://vault.example.com:8200']),\n}\n\n# compile the template source into the catalog\nfile { '/etc/secrets.conf':\n  ensure  => file,\n  content => Deferred('inline_epp',\n               [find_template('mymod/secret.conf.epp').file, $variables]),\n}\n```\n\n\n\nThis function can also accept:\n\n* An absolute String path, which checks for the existence of a template from anywhere on disk.\n* Multiple String arguments, which returns the path of the **first** template\n  found, skipping nonexistent files.\n* An array of string paths, which returns the path of the **first** template\n  found from the given paths in the array, skipping nonexistent files.\n\nThe function returns `undef` if none of the given paths were found.",
        "tags"=>[
          {
            "tag_name"=>"overload",
            "signature"=>"find_template(String *$paths)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"*paths"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"find_template"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"find_template(Array[String] *$paths_array)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array[String]"
                  ],
                  "name"=>"*paths_array"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"find_template"
          },
          {
            "tag_name"=>"since",
            "text"=>"6.x"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:find_template, Puppet::Functions::InternalFunction) do\n  dispatch :find_template do\n    scope_param\n    repeated_param 'String', :paths\n  end\n\n  dispatch :find_template_array do\n    scope_param\n    repeated_param 'Array[String]', :paths_array\n  end\n\n  def find_template_array(scope, array)\n    find_template(scope, *array)\n  end\n\n  def find_template(scope, *args)\n    args.each do |file|\n      found = Puppet::Parser::Files.find_template(file, scope.compiler.environment)\n      if found && Puppet::FileSystem.exist?(found)\n        return found\n      end\n    end\n    nil\n  end\nend"
    },
    {
      "name"=>"flatten",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/flatten.rb",
      "line"=>56,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"flatten(Any *$args)",
          "docstring"=>{
            "text"=>"Returns a flat Array produced from its possibly deeply nested given arguments.\n\nOne or more arguments of any data type can be given to this function.\nThe result is always a flat array representation where any nested arrays are recursively flattened.\n\n```puppet\nflatten(['a', ['b', ['c']]])\n# Would return: ['a','b','c']\n```\n\nTo flatten other kinds of iterables (for example hashes, or intermediate results like from a `reverse_each`)\nfirst convert the result to an array using `Array($x)`, or `$x.convert_to(Array)`. See the `new` function\nfor details and options when performing a conversion.\n\n```puppet\n$hsh = { a => 1, b => 2}\n\n# -- without conversion\n$hsh.flatten()\n# Would return [{a => 1, b => 2}]\n\n# -- with conversion\n$hsh.convert_to(Array).flatten()\n# Would return [a,1,b,2]\n\nflatten(Array($hsh))\n# Would also return [a,1,b,2]\n```\n\n```puppet\n$a1 = [1, [2, 3]]\n$a2 = [[4,[5,6]]\n$x = 7\nflatten($a1, $a2, $x)\n# would return [1,2,3,4,5,6,7]\n```\n\n```puppet\nflatten(42)\n# Would return [42]\n\nflatten([42])\n# Would also return [42]\n```",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Typical use of `flatten()`"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Flattening a Hash"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Flattening and concatenating at the same time"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Transforming to Array if not already an Array"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"*args"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns a flat Array produced from its possibly deeply nested given arguments.\n\nOne or more arguments of any data type can be given to this function.\nThe result is always a flat array representation where any nested arrays are recursively flattened.\n\n```puppet\nflatten(['a', ['b', ['c']]])\n# Would return: ['a','b','c']\n```\n\nTo flatten other kinds of iterables (for example hashes, or intermediate results like from a `reverse_each`)\nfirst convert the result to an array using `Array($x)`, or `$x.convert_to(Array)`. See the `new` function\nfor details and options when performing a conversion.\n\n```puppet\n$hsh = { a => 1, b => 2}\n\n# -- without conversion\n$hsh.flatten()\n# Would return [{a => 1, b => 2}]\n\n# -- with conversion\n$hsh.convert_to(Array).flatten()\n# Would return [a,1,b,2]\n\nflatten(Array($hsh))\n# Would also return [a,1,b,2]\n```\n\n```puppet\n$a1 = [1, [2, 3]]\n$a2 = [[4,[5,6]]\n$x = 7\nflatten($a1, $a2, $x)\n# would return [1,2,3,4,5,6,7]\n```\n\n```puppet\nflatten(42)\n# Would return [42]\n\nflatten([42])\n# Would also return [42]\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Typical use of `flatten()`"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Flattening a Hash"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Flattening and concatenating at the same time"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Transforming to Array if not already an Array"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Any"
            ],
            "name"=>"*args"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"5.5.0 support for flattening and concatenating at the same time"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:flatten) do\n  dispatch :flatten_args do\n    repeated_param 'Any', :args\n  end\n\n  def flatten_args(*args)\n    args.flatten()\n  end\nend"
    },
    {
      "name"=>"floor",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/floor.rb",
      "line"=>12,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"floor(Numeric $val)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"val"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"floor(String $val)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"val"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns the largest `Integer` less or equal to the argument.\nTakes a single numeric value as an argument.\n\nThis function is backwards compatible with the same function in stdlib\nand accepts a `Numeric` value. A `String` that can be converted\nto a floating point number can also be used in this version - but this\nis deprecated.\n\nIn general convert string input to `Numeric` before calling this function\nto have full control over how the conversion is done.",
        "tags"=>[
          {
            "tag_name"=>"overload",
            "signature"=>"floor(Numeric $val)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"val"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"floor"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"floor(String $val)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"val"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"floor"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:floor) do\n  dispatch :on_numeric do\n    param 'Numeric', :val\n  end\n\n  dispatch :on_string do\n    param 'String', :val\n  end\n\n  def on_numeric(x)\n    x.floor\n  end\n\n  def on_string(x)\n    Puppet.warn_once('deprecations', 'floor_function_numeric_coerce_string',\n      _(\"The floor() function's auto conversion of String to Float is deprecated - change to convert input before calling\"))\n\n    begin\n      Float(x).floor\n    rescue TypeError, ArgumentError => _e\n      # TRANSLATORS: 'floor' is a name and should not be translated\n      raise(ArgumentError, _('floor(): cannot convert given value to a floating point value.'))\n    end\n  end\n\nend"
    },
    {
      "name"=>"fqdn_rand",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/fqdn_rand.rb",
      "line"=>4,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"fqdn_rand()",
          "docstring"=>{
            "text"=>"Usage: `fqdn_rand(MAX, [SEED])`. MAX is required and must be a positive\ninteger; SEED is optional and may be any number or string.\n\nGenerates a random Integer number greater than or equal to 0 and less than MAX,\ncombining the `$fqdn` fact and the value of SEED for repeatable randomness.\n(That is, each node will get a different random number from this function, but\na given node's result will be the same every time unless its hostname changes.)\n\nThis function is usually used for spacing out runs of resource-intensive cron\ntasks that run on many nodes, which could cause a thundering herd or degrade\nother services if they all fire at once. Adding a SEED can be useful when you\nhave more than one such task and need several unrelated random numbers per\nnode. (For example, `fqdn_rand(30)`, `fqdn_rand(30, 'expensive job 1')`, and\n`fqdn_rand(30, 'expensive job 2')` will produce totally different numbers.)",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Usage: `fqdn_rand(MAX, [SEED])`. MAX is required and must be a positive\ninteger; SEED is optional and may be any number or string.\n\nGenerates a random Integer number greater than or equal to 0 and less than MAX,\ncombining the `$fqdn` fact and the value of SEED for repeatable randomness.\n(That is, each node will get a different random number from this function, but\na given node's result will be the same every time unless its hostname changes.)\n\nThis function is usually used for spacing out runs of resource-intensive cron\ntasks that run on many nodes, which could cause a thundering herd or degrade\nother services if they all fire at once. Adding a SEED can be useful when you\nhave more than one such task and need several unrelated random numbers per\nnode. (For example, `fqdn_rand(30)`, `fqdn_rand(30, 'expensive job 1')`, and\n`fqdn_rand(30, 'expensive job 2')` will produce totally different numbers.)",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:fqdn_rand, :arity => -2, :type => :rvalue, :doc =>\n  \"Usage: `fqdn_rand(MAX, [SEED])`. MAX is required and must be a positive\n  integer; SEED is optional and may be any number or string.\n\n  Generates a random Integer number greater than or equal to 0 and less than MAX,\n  combining the `$fqdn` fact and the value of SEED for repeatable randomness.\n  (That is, each node will get a different random number from this function, but\n  a given node's result will be the same every time unless its hostname changes.)\n\n  This function is usually used for spacing out runs of resource-intensive cron\n  tasks that run on many nodes, which could cause a thundering herd or degrade\n  other services if they all fire at once. Adding a SEED can be useful when you\n  have more than one such task and need several unrelated random numbers per\n  node. (For example, `fqdn_rand(30)`, `fqdn_rand(30, 'expensive job 1')`, and\n  `fqdn_rand(30, 'expensive job 2')` will produce totally different numbers.)\") do |args|\n    max = args.shift.to_i\n \n    # Puppet 5.4's fqdn_rand function produces a different value than earlier versions\n    # for the same set of inputs.\n    # This causes problems because the values are often written into service configuration files.\n    # When they change, services get notified and restart.\n\n    # Restoring previous fqdn_rand behavior of calculating its seed value using MD5\n    # when running on a non-FIPS enabled platform and only using SHA256 on FIPS enabled\n    # platforms.\n    if Puppet::Util::Platform.fips_enabled?\n      seed = Digest::SHA256.hexdigest([self['::fqdn'],max,args].join(':')).hex\n    else\n      seed = Digest::MD5.hexdigest([self['::fqdn'],max,args].join(':')).hex\n    end\n\n    Puppet::Util.deterministic_rand_int(seed,max)\nend"
    },
    {
      "name"=>"generate",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/generate.rb",
      "line"=>2,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"generate()",
          "docstring"=>{
            "text"=>"Calls an external command on the Puppet master and returns\nthe results of the command. Any arguments are passed to the external command as\narguments. If the generator does not exit with return code of 0,\nthe generator is considered to have failed and a parse error is\nthrown. Generators can only have file separators, alphanumerics, dashes,\nand periods in them. This function will attempt to protect you from\nmalicious generator calls (e.g., those with '..' in them), but it can\nnever be entirely safe. No subshell is used to execute\ngenerators, so all shell metacharacters are passed directly to\nthe generator, and all metacharacters are returned by the function.\nConsider cleaning white space from any string generated.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Calls an external command on the Puppet master and returns\nthe results of the command. Any arguments are passed to the external command as\narguments. If the generator does not exit with return code of 0,\nthe generator is considered to have failed and a parse error is\nthrown. Generators can only have file separators, alphanumerics, dashes,\nand periods in them. This function will attempt to protect you from\nmalicious generator calls (e.g., those with '..' in them), but it can\nnever be entirely safe. No subshell is used to execute\ngenerators, so all shell metacharacters are passed directly to\nthe generator, and all metacharacters are returned by the function.\nConsider cleaning white space from any string generated.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:generate, :arity => -2, :type => :rvalue,\n    :doc => \"Calls an external command on the Puppet master and returns\n    the results of the command. Any arguments are passed to the external command as\n    arguments. If the generator does not exit with return code of 0,\n    the generator is considered to have failed and a parse error is\n    thrown. Generators can only have file separators, alphanumerics, dashes,\n    and periods in them. This function will attempt to protect you from\n    malicious generator calls (e.g., those with '..' in them), but it can\n    never be entirely safe. No subshell is used to execute\n    generators, so all shell metacharacters are passed directly to\n    the generator, and all metacharacters are returned by the function.\n    Consider cleaning white space from any string generated.\") do |args|\n\n      #TRANSLATORS \"fully qualified\" refers to a fully qualified file system path\n      raise Puppet::ParseError, _(\"Generators must be fully qualified\") unless Puppet::Util.absolute_path?(args[0])\n\n      if Puppet::Util::Platform.windows?\n        valid = args[0] =~ /^[a-z]:(?:[\\/\\\\][-.~\\w]+)+$/i\n      else\n        valid = args[0] =~ /^[-\\/\\w.+]+$/\n      end\n\n      unless valid\n        raise Puppet::ParseError, _(\"Generators can only contain alphanumerics, file separators, and dashes\")\n      end\n\n      if args[0] =~ /\\.\\./\n        raise Puppet::ParseError, _(\"Can not use generators with '..' in them.\")\n      end\n\n      begin\n        Dir.chdir(File.dirname(args[0])) { Puppet::Util::Execution.execute(args).to_str }\n      rescue Puppet::ExecutionFailure => detail\n        raise Puppet::ParseError, _(\"Failed to execute generator %{generator}: %{detail}\") % { generator: args[0], detail: detail }, detail.backtrace\n      end\nend"
    },
    {
      "name"=>"get",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/get.rb",
      "line"=>115,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"get(Any $value, String $dotted_string, Optional[Any] $default_value, Optional[Callable[1,1]] &$block)",
          "docstring"=>{
            "text"=>"Digs into a value with dot notation to get a value from within a structure.\n\n**To dig into a given value**, call the function with (at least) two arguments:\n\n* The **first** argument must be an Array, or Hash. Value can also be `undef`\n  (which also makes the result `undef` unless a _default value_ is given).\n* The **second** argument must be a _dot notation navigation string_.\n* The **optional third** argument can be any type of value and it is used\n  as the _default value_ if the function would otherwise return `undef`.\n* An **optional lambda** for error handling taking one `Error` argument.\n\n**Dot notation navigation string** -\nThe dot string consists of period `.` separated segments where each\nsegment is either the index into an array or the value of a hash key.\nIf a wanted key contains a period it must be quoted to avoid it being\ntaken as a segment separator. Quoting can be done with either\nsingle quotes `'` or double quotes `\"`. If a segment is\na decimal number it is converted to an Integer index. This conversion\ncan be prevented by quoting the value.\n\n```puppet\n#get($facts, 'os.family')\n$facts.get('os.family')\n```\nWould both result in the value of $facts['os']['family']\n\n```puppet\nget([1,2,[{'name' =>'waldo'}]], '2.0.name')\n```\nWould result in 'waldo'\n\n```puppet\nget([1,2,[{'name' =>'waldo'}]], '2.1.name', 'not waldo')\n\n```\nWould result in 'not waldo'\n\n```puppet\n$x = [1, 2, { 'readme.md' => \"This is a readme.\"}]\n$x.get('2.\"readme.md\"')\n```\n\n```puppet\n$x = [1, 2, { '10' => \"ten\"}]\n$x.get('2.\"0\"')\n```\n\n**Error Handling** - There are two types of common errors that can\nbe handled by giving the function a code block to execute.\n(A third kind or error; when the navigation string has syntax errors\n(for example an empty segment or unbalanced quotes) will always raise\nan error).\n\nThe given block will be given an instance of the `Error` data type,\nand it has methods to extract `msg`, `issue_code`, `kind`, and\n`details`.\n\nThe `msg` will be a preformatted message describing the error.\nThis is the error message that would have surfaced if there was\nno block to handle the error.\n\nThe `kind` is the string `'SLICE_ERROR'` for both kinds of errors,\nand the `issue_code` is either the string `'EXPECTED_INTEGER_INDEX'`\nfor an attempt to index into an array with a String,\nor `'EXPECTED_COLLECTION'` for an attempt to index into something that\nis not a Collection.\n\nThe `details` is a Hash that for both issue codes contain the\nentry `'walked_path'` which is an Array with each key in the\nprogression of the dig up to the place where the error occurred.\n\nFor an `EXPECTED_INTEGER_INDEX`-issue the detail `'index_type'` is\nset to the data type of the index value and for an\n`'EXPECTED_COLLECTION'`-issue the detail `'value_type'` is set\nto the type of the value.\n\nThe logic in the error handling block can inspect the details,\nand either call `fail()` with a custom error message or produce\nthe wanted value.\n\nIf the block produces `undef` it will not be replaced with a\ngiven default value.\n\n```puppet\n$x = 'blue'\n$x.get('0.color', 'green') |$error| { undef } # result is undef\n\n$y = ['blue']\n$y.get('color', 'green') |$error| { undef } # result is undef\n```\n\n```puppet\n$x = [1, 2, ['blue']]\n$x.get('2.color') |$error| {\n  notice(\"Walked path is ${error.details['walked_path']}\")\n}\n```\nWould notice `Walked path is [2, color]`\n\nAlso see:\n* `getvar()` that takes the first segment to be the name of a variable\n  and then delegates to this function.\n* `dig()` function which is similar but uses an\n  array of navigation values instead of a dot notation string.",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Navigating into a value"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Getting the value from an expression"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using a default value"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Quoting a key with period"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Quoting a numeric string"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Ensure `undef` result on error"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Accessing information in the Error"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"dotted_string"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Any]"
                ],
                "name"=>"default_value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[1,1]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Digs into a value with dot notation to get a value from within a structure.\n\n**To dig into a given value**, call the function with (at least) two arguments:\n\n* The **first** argument must be an Array, or Hash. Value can also be `undef`\n  (which also makes the result `undef` unless a _default value_ is given).\n* The **second** argument must be a _dot notation navigation string_.\n* The **optional third** argument can be any type of value and it is used\n  as the _default value_ if the function would otherwise return `undef`.\n* An **optional lambda** for error handling taking one `Error` argument.\n\n**Dot notation navigation string** -\nThe dot string consists of period `.` separated segments where each\nsegment is either the index into an array or the value of a hash key.\nIf a wanted key contains a period it must be quoted to avoid it being\ntaken as a segment separator. Quoting can be done with either\nsingle quotes `'` or double quotes `\"`. If a segment is\na decimal number it is converted to an Integer index. This conversion\ncan be prevented by quoting the value.\n\n```puppet\n#get($facts, 'os.family')\n$facts.get('os.family')\n```\nWould both result in the value of $facts['os']['family']\n\n```puppet\nget([1,2,[{'name' =>'waldo'}]], '2.0.name')\n```\nWould result in 'waldo'\n\n```puppet\nget([1,2,[{'name' =>'waldo'}]], '2.1.name', 'not waldo')\n\n```\nWould result in 'not waldo'\n\n```puppet\n$x = [1, 2, { 'readme.md' => \"This is a readme.\"}]\n$x.get('2.\"readme.md\"')\n```\n\n```puppet\n$x = [1, 2, { '10' => \"ten\"}]\n$x.get('2.\"0\"')\n```\n\n**Error Handling** - There are two types of common errors that can\nbe handled by giving the function a code block to execute.\n(A third kind or error; when the navigation string has syntax errors\n(for example an empty segment or unbalanced quotes) will always raise\nan error).\n\nThe given block will be given an instance of the `Error` data type,\nand it has methods to extract `msg`, `issue_code`, `kind`, and\n`details`.\n\nThe `msg` will be a preformatted message describing the error.\nThis is the error message that would have surfaced if there was\nno block to handle the error.\n\nThe `kind` is the string `'SLICE_ERROR'` for both kinds of errors,\nand the `issue_code` is either the string `'EXPECTED_INTEGER_INDEX'`\nfor an attempt to index into an array with a String,\nor `'EXPECTED_COLLECTION'` for an attempt to index into something that\nis not a Collection.\n\nThe `details` is a Hash that for both issue codes contain the\nentry `'walked_path'` which is an Array with each key in the\nprogression of the dig up to the place where the error occurred.\n\nFor an `EXPECTED_INTEGER_INDEX`-issue the detail `'index_type'` is\nset to the data type of the index value and for an\n`'EXPECTED_COLLECTION'`-issue the detail `'value_type'` is set\nto the type of the value.\n\nThe logic in the error handling block can inspect the details,\nand either call `fail()` with a custom error message or produce\nthe wanted value.\n\nIf the block produces `undef` it will not be replaced with a\ngiven default value.\n\n```puppet\n$x = 'blue'\n$x.get('0.color', 'green') |$error| { undef } # result is undef\n\n$y = ['blue']\n$y.get('color', 'green') |$error| { undef } # result is undef\n```\n\n```puppet\n$x = [1, 2, ['blue']]\n$x.get('2.color') |$error| {\n  notice(\"Walked path is ${error.details['walked_path']}\")\n}\n```\nWould notice `Walked path is [2, color]`\n\nAlso see:\n* `getvar()` that takes the first segment to be the name of a variable\n  and then delegates to this function.\n* `dig()` function which is similar but uses an\n  array of navigation values instead of a dot notation string.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Navigating into a value"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Getting the value from an expression"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using a default value"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Quoting a key with period"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Quoting a numeric string"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Ensure `undef` result on error"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Accessing information in the Error"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Any"
            ],
            "name"=>"value"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "String"
            ],
            "name"=>"dotted_string"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Any]"
            ],
            "name"=>"default_value"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Callable[1,1]]"
            ],
            "name"=>"&block"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"6.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:get, Puppet::Functions::InternalFunction) do\n  dispatch :get_from_value do\n    param 'Any', :value\n    param 'String', :dotted_string\n    optional_param 'Any', :default_value\n    optional_block_param 'Callable[1,1]', :block\n  end\n\n  # Gets a result from given value and a navigation string\n  #\n  def get_from_value(value, navigation, default_value = nil, &block)\n    return default_value if value.nil?\n    return value if navigation.empty?\n\n    # Note: split_key always processes the initial segment as a string even if it could be an integer.\n    # This since it is designed for lookup keys. For a numeric first segment\n    # like '0.1' the wanted result is [0,1], not [\"0\", 1]. The workaround here is to\n    # prefix the navigation with \"x.\" thus giving split_key a first segment that is a string.\n    # The fake segment is then dropped.\n    segments = split_key(\"x.\" + navigation) {|err| _(\"Syntax error in dotted-navigation string\")}\n    segments.shift\n\n    begin\n      result = call_function('dig', value, *segments)\n      return result.nil? ? default_value : result\n    rescue Puppet::ErrorWithData => e\n      if block_given?\n        yield(e.error_data)\n      else\n        raise e\n      end\n    end\n  end\n  # reuse the split_key parser used also by lookup\n  include Puppet::Pops::Lookup::SubLookup\nend"
    },
    {
      "name"=>"getvar",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/getvar.rb",
      "line"=>45,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"getvar(Pattern[/\\A(?:::)?(?:[a-z]\\w*::)*[a-z_]\\w*(?:\\.|\\Z)/] $get_string, Optional[Any] $default_value, Optional[Callable[1,1]] &$block)",
          "docstring"=>{
            "text"=>"Digs into a variable with dot notation to get a value from a structure.\n\n**To get the value from a variable** (that may or may not exist), call the function with\none or two arguments:\n\n* The **first** argument must be a string, and must start with a variable name without leading `$`,\n  for example `get('facts')`. The variable name can be followed\n  by a _dot notation navigation string_ to dig out a value in the array or hash value\n  of the variable.\n* The **optional second** argument can be any type of value and it is used as the\n  _default value_ if the function would otherwise return `undef`.\n* An **optional lambda** for error handling taking one `Error` argument.\n\n**Dot notation navigation string** -\nThe dot string consists of period `.` separated segments where each\nsegment is either the index into an array or the value of a hash key.\nIf a wanted key contains a period it must be quoted to avoid it being\ntaken as a segment separator. Quoting can be done with either\nsingle quotes `'` or double quotes `\"`. If a segment is\na decimal number it is converted to an Integer index. This conversion\ncan be prevented by quoting the value.\n\n```puppet\ngetvar('facts') # results in the value of $facts\n```\n\n```puppet\ngetvar('facts.os.family') # results in the value of $facts['os']['family']\n```\n\n```puppet\n$x = [1,2,[{'name' =>'waldo'}]]\ngetvar('x.2.1.name', 'not waldo')\n# results in 'not waldo'\n```\n\nFor further examples and how to perform error handling, see the `get()` function\nwhich this function delegates to after having resolved the variable value.",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Getting the value of a variable"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Navigating into a variable"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using a default value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Pattern[/\\A(?:::)?(?:[a-z]\\w*::)*[a-z_]\\w*(?:\\.|\\Z)/]"
                ],
                "name"=>"get_string"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Any]"
                ],
                "name"=>"default_value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[1,1]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Digs into a variable with dot notation to get a value from a structure.\n\n**To get the value from a variable** (that may or may not exist), call the function with\none or two arguments:\n\n* The **first** argument must be a string, and must start with a variable name without leading `$`,\n  for example `get('facts')`. The variable name can be followed\n  by a _dot notation navigation string_ to dig out a value in the array or hash value\n  of the variable.\n* The **optional second** argument can be any type of value and it is used as the\n  _default value_ if the function would otherwise return `undef`.\n* An **optional lambda** for error handling taking one `Error` argument.\n\n**Dot notation navigation string** -\nThe dot string consists of period `.` separated segments where each\nsegment is either the index into an array or the value of a hash key.\nIf a wanted key contains a period it must be quoted to avoid it being\ntaken as a segment separator. Quoting can be done with either\nsingle quotes `'` or double quotes `\"`. If a segment is\na decimal number it is converted to an Integer index. This conversion\ncan be prevented by quoting the value.\n\n```puppet\ngetvar('facts') # results in the value of $facts\n```\n\n```puppet\ngetvar('facts.os.family') # results in the value of $facts['os']['family']\n```\n\n```puppet\n$x = [1,2,[{'name' =>'waldo'}]]\ngetvar('x.2.1.name', 'not waldo')\n# results in 'not waldo'\n```\n\nFor further examples and how to perform error handling, see the `get()` function\nwhich this function delegates to after having resolved the variable value.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Getting the value of a variable"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Navigating into a variable"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using a default value"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Pattern[/\\A(?:::)?(?:[a-z]\\w*::)*[a-z_]\\w*(?:\\.|\\Z)/]"
            ],
            "name"=>"get_string"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Any]"
            ],
            "name"=>"default_value"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Callable[1,1]]"
            ],
            "name"=>"&block"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"6.0.0 - the ability to dig into the variable's value with dot notation."
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:getvar, Puppet::Functions::InternalFunction) do\n  dispatch :get_from_navigation do\n    scope_param\n     param 'Pattern[/\\A(?:::)?(?:[a-z]\\w*::)*[a-z_]\\w*(?:\\.|\\Z)/]', :get_string\n    optional_param 'Any', :default_value\n    optional_block_param 'Callable[1,1]', :block\n  end\n\n  argument_mismatch :invalid_variable_error do\n    param 'String', :get_string\n    optional_param 'Any', :default_value\n    optional_block_param 'Callable', :block\n  end\n\n  def invalid_variable_error(navigation, default_value=nil, &block)\n    _(\"The given string does not start with a valid variable name\")\n  end\n\n  # Gets a result from a navigation string starting with $var\n  #\n  def get_from_navigation(scope, navigation, default_value = nil, &block)\n    # asserted to start with a valid variable name - dig out the variable\n    matches = navigation.match(/^((::)?(\\w+::)*\\w+)(.*)\\z/)\n    navigation = matches[4]\n    if navigation[0] == '.'\n      navigation = navigation[1..-1]\n    else\n      unless navigation.empty?\n        raise ArgumentError, _(\"First character after var name in get string must be a '.' - got %{char}\") % {char: navigation[0]}\n      end\n    end\n    get_from_var_name(scope, matches[1], navigation, default_value, &block)\n  end\n\n  # Gets a result from a $var name and a navigation string\n  #\n  def get_from_var_name(scope, var_string, navigation, default_value = nil, &block)\n    catch(:undefined_variable) do\n      return call_function_with_scope(scope,'get', scope.lookupvar(var_string), navigation, default_value, &block)\n    end\n    default_value\n  end\nend"
    },
    {
      "name"=>"group_by",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/group_by.rb",
      "line"=>5,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"group_by(Collection $collection, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"[a, b, ab].group_by |$s| { $s.length }",
                "name"=>"Group array of strings by length, results in e.g. { 1 => [a, b], 2 => [ab] }"
              },
              {
                "tag_name"=>"example",
                "text"=>"[a, b, ab].group_by |$i, $s| { $i%2 + $s.length }",
                "name"=>"Group array of strings by length and index, results in e.g. {1 => ['a'], 2 => ['b', 'ab']}"
              },
              {
                "tag_name"=>"example",
                "text"=>"{ a => [1, 2], b => [1] }.group_by |$kv| { $kv[1].length }",
                "name"=>"Group hash iterating by key-value pair, results in e.g. { 2 => [['a', [1, 2]]], 1 => [['b', [1]]] }"
              },
              {
                "tag_name"=>"example",
                "text"=>"{ a => [1, 2], b => [1] }.group_by |$k, $v| { $v.length }",
                "name"=>"Group hash iterating by key and value, results in e.g. { 2 => [['a', [1, 2]]], 1 => [['b', [1]]] }"
              },
              {
                "tag_name"=>"param",
                "text"=>"A collection of things to group.",
                "types"=>[
                  "Collection"
                ],
                "name"=>"collection"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Hash"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"group_by(Array $array, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array"
                ],
                "name"=>"array"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Hash"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"group_by(Collection $collection, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Collection"
                ],
                "name"=>"collection"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Hash"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Groups the collection by result of the block. Returns a hash where the keys are the evaluated result from the block\nand the values are arrays of elements in the collection that correspond to the key.",
        "tags"=>[
          {
            "tag_name"=>"overload",
            "signature"=>"group_by(Collection $collection, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"example",
                  "text"=>"[a, b, ab].group_by |$s| { $s.length }",
                  "name"=>"Group array of strings by length, results in e.g. { 1 => [a, b], 2 => [ab] }"
                },
                {
                  "tag_name"=>"example",
                  "text"=>"[a, b, ab].group_by |$i, $s| { $i%2 + $s.length }",
                  "name"=>"Group array of strings by length and index, results in e.g. {1 => ['a'], 2 => ['b', 'ab']}"
                },
                {
                  "tag_name"=>"example",
                  "text"=>"{ a => [1, 2], b => [1] }.group_by |$kv| { $kv[1].length }",
                  "name"=>"Group hash iterating by key-value pair, results in e.g. { 2 => [['a', [1, 2]]], 1 => [['b', [1]]] }"
                },
                {
                  "tag_name"=>"example",
                  "text"=>"{ a => [1, 2], b => [1] }.group_by |$k, $v| { $v.length }",
                  "name"=>"Group hash iterating by key and value, results in e.g. { 2 => [['a', [1, 2]]], 1 => [['b', [1]]] }"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"A collection of things to group.",
                  "types"=>[
                    "Collection"
                  ],
                  "name"=>"collection"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Hash"
                  ]
                }
              ]
            },
            "name"=>"group_by"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"group_by(Array $array, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array"
                  ],
                  "name"=>"array"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Hash"
                  ]
                }
              ]
            },
            "name"=>"group_by"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"group_by(Collection $collection, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Collection"
                  ],
                  "name"=>"collection"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Hash"
                  ]
                }
              ]
            },
            "name"=>"group_by"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:group_by) do\n  # @param collection A collection of things to group.\n  # @example Group array of strings by length, results in e.g. { 1 => [a, b], 2 => [ab] }\n  #   [a, b, ab].group_by |$s| { $s.length }\n  # @example Group array of strings by length and index, results in e.g. {1 => ['a'], 2 => ['b', 'ab']}\n  #   [a, b, ab].group_by |$i, $s| { $i%2 + $s.length }\n  # @example Group hash iterating by key-value pair, results in e.g. { 2 => [['a', [1, 2]]], 1 => [['b', [1]]] }\n  #   { a => [1, 2], b => [1] }.group_by |$kv| { $kv[1].length }\n  # @example Group hash iterating by key and value, results in e.g. { 2 => [['a', [1, 2]]], 1 => [['b', [1]]] }\n  #   { a => [1, 2], b => [1] }.group_by |$k, $v| { $v.length }\n  dispatch :group_by_1 do\n    required_param 'Collection', :collection\n    block_param 'Callable[1,1]', :block\n    return_type 'Hash'\n  end\n\n  dispatch :group_by_2a do\n    required_param 'Array', :array\n    block_param 'Callable[2,2]', :block\n    return_type 'Hash'\n  end\n\n  dispatch :group_by_2 do\n    required_param 'Collection', :collection\n    block_param 'Callable[2,2]', :block\n    return_type 'Hash'\n  end\n\n  def group_by_1(collection)\n    collection.group_by do |item|\n      yield(item)\n    end.freeze\n  end\n\n  def group_by_2a(array)\n    grouped = array.size.times.zip(array).group_by do |k, v|\n      yield(k, v)\n    end\n\n    grouped.each_with_object({}) do |(k, v), hsh|\n      hsh[k] = v.map { |item| item[1] }\n    end.freeze\n  end\n\n  def group_by_2(collection)\n    collection.group_by do |k, v|\n      yield(k, v)\n    end.freeze\n  end\nend"
    },
    {
      "name"=>"hiera",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/hiera.rb",
      "line"=>4,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"hiera()",
          "docstring"=>{
            "text"=>"Performs a standard priority lookup of the hierarchy and returns the most specific value\nfor a given key. The returned value can be any type of data.\n\nThe function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\nThe `hiera` function does **not** find all matches throughout a hierarchy, instead\nreturining the first specific value starting at the top of the hierarchy. To search\nthroughout a hierarchy, use the `hiera_array` or `hiera_hash` functions.\n\n**Example**: Using `hiera`\n\n~~~ yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming web01.example.com.yaml:\n# users:\n#   - \"Amy Barry\"\n#   - \"Carrie Douglas\"\n\n# Assuming common.yaml:\nusers:\n  admins:\n    - \"Edith Franklin\"\n    - \"Ginny Hamilton\"\n  regular:\n    - \"Iris Jackson\"\n    - \"Kelly Lambert\"\n~~~\n\n~~~ puppet\n# Assuming we are not web01.example.com:\n\n$users = hiera('users', undef)\n\n# $users contains {admins  => [\"Edith Franklin\", \"Ginny Hamilton\"],\n#                  regular => [\"Iris Jackson\", \"Kelly Lambert\"]}\n~~~\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n**Example**: Using `hiera` with a lambda\n\n~~~ puppet\n# Assuming the same Hiera data as the previous example:\n\n$users = hiera('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $users contains {admins  => [\"Edith Franklin\", \"Ginny Hamilton\"],\n#                  regular => [\"Iris Jackson\", \"Kelly Lambert\"]}\n# If hiera couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n~~~\n\nThe returned value's data type depends on the types of the results. In the example\nabove, Hiera matches the 'users' key and returns it as a hash.\n\nThe `hiera` function is deprecated in favor of using `lookup` and will be removed in 6.0.0.\nSee https://puppet.com/docs/puppet/\#{Puppet.minor_version}/deprecated_language.html.\nReplace the calls as follows:\n\n| from  | to |\n| ----  | ---|\n| hiera($key) | lookup($key) |\n| hiera($key, $default) | lookup($key, { 'default_value' => $default }) |\n| hiera($key, $default, $level) | override level not supported |\n\nNote that calls using the 'override level' option are not directly supported by 'lookup' and the produced\nresult must be post processed to get exactly the same result, for example using simple hash/array `+` or\nwith calls to stdlib's `deep_merge` function depending on kind of hiera call and setting of merge in hiera.yaml.\n\nSee\n[the documentation](https://puppet.com/docs/hiera/latest/puppet.html#hiera-lookup-functions)\nfor more information about Hiera lookup functions.\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Performs a standard priority lookup of the hierarchy and returns the most specific value\nfor a given key. The returned value can be any type of data.\n\nThe function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\nThe `hiera` function does **not** find all matches throughout a hierarchy, instead\nreturining the first specific value starting at the top of the hierarchy. To search\nthroughout a hierarchy, use the `hiera_array` or `hiera_hash` functions.\n\n**Example**: Using `hiera`\n\n~~~ yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming web01.example.com.yaml:\n# users:\n#   - \"Amy Barry\"\n#   - \"Carrie Douglas\"\n\n# Assuming common.yaml:\nusers:\n  admins:\n    - \"Edith Franklin\"\n    - \"Ginny Hamilton\"\n  regular:\n    - \"Iris Jackson\"\n    - \"Kelly Lambert\"\n~~~\n\n~~~ puppet\n# Assuming we are not web01.example.com:\n\n$users = hiera('users', undef)\n\n# $users contains {admins  => [\"Edith Franklin\", \"Ginny Hamilton\"],\n#                  regular => [\"Iris Jackson\", \"Kelly Lambert\"]}\n~~~\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n**Example**: Using `hiera` with a lambda\n\n~~~ puppet\n# Assuming the same Hiera data as the previous example:\n\n$users = hiera('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $users contains {admins  => [\"Edith Franklin\", \"Ginny Hamilton\"],\n#                  regular => [\"Iris Jackson\", \"Kelly Lambert\"]}\n# If hiera couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n~~~\n\nThe returned value's data type depends on the types of the results. In the example\nabove, Hiera matches the 'users' key and returns it as a hash.\n\nThe `hiera` function is deprecated in favor of using `lookup` and will be removed in 6.0.0.\nSee https://puppet.com/docs/puppet/\#{Puppet.minor_version}/deprecated_language.html.\nReplace the calls as follows:\n\n| from  | to |\n| ----  | ---|\n| hiera($key) | lookup($key) |\n| hiera($key, $default) | lookup($key, { 'default_value' => $default }) |\n| hiera($key, $default, $level) | override level not supported |\n\nNote that calls using the 'override level' option are not directly supported by 'lookup' and the produced\nresult must be post processed to get exactly the same result, for example using simple hash/array `+` or\nwith calls to stdlib's `deep_merge` function depending on kind of hiera call and setting of merge in hiera.yaml.\n\nSee\n[the documentation](https://puppet.com/docs/hiera/latest/puppet.html#hiera-lookup-functions)\nfor more information about Hiera lookup functions.\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"newfunction(\n  :hiera,\n  :type => :rvalue,\n  :arity => -2,\n  :doc => <<DOC\nPerforms a standard priority lookup of the hierarchy and returns the most specific value\nfor a given key. The returned value can be any type of data.\n\nThe function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n  * If this argument isn't provided and this function results in a lookup failure, Puppet\n  fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n  * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n  searching the rest of the hierarchy.\n\nThe `hiera` function does **not** find all matches throughout a hierarchy, instead\nreturining the first specific value starting at the top of the hierarchy. To search\nthroughout a hierarchy, use the `hiera_array` or `hiera_hash` functions.\n\n**Example**: Using `hiera`\n\n~~~ yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming web01.example.com.yaml:\n# users:\n#   - \"Amy Barry\"\n#   - \"Carrie Douglas\"\n\n# Assuming common.yaml:\nusers:\nadmins:\n  - \"Edith Franklin\"\n  - \"Ginny Hamilton\"\nregular:\n  - \"Iris Jackson\"\n  - \"Kelly Lambert\"\n~~~\n\n~~~ puppet\n# Assuming we are not web01.example.com:\n\n$users = hiera('users', undef)\n\n# $users contains {admins  => [\"Edith Franklin\", \"Ginny Hamilton\"],\n#                  regular => [\"Iris Jackson\", \"Kelly Lambert\"]}\n~~~\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n**Example**: Using `hiera` with a lambda\n\n~~~ puppet\n# Assuming the same Hiera data as the previous example:\n\n$users = hiera('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $users contains {admins  => [\"Edith Franklin\", \"Ginny Hamilton\"],\n#                  regular => [\"Iris Jackson\", \"Kelly Lambert\"]}\n# If hiera couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n~~~\n\nThe returned value's data type depends on the types of the results. In the example\nabove, Hiera matches the 'users' key and returns it as a hash.\n\nThe `hiera` function is deprecated in favor of using `lookup` and will be removed in 6.0.0.\nSee https://puppet.com/docs/puppet/\#{Puppet.minor_version}/deprecated_language.html.\nReplace the calls as follows:\n\n| from  | to |\n| ----  | ---|\n| hiera($key) | lookup($key) |\n| hiera($key, $default) | lookup($key, { 'default_value' => $default }) |\n| hiera($key, $default, $level) | override level not supported |\n\nNote that calls using the 'override level' option are not directly supported by 'lookup' and the produced\nresult must be post processed to get exactly the same result, for example using simple hash/array `+` or\nwith calls to stdlib's `deep_merge` function depending on kind of hiera call and setting of merge in hiera.yaml.\n\nSee\n[the documentation](https://puppet.com/docs/hiera/latest/puppet.html#hiera-lookup-functions)\nfor more information about Hiera lookup functions.\n\n- Since 4.0.0\nDOC\n) do |*args|\n  Error.is4x('hiera')\nend"
    },
    {
      "name"=>"hiera",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/hiera.rb",
      "line"=>86,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"hiera()",
          "docstring"=>{
            "text"=>"Performs a standard priority lookup of the hierarchy and returns the most specific value\nfor a given key. The returned value can be any type of data.\n\nThis function is deprecated in favor of the `lookup` function. While this function\ncontinues to work, it does **not** support:\n* `lookup_options` stored in the data\n* lookup across global, environment, and module layers\n\nThe function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\nThe `hiera` function does **not** find all matches throughout a hierarchy, instead\nreturning the first specific value starting at the top of the hierarchy. To search\nthroughout a hierarchy, use the `hiera_array` or `hiera_hash` functions.\n\n```yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming web01.example.com.yaml:\n# users:\n#   - \"Amy Barry\"\n#   - \"Carrie Douglas\"\n\n# Assuming common.yaml:\nusers:\n  admins:\n    - \"Edith Franklin\"\n    - \"Ginny Hamilton\"\n  regular:\n    - \"Iris Jackson\"\n    - \"Kelly Lambert\"\n```\n\n```puppet\n# Assuming we are not web01.example.com:\n\n$users = hiera('users', undef)\n\n# $users contains {admins  => [\"Edith Franklin\", \"Ginny Hamilton\"],\n#                  regular => [\"Iris Jackson\", \"Kelly Lambert\"]}\n```\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n```puppet\n# Assuming the same Hiera data as the previous example:\n\n$users = hiera('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $users contains {admins  => [\"Edith Franklin\", \"Ginny Hamilton\"],\n#                  regular => [\"Iris Jackson\", \"Kelly Lambert\"]}\n# If hiera couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n```\n\nThe returned value's data type depends on the types of the results. In the example\nabove, Hiera matches the 'users' key and returns it as a hash.\n\nSee\n[the 'Using the lookup function' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html) for how to perform lookup of data.\nAlso see\n[the 'Using the deprecated hiera functions' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html)\nfor more information about the Hiera 3 functions.",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `hiera`"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `hiera` with a lambda"
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Performs a standard priority lookup of the hierarchy and returns the most specific value\nfor a given key. The returned value can be any type of data.\n\nThis function is deprecated in favor of the `lookup` function. While this function\ncontinues to work, it does **not** support:\n* `lookup_options` stored in the data\n* lookup across global, environment, and module layers\n\nThe function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\nThe `hiera` function does **not** find all matches throughout a hierarchy, instead\nreturning the first specific value starting at the top of the hierarchy. To search\nthroughout a hierarchy, use the `hiera_array` or `hiera_hash` functions.\n\n```yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming web01.example.com.yaml:\n# users:\n#   - \"Amy Barry\"\n#   - \"Carrie Douglas\"\n\n# Assuming common.yaml:\nusers:\n  admins:\n    - \"Edith Franklin\"\n    - \"Ginny Hamilton\"\n  regular:\n    - \"Iris Jackson\"\n    - \"Kelly Lambert\"\n```\n\n```puppet\n# Assuming we are not web01.example.com:\n\n$users = hiera('users', undef)\n\n# $users contains {admins  => [\"Edith Franklin\", \"Ginny Hamilton\"],\n#                  regular => [\"Iris Jackson\", \"Kelly Lambert\"]}\n```\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n```puppet\n# Assuming the same Hiera data as the previous example:\n\n$users = hiera('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $users contains {admins  => [\"Edith Franklin\", \"Ginny Hamilton\"],\n#                  regular => [\"Iris Jackson\", \"Kelly Lambert\"]}\n# If hiera couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n```\n\nThe returned value's data type depends on the types of the results. In the example\nabove, Hiera matches the 'users' key and returns it as a hash.\n\nSee\n[the 'Using the lookup function' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html) for how to perform lookup of data.\nAlso see\n[the 'Using the deprecated hiera functions' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html)\nfor more information about the Hiera 3 functions.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `hiera`"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `hiera` with a lambda"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:hiera, Hiera::PuppetFunction) do\n  init_dispatch\nend"
    },
    {
      "name"=>"hiera_array",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/hiera_array.rb",
      "line"=>4,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"hiera_array()",
          "docstring"=>{
            "text"=>"Finds all matches of a key throughout the hierarchy and returns them as a single flattened\narray of unique values. If any of the matched values are arrays, they're flattened and\nincluded in the results. This is called an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge).\n\nThe `hiera_array` function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\n**Example**: Using `hiera_array`\n\n~~~ yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming common.yaml:\n# users:\n#   - 'cdouglas = regular'\n#   - 'efranklin = regular'\n\n# Assuming web01.example.com.yaml:\n# users: 'abarry = admin'\n~~~\n\n~~~ puppet\n$allusers = hiera_array('users', undef)\n\n# $allusers contains [\"cdouglas = regular\", \"efranklin = regular\", \"abarry = admin\"].\n~~~\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n**Example**: Using `hiera_array` with a lambda\n\n~~~ puppet\n# Assuming the same Hiera data as the previous example:\n\n$allusers = hiera_array('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $allusers contains [\"cdouglas = regular\", \"efranklin = regular\", \"abarry = admin\"].\n# If hiera_array couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n~~~\n\n`hiera_array` expects that all values returned will be strings or arrays. If any matched\nvalue is a hash, Puppet raises a type mismatch error.\n\n`hiera_array` is deprecated in favor of using `lookup` and will be removed in 6.0.0.\nSee https://puppet.com/docs/puppet/\#{Puppet.minor_version}/deprecated_language.html.\nReplace the calls as follows:\n\n| from  | to |\n| ----  | ---|\n| hiera_array($key) | lookup($key, { 'merge' => 'unique' }) |\n| hiera_array($key, $default) | lookup($key, { 'default_value' => $default, 'merge' => 'unique' }) |\n| hiera_array($key, $default, $level) | override level not supported |\n\nNote that calls using the 'override level' option are not directly supported by 'lookup' and the produced\nresult must be post processed to get exactly the same result, for example using simple hash/array `+` or\nwith calls to stdlib's `deep_merge` function depending on kind of hiera call and setting of merge in hiera.yaml.\n\nSee\n[the documentation](https://puppet.com/docs/hiera/latest/puppet.html#hiera-lookup-functions)\nfor more information about Hiera lookup functions.\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Finds all matches of a key throughout the hierarchy and returns them as a single flattened\narray of unique values. If any of the matched values are arrays, they're flattened and\nincluded in the results. This is called an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge).\n\nThe `hiera_array` function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\n**Example**: Using `hiera_array`\n\n~~~ yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming common.yaml:\n# users:\n#   - 'cdouglas = regular'\n#   - 'efranklin = regular'\n\n# Assuming web01.example.com.yaml:\n# users: 'abarry = admin'\n~~~\n\n~~~ puppet\n$allusers = hiera_array('users', undef)\n\n# $allusers contains [\"cdouglas = regular\", \"efranklin = regular\", \"abarry = admin\"].\n~~~\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n**Example**: Using `hiera_array` with a lambda\n\n~~~ puppet\n# Assuming the same Hiera data as the previous example:\n\n$allusers = hiera_array('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $allusers contains [\"cdouglas = regular\", \"efranklin = regular\", \"abarry = admin\"].\n# If hiera_array couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n~~~\n\n`hiera_array` expects that all values returned will be strings or arrays. If any matched\nvalue is a hash, Puppet raises a type mismatch error.\n\n`hiera_array` is deprecated in favor of using `lookup` and will be removed in 6.0.0.\nSee https://puppet.com/docs/puppet/\#{Puppet.minor_version}/deprecated_language.html.\nReplace the calls as follows:\n\n| from  | to |\n| ----  | ---|\n| hiera_array($key) | lookup($key, { 'merge' => 'unique' }) |\n| hiera_array($key, $default) | lookup($key, { 'default_value' => $default, 'merge' => 'unique' }) |\n| hiera_array($key, $default, $level) | override level not supported |\n\nNote that calls using the 'override level' option are not directly supported by 'lookup' and the produced\nresult must be post processed to get exactly the same result, for example using simple hash/array `+` or\nwith calls to stdlib's `deep_merge` function depending on kind of hiera call and setting of merge in hiera.yaml.\n\nSee\n[the documentation](https://puppet.com/docs/hiera/latest/puppet.html#hiera-lookup-functions)\nfor more information about Hiera lookup functions.\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"newfunction(\n  :hiera_array,\n  :type => :rvalue,\n  :arity => -2,\n  :doc => <<-DOC\nFinds all matches of a key throughout the hierarchy and returns them as a single flattened\narray of unique values. If any of the matched values are arrays, they're flattened and\nincluded in the results. This is called an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge).\n\nThe `hiera_array` function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n  * If this argument isn't provided and this function results in a lookup failure, Puppet\n  fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n  * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n  searching the rest of the hierarchy.\n\n**Example**: Using `hiera_array`\n\n~~~ yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming common.yaml:\n# users:\n#   - 'cdouglas = regular'\n#   - 'efranklin = regular'\n\n# Assuming web01.example.com.yaml:\n# users: 'abarry = admin'\n~~~\n\n~~~ puppet\n$allusers = hiera_array('users', undef)\n\n# $allusers contains [\"cdouglas = regular\", \"efranklin = regular\", \"abarry = admin\"].\n~~~\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n**Example**: Using `hiera_array` with a lambda\n\n~~~ puppet\n# Assuming the same Hiera data as the previous example:\n\n$allusers = hiera_array('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $allusers contains [\"cdouglas = regular\", \"efranklin = regular\", \"abarry = admin\"].\n# If hiera_array couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n~~~\n\n`hiera_array` expects that all values returned will be strings or arrays. If any matched\nvalue is a hash, Puppet raises a type mismatch error.\n\n`hiera_array` is deprecated in favor of using `lookup` and will be removed in 6.0.0.\nSee https://puppet.com/docs/puppet/\#{Puppet.minor_version}/deprecated_language.html.\nReplace the calls as follows:\n\n| from  | to |\n| ----  | ---|\n| hiera_array($key) | lookup($key, { 'merge' => 'unique' }) |\n| hiera_array($key, $default) | lookup($key, { 'default_value' => $default, 'merge' => 'unique' }) |\n| hiera_array($key, $default, $level) | override level not supported |\n\nNote that calls using the 'override level' option are not directly supported by 'lookup' and the produced\nresult must be post processed to get exactly the same result, for example using simple hash/array `+` or\nwith calls to stdlib's `deep_merge` function depending on kind of hiera call and setting of merge in hiera.yaml.\n\nSee\n[the documentation](https://puppet.com/docs/hiera/latest/puppet.html#hiera-lookup-functions)\nfor more information about Hiera lookup functions.\n\n- Since 4.0.0\nDOC\n) do |*args|\n  Error.is4x('hiera_array')\nend"
    },
    {
      "name"=>"hiera_array",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/hiera_array.rb",
      "line"=>75,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"hiera_array()",
          "docstring"=>{
            "text"=>"Finds all matches of a key throughout the hierarchy and returns them as a single flattened\narray of unique values. If any of the matched values are arrays, they're flattened and\nincluded in the results. This is called an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge).\n\nThis function is deprecated in favor of the `lookup` function. While this function\ncontinues to work, it does **not** support:\n* `lookup_options` stored in the data\n* lookup across global, environment, and module layers\n\nThe `hiera_array` function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\n```yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming common.yaml:\n# users:\n#   - 'cdouglas = regular'\n#   - 'efranklin = regular'\n\n# Assuming web01.example.com.yaml:\n# users: 'abarry = admin'\n```\n\n```puppet\n$allusers = hiera_array('users', undef)\n\n# $allusers contains [\"cdouglas = regular\", \"efranklin = regular\", \"abarry = admin\"].\n```\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n```puppet\n# Assuming the same Hiera data as the previous example:\n\n$allusers = hiera_array('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $allusers contains [\"cdouglas = regular\", \"efranklin = regular\", \"abarry = admin\"].\n# If hiera_array couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n```\n\n`hiera_array` expects that all values returned will be strings or arrays. If any matched\nvalue is a hash, Puppet raises a type mismatch error.\n\nSee\n[the 'Using the lookup function' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html) for how to perform lookup of data.\nAlso see\n[the 'Using the deprecated hiera functions' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html)\nfor more information about the Hiera 3 functions.",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `hiera_array`"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `hiera_array` with a lambda"
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Finds all matches of a key throughout the hierarchy and returns them as a single flattened\narray of unique values. If any of the matched values are arrays, they're flattened and\nincluded in the results. This is called an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge).\n\nThis function is deprecated in favor of the `lookup` function. While this function\ncontinues to work, it does **not** support:\n* `lookup_options` stored in the data\n* lookup across global, environment, and module layers\n\nThe `hiera_array` function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\n```yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming common.yaml:\n# users:\n#   - 'cdouglas = regular'\n#   - 'efranklin = regular'\n\n# Assuming web01.example.com.yaml:\n# users: 'abarry = admin'\n```\n\n```puppet\n$allusers = hiera_array('users', undef)\n\n# $allusers contains [\"cdouglas = regular\", \"efranklin = regular\", \"abarry = admin\"].\n```\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n```puppet\n# Assuming the same Hiera data as the previous example:\n\n$allusers = hiera_array('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $allusers contains [\"cdouglas = regular\", \"efranklin = regular\", \"abarry = admin\"].\n# If hiera_array couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n```\n\n`hiera_array` expects that all values returned will be strings or arrays. If any matched\nvalue is a hash, Puppet raises a type mismatch error.\n\nSee\n[the 'Using the lookup function' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html) for how to perform lookup of data.\nAlso see\n[the 'Using the deprecated hiera functions' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html)\nfor more information about the Hiera 3 functions.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `hiera_array`"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `hiera_array` with a lambda"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:hiera_array, Hiera::PuppetFunction) do\n  init_dispatch\n\n  def merge_type\n    :unique\n  end\nend"
    },
    {
      "name"=>"hiera_hash",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/hiera_hash.rb",
      "line"=>4,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"hiera_hash()",
          "docstring"=>{
            "text"=>"Finds all matches of a key throughout the hierarchy and returns them in a merged hash.\nIf any of the matched hashes share keys, the final hash uses the value from the\nhighest priority match. This is called a\n[hash merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#hash-merge).\n\nThe merge strategy is determined by Hiera's\n[`:merge_behavior`](https://puppet.com/docs/hiera/latest/configuring.html#mergebehavior)\nsetting.\n\nThe `hiera_hash` function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\n**Example**: Using `hiera_hash`\n\n~~~ yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming common.yaml:\n# users:\n#   regular:\n#     'cdouglas': 'Carrie Douglas'\n\n# Assuming web01.example.com.yaml:\n# users:\n#   administrators:\n#     'aberry': 'Amy Berry'\n~~~\n\n~~~ puppet\n# Assuming we are not web01.example.com:\n\n$allusers = hiera_hash('users', undef)\n\n# $allusers contains {regular => {\"cdouglas\" => \"Carrie Douglas\"},\n#                     administrators => {\"aberry\" => \"Amy Berry\"}}\n~~~\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n**Example**: Using `hiera_hash` with a lambda\n\n~~~ puppet\n# Assuming the same Hiera data as the previous example:\n\n$allusers = hiera_hash('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $allusers contains {regular => {\"cdouglas\" => \"Carrie Douglas\"},\n#                     administrators => {\"aberry\" => \"Amy Berry\"}}\n# If hiera_hash couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n~~~\n\n`hiera_hash` expects that all values returned will be hashes. If any of the values\nfound in the data sources are strings or arrays, Puppet raises a type mismatch error.\n\n`hiera_hash` is deprecated in favor of using `lookup` and will be removed in 6.0.0.\nSee  https://puppet.com/docs/puppet/\#{Puppet.minor_version}/deprecated_language.html.\nReplace the calls as follows:\n\n| from  | to |\n| ----  | ---|\n| hiera_hash($key) | lookup($key, { 'merge' => 'hash' }) |\n| hiera_hash($key, $default) | lookup($key, { 'default_value' => $default, 'merge' => 'hash' }) |\n| hiera_hash($key, $default, $level) | override level not supported |\n\nNote that calls using the 'override level' option are not directly supported by 'lookup' and the produced\nresult must be post processed to get exactly the same result, for example using simple hash/array `+` or\nwith calls to stdlib's `deep_merge` function depending on kind of hiera call and setting of merge in hiera.yaml.\n\nSee\n[the documentation](https://puppet.com/docs/hiera/latest/puppet.html#hiera-lookup-functions)\nfor more information about Hiera lookup functions.\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Finds all matches of a key throughout the hierarchy and returns them in a merged hash.\nIf any of the matched hashes share keys, the final hash uses the value from the\nhighest priority match. This is called a\n[hash merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#hash-merge).\n\nThe merge strategy is determined by Hiera's\n[`:merge_behavior`](https://puppet.com/docs/hiera/latest/configuring.html#mergebehavior)\nsetting.\n\nThe `hiera_hash` function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\n**Example**: Using `hiera_hash`\n\n~~~ yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming common.yaml:\n# users:\n#   regular:\n#     'cdouglas': 'Carrie Douglas'\n\n# Assuming web01.example.com.yaml:\n# users:\n#   administrators:\n#     'aberry': 'Amy Berry'\n~~~\n\n~~~ puppet\n# Assuming we are not web01.example.com:\n\n$allusers = hiera_hash('users', undef)\n\n# $allusers contains {regular => {\"cdouglas\" => \"Carrie Douglas\"},\n#                     administrators => {\"aberry\" => \"Amy Berry\"}}\n~~~\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n**Example**: Using `hiera_hash` with a lambda\n\n~~~ puppet\n# Assuming the same Hiera data as the previous example:\n\n$allusers = hiera_hash('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $allusers contains {regular => {\"cdouglas\" => \"Carrie Douglas\"},\n#                     administrators => {\"aberry\" => \"Amy Berry\"}}\n# If hiera_hash couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n~~~\n\n`hiera_hash` expects that all values returned will be hashes. If any of the values\nfound in the data sources are strings or arrays, Puppet raises a type mismatch error.\n\n`hiera_hash` is deprecated in favor of using `lookup` and will be removed in 6.0.0.\nSee  https://puppet.com/docs/puppet/\#{Puppet.minor_version}/deprecated_language.html.\nReplace the calls as follows:\n\n| from  | to |\n| ----  | ---|\n| hiera_hash($key) | lookup($key, { 'merge' => 'hash' }) |\n| hiera_hash($key, $default) | lookup($key, { 'default_value' => $default, 'merge' => 'hash' }) |\n| hiera_hash($key, $default, $level) | override level not supported |\n\nNote that calls using the 'override level' option are not directly supported by 'lookup' and the produced\nresult must be post processed to get exactly the same result, for example using simple hash/array `+` or\nwith calls to stdlib's `deep_merge` function depending on kind of hiera call and setting of merge in hiera.yaml.\n\nSee\n[the documentation](https://puppet.com/docs/hiera/latest/puppet.html#hiera-lookup-functions)\nfor more information about Hiera lookup functions.\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"newfunction(\n  :hiera_hash,\n  :type => :rvalue,\n  :arity => -2,\n  :doc => <<-DOC\nFinds all matches of a key throughout the hierarchy and returns them in a merged hash.\nIf any of the matched hashes share keys, the final hash uses the value from the\nhighest priority match. This is called a\n[hash merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#hash-merge).\n\nThe merge strategy is determined by Hiera's\n[`:merge_behavior`](https://puppet.com/docs/hiera/latest/configuring.html#mergebehavior)\nsetting.\n\nThe `hiera_hash` function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n  * If this argument isn't provided and this function results in a lookup failure, Puppet\n  fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n  * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n  searching the rest of the hierarchy.\n\n**Example**: Using `hiera_hash`\n\n~~~ yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming common.yaml:\n# users:\n#   regular:\n#     'cdouglas': 'Carrie Douglas'\n\n# Assuming web01.example.com.yaml:\n# users:\n#   administrators:\n#     'aberry': 'Amy Berry'\n~~~\n\n~~~ puppet\n# Assuming we are not web01.example.com:\n\n$allusers = hiera_hash('users', undef)\n\n# $allusers contains {regular => {\"cdouglas\" => \"Carrie Douglas\"},\n#                     administrators => {\"aberry\" => \"Amy Berry\"}}\n~~~\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n**Example**: Using `hiera_hash` with a lambda\n\n~~~ puppet\n# Assuming the same Hiera data as the previous example:\n\n$allusers = hiera_hash('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $allusers contains {regular => {\"cdouglas\" => \"Carrie Douglas\"},\n#                     administrators => {\"aberry\" => \"Amy Berry\"}}\n# If hiera_hash couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n~~~\n\n`hiera_hash` expects that all values returned will be hashes. If any of the values\nfound in the data sources are strings or arrays, Puppet raises a type mismatch error.\n\n`hiera_hash` is deprecated in favor of using `lookup` and will be removed in 6.0.0.\nSee  https://puppet.com/docs/puppet/\#{Puppet.minor_version}/deprecated_language.html.\nReplace the calls as follows:\n\n| from  | to |\n| ----  | ---|\n| hiera_hash($key) | lookup($key, { 'merge' => 'hash' }) |\n| hiera_hash($key, $default) | lookup($key, { 'default_value' => $default, 'merge' => 'hash' }) |\n| hiera_hash($key, $default, $level) | override level not supported |\n\nNote that calls using the 'override level' option are not directly supported by 'lookup' and the produced\nresult must be post processed to get exactly the same result, for example using simple hash/array `+` or\nwith calls to stdlib's `deep_merge` function depending on kind of hiera call and setting of merge in hiera.yaml.\n\nSee\n[the documentation](https://puppet.com/docs/hiera/latest/puppet.html#hiera-lookup-functions)\nfor more information about Hiera lookup functions.\n\n- Since 4.0.0\nDOC\n) do |*args|\n  Error.is4x('hiera_hash')\nend"
    },
    {
      "name"=>"hiera_hash",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/hiera_hash.rb",
      "line"=>86,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"hiera_hash()",
          "docstring"=>{
            "text"=>"Finds all matches of a key throughout the hierarchy and returns them in a merged hash.\n\nThis function is deprecated in favor of the `lookup` function. While this function\ncontinues to work, it does **not** support:\n* `lookup_options` stored in the data\n* lookup across global, environment, and module layers\n\nIf any of the matched hashes share keys, the final hash uses the value from the\nhighest priority match. This is called a\n[hash merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#hash-merge).\n\nThe merge strategy is determined by Hiera's\n[`:merge_behavior`](https://puppet.com/docs/hiera/latest/configuring.html#mergebehavior)\nsetting.\n\nThe `hiera_hash` function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\n```yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming common.yaml:\n# users:\n#   regular:\n#     'cdouglas': 'Carrie Douglas'\n\n# Assuming web01.example.com.yaml:\n# users:\n#   administrators:\n#     'aberry': 'Amy Berry'\n```\n\n```puppet\n# Assuming we are not web01.example.com:\n\n$allusers = hiera_hash('users', undef)\n\n# $allusers contains {regular => {\"cdouglas\" => \"Carrie Douglas\"},\n#                     administrators => {\"aberry\" => \"Amy Berry\"}}\n```\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n```puppet\n# Assuming the same Hiera data as the previous example:\n\n$allusers = hiera_hash('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $allusers contains {regular => {\"cdouglas\" => \"Carrie Douglas\"},\n#                     administrators => {\"aberry\" => \"Amy Berry\"}}\n# If hiera_hash couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n```\n\n`hiera_hash` expects that all values returned will be hashes. If any of the values\nfound in the data sources are strings or arrays, Puppet raises a type mismatch error.\n\nSee\n[the 'Using the lookup function' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html) for how to perform lookup of data.\nAlso see\n[the 'Using the deprecated hiera functions' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html)\nfor more information about the Hiera 3 functions.",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `hiera_hash`"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `hiera_hash` with a lambda"
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Finds all matches of a key throughout the hierarchy and returns them in a merged hash.\n\nThis function is deprecated in favor of the `lookup` function. While this function\ncontinues to work, it does **not** support:\n* `lookup_options` stored in the data\n* lookup across global, environment, and module layers\n\nIf any of the matched hashes share keys, the final hash uses the value from the\nhighest priority match. This is called a\n[hash merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#hash-merge).\n\nThe merge strategy is determined by Hiera's\n[`:merge_behavior`](https://puppet.com/docs/hiera/latest/configuring.html#mergebehavior)\nsetting.\n\nThe `hiera_hash` function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\n```yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming common.yaml:\n# users:\n#   regular:\n#     'cdouglas': 'Carrie Douglas'\n\n# Assuming web01.example.com.yaml:\n# users:\n#   administrators:\n#     'aberry': 'Amy Berry'\n```\n\n```puppet\n# Assuming we are not web01.example.com:\n\n$allusers = hiera_hash('users', undef)\n\n# $allusers contains {regular => {\"cdouglas\" => \"Carrie Douglas\"},\n#                     administrators => {\"aberry\" => \"Amy Berry\"}}\n```\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n```puppet\n# Assuming the same Hiera data as the previous example:\n\n$allusers = hiera_hash('users') | $key | { \"Key \\'${key}\\' not found\" }\n\n# $allusers contains {regular => {\"cdouglas\" => \"Carrie Douglas\"},\n#                     administrators => {\"aberry\" => \"Amy Berry\"}}\n# If hiera_hash couldn't match its key, it would return the lambda result,\n# \"Key 'users' not found\".\n```\n\n`hiera_hash` expects that all values returned will be hashes. If any of the values\nfound in the data sources are strings or arrays, Puppet raises a type mismatch error.\n\nSee\n[the 'Using the lookup function' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html) for how to perform lookup of data.\nAlso see\n[the 'Using the deprecated hiera functions' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html)\nfor more information about the Hiera 3 functions.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `hiera_hash`"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `hiera_hash` with a lambda"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:hiera_hash, Hiera::PuppetFunction) do\n  init_dispatch\n\n  def merge_type\n    :hash\n  end\nend"
    },
    {
      "name"=>"hiera_include",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/hiera_include.rb",
      "line"=>93,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"hiera_include()",
          "docstring"=>{
            "text"=>"Assigns classes to a node using an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge)\nthat retrieves the value for a user-specified key from Hiera's data.\n\nThis function is deprecated in favor of the `lookup` function in combination with `include`.\nWhile this function continues to work, it does **not** support:\n* `lookup_options` stored in the data\n* lookup across global, environment, and module layers\n\n```puppet\n# In site.pp, outside of any node definitions and below any top-scope variables:\nlookup('classes', Array[String], 'unique').include\n```\n\nThe `hiera_include` function requires:\n\n- A string key name to use for classes.\n- A call to this function (i.e. `hiera_include('classes')`) in your environment's\n`sites.pp` manifest, outside of any node definitions and below any top-scope variables\nthat Hiera uses in lookups.\n- `classes` keys in the appropriate Hiera data sources, with an array for each\n`classes` key and each value of the array containing the name of a class.\n\nThe function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\nThe function uses an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge)\nto retrieve the `classes` array, so every node gets every class from the hierarchy.\n\n```yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming web01.example.com.yaml:\n# classes:\n#   - apache::mod::php\n\n# Assuming common.yaml:\n# classes:\n#   - apache\n```\n\n```puppet\n# In site.pp, outside of any node definitions and below any top-scope variables:\nhiera_include('classes', undef)\n\n# Puppet assigns the apache and apache::mod::php classes to the web01.example.com node.\n```\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n```puppet\n# Assuming the same Hiera data as the previous example:\n\n# In site.pp, outside of any node definitions and below any top-scope variables:\nhiera_include('classes') | $key | {\"Key \\'${key}\\' not found\" }\n\n# Puppet assigns the apache and apache::mod::php classes to the web01.example.com node.\n# If hiera_include couldn't match its key, it would return the lambda result,\n# \"Key 'classes' not found\".\n```\n\nSee\n[the 'Using the lookup function' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html) for how to perform lookup of data.\nAlso see\n[the 'Using the deprecated hiera functions' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html)\nfor more information about the Hiera 3 functions.",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `lookup` and `include` instead of of the deprecated `hiera_include`"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `hiera_include`"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `hiera_include` with a lambda"
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Assigns classes to a node using an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge)\nthat retrieves the value for a user-specified key from Hiera's data.\n\nThis function is deprecated in favor of the `lookup` function in combination with `include`.\nWhile this function continues to work, it does **not** support:\n* `lookup_options` stored in the data\n* lookup across global, environment, and module layers\n\n```puppet\n# In site.pp, outside of any node definitions and below any top-scope variables:\nlookup('classes', Array[String], 'unique').include\n```\n\nThe `hiera_include` function requires:\n\n- A string key name to use for classes.\n- A call to this function (i.e. `hiera_include('classes')`) in your environment's\n`sites.pp` manifest, outside of any node definitions and below any top-scope variables\nthat Hiera uses in lookups.\n- `classes` keys in the appropriate Hiera data sources, with an array for each\n`classes` key and each value of the array containing the name of a class.\n\nThe function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\nThe function uses an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge)\nto retrieve the `classes` array, so every node gets every class from the hierarchy.\n\n```yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming web01.example.com.yaml:\n# classes:\n#   - apache::mod::php\n\n# Assuming common.yaml:\n# classes:\n#   - apache\n```\n\n```puppet\n# In site.pp, outside of any node definitions and below any top-scope variables:\nhiera_include('classes', undef)\n\n# Puppet assigns the apache and apache::mod::php classes to the web01.example.com node.\n```\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n```puppet\n# Assuming the same Hiera data as the previous example:\n\n# In site.pp, outside of any node definitions and below any top-scope variables:\nhiera_include('classes') | $key | {\"Key \\'${key}\\' not found\" }\n\n# Puppet assigns the apache and apache::mod::php classes to the web01.example.com node.\n# If hiera_include couldn't match its key, it would return the lambda result,\n# \"Key 'classes' not found\".\n```\n\nSee\n[the 'Using the lookup function' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html) for how to perform lookup of data.\nAlso see\n[the 'Using the deprecated hiera functions' documentation](https://puppet.com/docs/puppet/latest/hiera_automatic.html)\nfor more information about the Hiera 3 functions.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `lookup` and `include` instead of of the deprecated `hiera_include`"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `hiera_include`"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `hiera_include` with a lambda"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:hiera_include, Hiera::PuppetFunction) do\n  init_dispatch\n\n  def merge_type\n    :unique\n  end\n\n  def post_lookup(scope, key, value)\n    raise Puppet::ParseError, _(\"Could not find data item %{key}\") % { key: key } if value.nil?\n    call_function_with_scope(scope, 'include', value) unless value.empty?\n  end\nend"
    },
    {
      "name"=>"hiera_include",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/hiera_include.rb",
      "line"=>4,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"hiera_include()",
          "docstring"=>{
            "text"=>"Assigns classes to a node using an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge)\nthat retrieves the value for a user-specified key from Hiera's data.\n\nThe `hiera_include` function requires:\n\n- A string key name to use for classes.\n- A call to this function (i.e. `hiera_include('classes')`) in your environment's\n`sites.pp` manifest, outside of any node definitions and below any top-scope variables\nthat Hiera uses in lookups.\n- `classes` keys in the appropriate Hiera data sources, with an array for each\n`classes` key and each value of the array containing the name of a class.\n\nThe function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\nThe function uses an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge)\nto retrieve the `classes` array, so every node gets every class from the hierarchy.\n\n**Example**: Using `hiera_include`\n\n~~~ yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming web01.example.com.yaml:\n# classes:\n#   - apache::mod::php\n\n# Assuming common.yaml:\n# classes:\n#   - apache\n~~~\n\n~~~ puppet\n# In site.pp, outside of any node definitions and below any top-scope variables:\nhiera_include('classes', undef)\n\n# Puppet assigns the apache and apache::mod::php classes to the web01.example.com node.\n~~~\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n**Example**: Using `hiera_include` with a lambda\n\n~~~ puppet\n# Assuming the same Hiera data as the previous example:\n\n# In site.pp, outside of any node definitions and below any top-scope variables:\nhiera_include('classes') | $key | {\"Key \\'${key}\\' not found\" }\n\n# Puppet assigns the apache and apache::mod::php classes to the web01.example.com node.\n# If hiera_include couldn't match its key, it would return the lambda result,\n# \"Key 'classes' not found\".\n~~~\n\n`hiera_include` is deprecated in favor of using a combination of `include` and `lookup` and will be\nremoved in Puppet 6.0.0. Replace the calls as follows:\n\n| from  | to |\n| ----  | ---|\n| hiera_include($key) | include(lookup($key, { 'merge' => 'unique' })) |\n| hiera_include($key, $default) | include(lookup($key, { 'default_value' => $default, 'merge' => 'unique' })) |\n| hiera_include($key, $default, $level) | override level not supported |\n\nSee\n[the Upgrading to Hiera 5 migration guide](https://puppet.com/docs/puppet/5.5/hiera_migrate.html)\nfor more information.\n\nNote that calls using the 'override level' option are not directly supported by 'lookup' and the produced\nresult must be post processed to get exactly the same result, for example using simple hash/array `+` or\nwith calls to stdlib's `deep_merge` function depending on kind of hiera call and setting of merge in hiera.yaml.\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Assigns classes to a node using an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge)\nthat retrieves the value for a user-specified key from Hiera's data.\n\nThe `hiera_include` function requires:\n\n- A string key name to use for classes.\n- A call to this function (i.e. `hiera_include('classes')`) in your environment's\n`sites.pp` manifest, outside of any node definitions and below any top-scope variables\nthat Hiera uses in lookups.\n- `classes` keys in the appropriate Hiera data sources, with an array for each\n`classes` key and each value of the array containing the name of a class.\n\nThe function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n    * If this argument isn't provided and this function results in a lookup failure, Puppet\n    fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n    * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n    searching the rest of the hierarchy.\n\nThe function uses an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge)\nto retrieve the `classes` array, so every node gets every class from the hierarchy.\n\n**Example**: Using `hiera_include`\n\n~~~ yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming web01.example.com.yaml:\n# classes:\n#   - apache::mod::php\n\n# Assuming common.yaml:\n# classes:\n#   - apache\n~~~\n\n~~~ puppet\n# In site.pp, outside of any node definitions and below any top-scope variables:\nhiera_include('classes', undef)\n\n# Puppet assigns the apache and apache::mod::php classes to the web01.example.com node.\n~~~\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n**Example**: Using `hiera_include` with a lambda\n\n~~~ puppet\n# Assuming the same Hiera data as the previous example:\n\n# In site.pp, outside of any node definitions and below any top-scope variables:\nhiera_include('classes') | $key | {\"Key \\'${key}\\' not found\" }\n\n# Puppet assigns the apache and apache::mod::php classes to the web01.example.com node.\n# If hiera_include couldn't match its key, it would return the lambda result,\n# \"Key 'classes' not found\".\n~~~\n\n`hiera_include` is deprecated in favor of using a combination of `include` and `lookup` and will be\nremoved in Puppet 6.0.0. Replace the calls as follows:\n\n| from  | to |\n| ----  | ---|\n| hiera_include($key) | include(lookup($key, { 'merge' => 'unique' })) |\n| hiera_include($key, $default) | include(lookup($key, { 'default_value' => $default, 'merge' => 'unique' })) |\n| hiera_include($key, $default, $level) | override level not supported |\n\nSee\n[the Upgrading to Hiera 5 migration guide](https://puppet.com/docs/puppet/5.5/hiera_migrate.html)\nfor more information.\n\nNote that calls using the 'override level' option are not directly supported by 'lookup' and the produced\nresult must be post processed to get exactly the same result, for example using simple hash/array `+` or\nwith calls to stdlib's `deep_merge` function depending on kind of hiera call and setting of merge in hiera.yaml.\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"newfunction(\n  :hiera_include,\n  :arity => -2,\n  :doc => <<-DOC\nAssigns classes to a node using an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge)\nthat retrieves the value for a user-specified key from Hiera's data.\n\nThe `hiera_include` function requires:\n\n- A string key name to use for classes.\n- A call to this function (i.e. `hiera_include('classes')`) in your environment's\n`sites.pp` manifest, outside of any node definitions and below any top-scope variables\nthat Hiera uses in lookups.\n- `classes` keys in the appropriate Hiera data sources, with an array for each\n`classes` key and each value of the array containing the name of a class.\n\nThe function takes up to three arguments, in this order:\n\n1. A string key that Hiera searches for in the hierarchy. **Required**.\n2. An optional default value to return if Hiera doesn't find anything matching the key.\n  * If this argument isn't provided and this function results in a lookup failure, Puppet\n  fails with a compilation error.\n3. The optional name of an arbitrary\n[hierarchy level](https://puppet.com/docs/hiera/latest/hierarchy.html) to insert at the\ntop of the hierarchy. This lets you temporarily modify the hierarchy for a single lookup.\n  * If Hiera doesn't find a matching key in the overriding hierarchy level, it continues\n  searching the rest of the hierarchy.\n\nThe function uses an\n[array merge lookup](https://puppet.com/docs/hiera/latest/lookup_types.html#array-merge)\nto retrieve the `classes` array, so every node gets every class from the hierarchy.\n\n**Example**: Using `hiera_include`\n\n~~~ yaml\n# Assuming hiera.yaml\n# :hierarchy:\n#   - web01.example.com\n#   - common\n\n# Assuming web01.example.com.yaml:\n# classes:\n#   - apache::mod::php\n\n# Assuming common.yaml:\n# classes:\n#   - apache\n~~~\n\n~~~ puppet\n# In site.pp, outside of any node definitions and below any top-scope variables:\nhiera_include('classes', undef)\n\n# Puppet assigns the apache and apache::mod::php classes to the web01.example.com node.\n~~~\n\nYou can optionally generate the default value with a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) that\ntakes one parameter.\n\n**Example**: Using `hiera_include` with a lambda\n\n~~~ puppet\n# Assuming the same Hiera data as the previous example:\n\n# In site.pp, outside of any node definitions and below any top-scope variables:\nhiera_include('classes') | $key | {\"Key \\'${key}\\' not found\" }\n\n# Puppet assigns the apache and apache::mod::php classes to the web01.example.com node.\n# If hiera_include couldn't match its key, it would return the lambda result,\n# \"Key 'classes' not found\".\n~~~\n\n`hiera_include` is deprecated in favor of using a combination of `include` and `lookup` and will be\nremoved in Puppet 6.0.0. Replace the calls as follows:\n\n| from  | to |\n| ----  | ---|\n| hiera_include($key) | include(lookup($key, { 'merge' => 'unique' })) |\n| hiera_include($key, $default) | include(lookup($key, { 'default_value' => $default, 'merge' => 'unique' })) |\n| hiera_include($key, $default, $level) | override level not supported |\n\nSee\n[the Upgrading to Hiera 5 migration guide](https://puppet.com/docs/puppet/5.5/hiera_migrate.html)\nfor more information.\n\nNote that calls using the 'override level' option are not directly supported by 'lookup' and the produced\nresult must be post processed to get exactly the same result, for example using simple hash/array `+` or\nwith calls to stdlib's `deep_merge` function depending on kind of hiera call and setting of merge in hiera.yaml.\n\n- Since 4.0.0\nDOC\n) do |*args|\n  Error.is4x('hiera_include')\nend"
    },
    {
      "name"=>"hocon_data",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/hocon_data.rb",
      "line"=>9,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"hocon_data(Struct[{path=>String[1]}] $options, Puppet::LookupContext $context)",
          "docstring"=>{
            "text"=>"The `hocon_data` is a hiera 5 `data_hash` data provider function.\nSee [the configuration guide documentation](https://puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#configuring-a-hierarchy-level-built-in-backends) for\nhow to use this function.\n\nNote that this function is not supported without a hocon library being present.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Struct[{path=>String[1]}]"
                ],
                "name"=>"options"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Puppet::LookupContext"
                ],
                "name"=>"context"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"The `hocon_data` is a hiera 5 `data_hash` data provider function.\nSee [the configuration guide documentation](https://puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#configuring-a-hierarchy-level-built-in-backends) for\nhow to use this function.\n\nNote that this function is not supported without a hocon library being present.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Struct[{path=>String[1]}]"
            ],
            "name"=>"options"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Puppet::LookupContext"
            ],
            "name"=>"context"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.9.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:hocon_data) do\n  unless Puppet.features.hocon?\n    raise Puppet::DataBinding::LookupError, _('Lookup using Hocon data_hash function is not supported without hocon library')\n  end\n\n  require 'hocon'\n  require 'hocon/config_error'\n\n  dispatch :hocon_data do\n    param 'Struct[{path=>String[1]}]', :options\n    param 'Puppet::LookupContext', :context\n  end\n\n  argument_mismatch :missing_path do\n    param 'Hash', :options\n    param 'Puppet::LookupContext', :context\n  end\n\n  def hocon_data(options, context)\n    path = options['path']\n    context.cached_file_data(path) do |content|\n      begin\n        Hocon.parse(content)\n      rescue Hocon::ConfigError => ex\n        raise Puppet::DataBinding::LookupError, _(\"Unable to parse (%{path}): %{message}\") % { path: path, message: ex.message }\n      end\n    end\n  end\n\n  def missing_path(options, context)\n    \"one of 'path', 'paths' 'glob', 'globs' or 'mapped_paths' must be declared in hiera.yaml when using this data_hash function\"\n  end\nend"
    },
    {
      "name"=>"import",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/import.rb",
      "line"=>3,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"import(Any *$args)",
          "docstring"=>{
            "text"=>"The import function raises an error when called to inform the user that import is no longer supported.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"*args"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"The import function raises an error when called to inform the user that import is no longer supported.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Any"
            ],
            "name"=>"*args"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:import) do\n  def import(*args)\n    raise Puppet::Pops::SemanticError.new(Puppet::Pops::Issues::DISCONTINUED_IMPORT)\n  end\nend"
    },
    {
      "name"=>"include",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/include.rb",
      "line"=>2,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"include()",
          "docstring"=>{
            "text"=>"Declares one or more classes, causing the resources in them to be\nevaluated and added to the catalog. Accepts a class name, an array of class\nnames, or a comma-separated list of class names.\n\nThe `include` function can be used multiple times on the same class and will\nonly declare a given class once. If a class declared with `include` has any\nparameters, Puppet will automatically look up values for them in Hiera, using\n`<class name>::<parameter name>` as the lookup key.\n\nContrast this behavior with resource-like class declarations\n(`class {'name': parameter => 'value',}`), which must be used in only one place\nper class and can directly set parameters. You should avoid using both `include`\nand resource-like declarations with the same class.\n\nThe `include` function does not cause classes to be contained in the class\nwhere they are declared. For that, see the `contain` function. It also\ndoes not create a dependency relationship between the declared class and the\nsurrounding class; for that, see the `require` function.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use Class and Resource Type values that are produced by\nthe future parser's resource and relationship expressions.\n\n- Since < 3.0.0\n- Since 4.0.0 support for class and resource type values, absolute names\n- Since 4.7.0 returns an Array[Type[Class]] of all included classes",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Declares one or more classes, causing the resources in them to be\nevaluated and added to the catalog. Accepts a class name, an array of class\nnames, or a comma-separated list of class names.\n\nThe `include` function can be used multiple times on the same class and will\nonly declare a given class once. If a class declared with `include` has any\nparameters, Puppet will automatically look up values for them in Hiera, using\n`<class name>::<parameter name>` as the lookup key.\n\nContrast this behavior with resource-like class declarations\n(`class {'name': parameter => 'value',}`), which must be used in only one place\nper class and can directly set parameters. You should avoid using both `include`\nand resource-like declarations with the same class.\n\nThe `include` function does not cause classes to be contained in the class\nwhere they are declared. For that, see the `contain` function. It also\ndoes not create a dependency relationship between the declared class and the\nsurrounding class; for that, see the `require` function.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use Class and Resource Type values that are produced by\nthe future parser's resource and relationship expressions.\n\n- Since < 3.0.0\n- Since 4.0.0 support for class and resource type values, absolute names\n- Since 4.7.0 returns an Array[Type[Class]] of all included classes",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:include, :arity => -2, :doc =>\n\"Declares one or more classes, causing the resources in them to be\nevaluated and added to the catalog. Accepts a class name, an array of class\nnames, or a comma-separated list of class names.\n\nThe `include` function can be used multiple times on the same class and will\nonly declare a given class once. If a class declared with `include` has any\nparameters, Puppet will automatically look up values for them in Hiera, using\n`<class name>::<parameter name>` as the lookup key.\n\nContrast this behavior with resource-like class declarations\n(`class {'name': parameter => 'value',}`), which must be used in only one place\nper class and can directly set parameters. You should avoid using both `include`\nand resource-like declarations with the same class.\n\nThe `include` function does not cause classes to be contained in the class\nwhere they are declared. For that, see the `contain` function. It also\ndoes not create a dependency relationship between the declared class and the\nsurrounding class; for that, see the `require` function.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use Class and Resource Type values that are produced by\nthe future parser's resource and relationship expressions.\n\n- Since < 3.0.0\n- Since 4.0.0 support for class and resource type values, absolute names\n- Since 4.7.0 returns an Array[Type[Class]] of all included classes \n\") do |classes|\n  call_function('include', classes)\n  #TRANSLATORS \"function_include\", \"Scope\", and \"Scope#call_function\" refer to Puppet internals and should not be translated\n  Puppet.warn_once('deprecations', '3xfunction#include', _(\"Calling function_include via the Scope class is deprecated. Use Scope#call_function instead\"))\nend"
    },
    {
      "name"=>"include",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/include.rb",
      "line"=>29,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"include(Any *$names)",
          "docstring"=>{
            "text"=>"Declares one or more classes, causing the resources in them to be\nevaluated and added to the catalog. Accepts a class name, an array of class\nnames, or a comma-separated list of class names.\n\nThe `include` function can be used multiple times on the same class and will\nonly declare a given class once. If a class declared with `include` has any\nparameters, Puppet will automatically look up values for them in Hiera, using\n`<class name>::<parameter name>` as the lookup key.\n\nContrast this behavior with resource-like class declarations\n(`class {'name': parameter => 'value',}`), which must be used in only one place\nper class and can directly set parameters. You should avoid using both `include`\nand resource-like declarations with the same class.\n\nThe `include` function does not cause classes to be contained in the class\nwhere they are declared. For that, see the `contain` function. It also\ndoes not create a dependency relationship between the declared class and the\nsurrounding class; for that, see the `require` function.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use `Class` and `Resource` `Type`-values that are produced by\nthe resource and relationship expressions.\n\n- Since < 3.0.0\n- Since 4.0.0 support for class and resource type values, absolute names\n- Since 4.7.0 returns an `Array[Type[Class]]` of all included classes",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"*names"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Declares one or more classes, causing the resources in them to be\nevaluated and added to the catalog. Accepts a class name, an array of class\nnames, or a comma-separated list of class names.\n\nThe `include` function can be used multiple times on the same class and will\nonly declare a given class once. If a class declared with `include` has any\nparameters, Puppet will automatically look up values for them in Hiera, using\n`<class name>::<parameter name>` as the lookup key.\n\nContrast this behavior with resource-like class declarations\n(`class {'name': parameter => 'value',}`), which must be used in only one place\nper class and can directly set parameters. You should avoid using both `include`\nand resource-like declarations with the same class.\n\nThe `include` function does not cause classes to be contained in the class\nwhere they are declared. For that, see the `contain` function. It also\ndoes not create a dependency relationship between the declared class and the\nsurrounding class; for that, see the `require` function.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use `Class` and `Resource` `Type`-values that are produced by\nthe resource and relationship expressions.\n\n- Since < 3.0.0\n- Since 4.0.0 support for class and resource type values, absolute names\n- Since 4.7.0 returns an `Array[Type[Class]]` of all included classes",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Any"
            ],
            "name"=>"*names"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:include, Puppet::Functions::InternalFunction) do\n  dispatch :include do\n    scope_param\n    # The function supports what the type system sees as Ruby runtime objects, and\n    # they cannot be parameterized to find what is actually valid instances.\n    # The validation is instead done in the function body itself via a call to\n    # `transform_and_assert_classnames` on the calling scope.\n    required_repeated_param 'Any', :names\n  end\n\n  def include(scope, *classes)\n    if Puppet[:tasks]\n      raise Puppet::ParseErrorWithIssue.from_issue_and_stack(\n        Puppet::Pops::Issues::CATALOG_OPERATION_NOT_SUPPORTED_WHEN_SCRIPTING,\n        {:operation => 'include'})\n    end\n\n    classes = scope.transform_and_assert_classnames(classes.flatten)\n    result = classes.map {|name| Puppet::Pops::Types::TypeFactory.host_class(name) }\n    scope.compiler.evaluate_classes(classes, scope, false)\n\n    # Result is an Array[Class, 1, n] which allows chaining other operations\n    result\n  end\nend"
    },
    {
      "name"=>"index",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/index.rb",
      "line"=>92,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"index(Hash[Any, Any] $hash, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Any, Any]"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"index(Hash[Any, Any] $hash, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Any, Any]"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"index(Iterable $enumerable, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"index(Iterable $enumerable, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"index(String $str, Variant[String,Regexp] $match)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"str"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Variant[String,Regexp]"
                ],
                "name"=>"match"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"index(Iterable $enumerable, Any $match)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"match"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns the index (or key in a hash) to a first-found value in an `Iterable` value.\n\nWhen called with a  [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nthe lambda is called repeatedly using each value in a data structure until the lambda returns a \"truthy\" value which\nmakes the function return the index or key, or if the end of the iteration is reached, undef is returned.\n\nThis function can be called in two different ways; with a value to be searched for, or with\na lambda that determines if an entry in the iterable matches.\n\nWhen called with a lambda the function takes two mandatory arguments, in this order:\n\n1. An array, hash, string, or other iterable object that the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can request one (value) or two (index/key, value) parameters.\n\n`$data.index |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`index($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\n```puppet\n$data = [\"routers\", \"servers\", \"workstations\"]\nnotice $data.index |$value| { $value == 'servers' } # notices 1\nnotice $data.index |$value| { $value == 'hosts'  }  # notices undef\n```\n\n```puppet\n$data = {types => [\"routers\", \"servers\", \"workstations\"], colors => ['red', 'blue', 'green']}\nnotice $data.index |$value| { 'servers' in $value } # notices 'types'\nnotice $data.index |$value| { 'red' in $value }     # notices 'colors'\n```\nNote that the lambda gets the value and not an array with `[key, value]` as in other\niterative functions.\n\nUsing a lambda that accepts two values works the same way, it simply gets the index/key \nas the first parameter, and the value as the second.\n\n```puppet\n# Find the first even numbered index that has a non String value\n$data = [key1, 1, 3, 5]\nnotice $data.index |$idx, $value| { $idx % 2 == 0 and $value !~ String } # notices 2\n```\n\nWhen called on a `String`, the lambda is given each character as a value. What is typically wanted is to\nfind a sequence of characters which is achieved by calling the function with a value to search for instead\nof giving a lambda.\n\n\n```puppet\n# Find first occurrence of 'ah'\n$data = \"blablahbleh\"\nnotice $data.index('ah') # notices 5\n```\n\n```puppet\n# Find first occurrence of 'la' or 'le'\n$data = \"blablahbleh\"\nnotice $data.index(/l(a|e)/ # notices 1\n```\n\nWhen searching in a `String` with a given value that is neither `String` nor `Regexp` the answer is always `undef`.\nWhen searching in any other iterable, the value is matched against each value in the iteration using strict\nRuby `==` semantics. If Puppet Language semantics are wanted (where string compare is case insensitive) use a\nlambda and the `==` operator in Puppet.\n\n```puppet\n$data = ['routers', 'servers', 'WORKstations']\nnotice $data.index('servers')      # notices 1\nnotice $data.index('workstations') # notices undef (not matching case)\n```\n\nFor an general examples that demonstrates iteration, see the Puppet\n[iteration](https://puppet.com/docs/puppet/latest/lang_iteration.html)\ndocumentation.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `index` function"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `index` function with an Array and a one-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `index` function with a Hash and a one-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `index` function with an Array and a two-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `index` function with a String, search for first occurrence of a sequence of characters"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `index` function with a String, search for first occurrence of a regular expression"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `index` function to search for a given value in an Array"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"index(Hash[Any, Any] $hash, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Any, Any]"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"index"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"index(Hash[Any, Any] $hash, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Any, Any]"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"index"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"index(Iterable $enumerable, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"index"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"index(Iterable $enumerable, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"index"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"index(String $str, Variant[String,Regexp] $match)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"str"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Variant[String,Regexp]"
                  ],
                  "name"=>"match"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"index"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"index(Iterable $enumerable, Any $match)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"match"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"index"
          },
          {
            "tag_name"=>"since",
            "text"=>"6.3.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:index) do\n  dispatch :index_Hash_2 do\n    param 'Hash[Any, Any]', :hash\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :index_Hash_1 do\n    param 'Hash[Any, Any]', :hash\n    block_param 'Callable[1,1]', :block\n  end\n\n  dispatch :index_Enumerable_2 do\n    param 'Iterable', :enumerable\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :index_Enumerable_1 do\n    param 'Iterable', :enumerable\n    block_param 'Callable[1,1]', :block\n  end\n\n  dispatch :string_index do\n    param 'String', :str\n    param 'Variant[String,Regexp]', :match\n  end\n\n  dispatch :index_value do\n    param 'Iterable', :enumerable\n    param 'Any', :match\n  end\n\n\n  def index_Hash_1(hash)\n    hash.each_pair { |x, y| return x if yield(y)  }\n    nil\n  end\n\n  def index_Hash_2(hash)\n    hash.each_pair.any? { |x, y| return x if yield(x, y) }\n    nil\n  end\n\n  def index_Enumerable_1(enumerable)\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n    if enum.hash_style?\n      enum.each { |entry| return entry[0] if yield(entry[1]) }\n    else\n      enum.each_with_index { |e, i| return i if yield(e) }\n    end\n    nil\n  end\n\n  def index_Enumerable_2(enumerable)\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n    if enum.hash_style?\n      enum.each { |entry| return entry[0] if yield(*entry) }\n    else\n      enum.each_with_index { |e, i| return i if yield(i, e) }\n    end\n    nil\n  end\n\n  def string_index(str, match)\n    str.index(match)\n  end\n\n  def index_value(enumerable, match)\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n    if enum.hash_style?\n      enum.each { |entry| return entry[0] if entry[1] == match }\n    else\n      enum.each_with_index { |e, i| return i if e == match }\n    end\n    nil\n  end\nend"
    },
    {
      "name"=>"info",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/info.rb",
      "line"=>2,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"info(Any *$values)",
          "docstring"=>{
            "text"=>"Logs a message on the server at level `info`.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"The values to log.",
                "types"=>[
                  "Any"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Undef"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Logs a message on the server at level `info`.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"The values to log.",
            "types"=>[
              "Any"
            ],
            "name"=>"*values"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Undef"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:info, Puppet::Functions::InternalFunction) do\n  # @param values The values to log.\n  # @return [Undef]\n  dispatch :info do\n    scope_param\n    repeated_param 'Any', :values\n    return_type 'Undef'\n  end\n\n  def info(scope, *values)\n    Puppet::Util::Log.log_func(scope, :info, values)\n  end\nend"
    },
    {
      "name"=>"inline_epp",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/inline_epp.rb",
      "line"=>48,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"inline_epp(String $template, Optional[Hash[Pattern[/^\\w+$/], Any]] $parameters)",
          "docstring"=>{
            "text"=>"Evaluates an Embedded Puppet (EPP) template string and returns the rendered\ntext result as a String.\n\n`inline_epp('<EPP TEMPLATE STRING>', <PARAMETER HASH>)`\n\nThe first argument to this function should be a string containing an EPP\ntemplate. In most cases, the last argument is optional; if used, it should be a\n[hash](https://puppet.com/docs/puppet/latest/lang_data_hash.html) that contains parameters to\npass to the template.\n\n- See the [template](https://puppet.com/docs/puppet/latest/lang_template.html)\ndocumentation for general template usage information.\n- See the [EPP syntax](https://puppet.com/docs/puppet/latest/lang_template_epp.html)\ndocumentation for examples of EPP.\n\nFor example, to evaluate an inline EPP template and pass it the `docroot` and\n`virtual_docroot` parameters, call the `inline_epp` function like this:\n\n`inline_epp('docroot: <%= $docroot %> Virtual docroot: <%= $virtual_docroot %>',\n{ 'docroot' => '/var/www/html', 'virtual_docroot' => '/var/www/example' })`\n\nPuppet produces a syntax error if you pass more parameters than are declared in\nthe template's parameter tag. When passing parameters to a template that\ncontains a parameter tag, use the same names as the tag's declared parameters.\n\nParameters are required only if they are declared in the called template's\nparameter tag without default values. Puppet produces an error if the\n`inline_epp` function fails to pass any required parameter.\n\nAn inline EPP template should be written as a single-quoted string or\n[heredoc](https://puppet.com/docs/puppet/latest/lang_data_string.html#heredocs).\nA double-quoted string is subject to expression interpolation before the string\nis parsed as an EPP template.\n\nFor example, to evaluate an inline EPP template using a heredoc, call the\n`inline_epp` function like this:\n\n```puppet\n# Outputs 'Hello given argument planet!'\ninline_epp(@(END), { x => 'given argument' })\n<%- | $x, $y = planet | -%>\nHello <%= $x %> <%= $y %>!\nEND\n```",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"template"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Hash[Pattern[/^\\w+$/], Any]]"
                ],
                "name"=>"parameters"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Variant[String, Sensitive[String]]"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Evaluates an Embedded Puppet (EPP) template string and returns the rendered\ntext result as a String.\n\n`inline_epp('<EPP TEMPLATE STRING>', <PARAMETER HASH>)`\n\nThe first argument to this function should be a string containing an EPP\ntemplate. In most cases, the last argument is optional; if used, it should be a\n[hash](https://puppet.com/docs/puppet/latest/lang_data_hash.html) that contains parameters to\npass to the template.\n\n- See the [template](https://puppet.com/docs/puppet/latest/lang_template.html)\ndocumentation for general template usage information.\n- See the [EPP syntax](https://puppet.com/docs/puppet/latest/lang_template_epp.html)\ndocumentation for examples of EPP.\n\nFor example, to evaluate an inline EPP template and pass it the `docroot` and\n`virtual_docroot` parameters, call the `inline_epp` function like this:\n\n`inline_epp('docroot: <%= $docroot %> Virtual docroot: <%= $virtual_docroot %>',\n{ 'docroot' => '/var/www/html', 'virtual_docroot' => '/var/www/example' })`\n\nPuppet produces a syntax error if you pass more parameters than are declared in\nthe template's parameter tag. When passing parameters to a template that\ncontains a parameter tag, use the same names as the tag's declared parameters.\n\nParameters are required only if they are declared in the called template's\nparameter tag without default values. Puppet produces an error if the\n`inline_epp` function fails to pass any required parameter.\n\nAn inline EPP template should be written as a single-quoted string or\n[heredoc](https://puppet.com/docs/puppet/latest/lang_data_string.html#heredocs).\nA double-quoted string is subject to expression interpolation before the string\nis parsed as an EPP template.\n\nFor example, to evaluate an inline EPP template using a heredoc, call the\n`inline_epp` function like this:\n\n```puppet\n# Outputs 'Hello given argument planet!'\ninline_epp(@(END), { x => 'given argument' })\n<%- | $x, $y = planet | -%>\nHello <%= $x %> <%= $y %>!\nEND\n```",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "String"
            ],
            "name"=>"template"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Hash[Pattern[/^\\w+$/], Any]]"
            ],
            "name"=>"parameters"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Variant[String, Sensitive[String]]"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:inline_epp, Puppet::Functions::InternalFunction) do\n\n  dispatch :inline_epp do\n    scope_param()\n    param 'String', :template\n    optional_param 'Hash[Pattern[/^\\w+$/], Any]', :parameters\n    return_type 'Variant[String, Sensitive[String]]'\n  end\n\n  def inline_epp(scope, template, parameters = nil)\n    Puppet::Pops::Evaluator::EppEvaluator.inline_epp(scope, template, parameters)\n  end\nend"
    },
    {
      "name"=>"inline_epp",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/inline_epp.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"inline_epp()",
          "docstring"=>{
            "text"=>"Evaluates an Embedded Puppet (EPP) template string and returns the rendered\ntext result as a String.\n\n`inline_epp('<EPP TEMPLATE STRING>', <PARAMETER HASH>)`\n\nThe first argument to this function should be a string containing an EPP\ntemplate. In most cases, the last argument is optional; if used, it should be a\n[hash](https://puppet.com/docs/puppet/latest/lang_data_hash.html) that contains parameters to\npass to the template.\n\n- See the [template](https://puppet.com/docs/puppet/latest/lang_template.html) documentation\nfor general template usage information.\n- See the [EPP syntax](https://puppet.com/docs/puppet/latest/lang_template_epp.html)\ndocumentation for examples of EPP.\n\nFor example, to evaluate an inline EPP template and pass it the `docroot` and\n`virtual_docroot` parameters, call the `inline_epp` function like this:\n\n`inline_epp('docroot: <%= $docroot %> Virtual docroot: <%= $virtual_docroot %>',\n{ 'docroot' => '/var/www/html', 'virtual_docroot' => '/var/www/example' })`\n\nPuppet produces a syntax error if you pass more parameters than are declared in\nthe template's parameter tag. When passing parameters to a template that\ncontains a parameter tag, use the same names as the tag's declared parameters.\n\nParameters are required only if they are declared in the called template's\nparameter tag without default values. Puppet produces an error if the\n`inline_epp` function fails to pass any required parameter.\n\nAn inline EPP template should be written as a single-quoted string or\n[heredoc](https://puppet.com/docs/puppet/latest/lang_data_string.html#heredocs).\nA double-quoted string is subject to expression interpolation before the string\nis parsed as an EPP template.\n\nFor example, to evaluate an inline EPP template using a heredoc, call the\n`inline_epp` function like this:\n\n~~~ puppet\n# Outputs 'Hello given argument planet!'\ninline_epp(@(END), { x => 'given argument' })\n<%- | $x, $y = planet | -%>\nHello <%= $x %> <%= $y %>!\nEND\n~~~\n\n- Since 3.5\n- Requires [future parser](https://puppet.com/docs/puppet/3.8/experiments_future.html) in Puppet 3.5 to 3.8",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Evaluates an Embedded Puppet (EPP) template string and returns the rendered\ntext result as a String.\n\n`inline_epp('<EPP TEMPLATE STRING>', <PARAMETER HASH>)`\n\nThe first argument to this function should be a string containing an EPP\ntemplate. In most cases, the last argument is optional; if used, it should be a\n[hash](https://puppet.com/docs/puppet/latest/lang_data_hash.html) that contains parameters to\npass to the template.\n\n- See the [template](https://puppet.com/docs/puppet/latest/lang_template.html) documentation\nfor general template usage information.\n- See the [EPP syntax](https://puppet.com/docs/puppet/latest/lang_template_epp.html)\ndocumentation for examples of EPP.\n\nFor example, to evaluate an inline EPP template and pass it the `docroot` and\n`virtual_docroot` parameters, call the `inline_epp` function like this:\n\n`inline_epp('docroot: <%= $docroot %> Virtual docroot: <%= $virtual_docroot %>',\n{ 'docroot' => '/var/www/html', 'virtual_docroot' => '/var/www/example' })`\n\nPuppet produces a syntax error if you pass more parameters than are declared in\nthe template's parameter tag. When passing parameters to a template that\ncontains a parameter tag, use the same names as the tag's declared parameters.\n\nParameters are required only if they are declared in the called template's\nparameter tag without default values. Puppet produces an error if the\n`inline_epp` function fails to pass any required parameter.\n\nAn inline EPP template should be written as a single-quoted string or\n[heredoc](https://puppet.com/docs/puppet/latest/lang_data_string.html#heredocs).\nA double-quoted string is subject to expression interpolation before the string\nis parsed as an EPP template.\n\nFor example, to evaluate an inline EPP template using a heredoc, call the\n`inline_epp` function like this:\n\n~~~ puppet\n# Outputs 'Hello given argument planet!'\ninline_epp(@(END), { x => 'given argument' })\n<%- | $x, $y = planet | -%>\nHello <%= $x %> <%= $y %>!\nEND\n~~~\n\n- Since 3.5\n- Requires [future parser](https://puppet.com/docs/puppet/3.8/experiments_future.html) in Puppet 3.5 to 3.8",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:inline_epp, :type => :rvalue, :arity => -2, :doc =>\n\"Evaluates an Embedded Puppet (EPP) template string and returns the rendered\ntext result as a String.\n\n`inline_epp('<EPP TEMPLATE STRING>', <PARAMETER HASH>)`\n\nThe first argument to this function should be a string containing an EPP\ntemplate. In most cases, the last argument is optional; if used, it should be a\n[hash](https://puppet.com/docs/puppet/latest/lang_data_hash.html) that contains parameters to\npass to the template.\n\n- See the [template](https://puppet.com/docs/puppet/latest/lang_template.html) documentation\nfor general template usage information.\n- See the [EPP syntax](https://puppet.com/docs/puppet/latest/lang_template_epp.html)\ndocumentation for examples of EPP.\n\nFor example, to evaluate an inline EPP template and pass it the `docroot` and\n`virtual_docroot` parameters, call the `inline_epp` function like this:\n\n`inline_epp('docroot: <%= $docroot %> Virtual docroot: <%= $virtual_docroot %>',\n{ 'docroot' => '/var/www/html', 'virtual_docroot' => '/var/www/example' })`\n\nPuppet produces a syntax error if you pass more parameters than are declared in\nthe template's parameter tag. When passing parameters to a template that\ncontains a parameter tag, use the same names as the tag's declared parameters.\n\nParameters are required only if they are declared in the called template's\nparameter tag without default values. Puppet produces an error if the\n`inline_epp` function fails to pass any required parameter.\n\nAn inline EPP template should be written as a single-quoted string or\n[heredoc](https://puppet.com/docs/puppet/latest/lang_data_string.html#heredocs).\nA double-quoted string is subject to expression interpolation before the string\nis parsed as an EPP template.\n\nFor example, to evaluate an inline EPP template using a heredoc, call the\n`inline_epp` function like this:\n\n~~~ puppet\n# Outputs 'Hello given argument planet!'\ninline_epp(@(END), { x => 'given argument' })\n<%- | $x, $y = planet | -%>\nHello <%= $x %> <%= $y %>!\nEND\n~~~\n\n- Since 3.5\n- Requires [future parser](https://puppet.com/docs/puppet/3.8/experiments_future.html) in Puppet 3.5 to 3.8\") do |arguments|\n\n  Puppet::Parser::Functions::Error.is4x('inline_epp')\nend"
    },
    {
      "name"=>"inline_template",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/inline_template.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"inline_template()",
          "docstring"=>{
            "text"=>"Evaluate a template string and return its value.  See\n[the templating docs](https://puppet.com/docs/puppet/latest/lang_template.html) for\nmore information. Note that if multiple template strings are specified, their\noutput is all concatenated and returned as the output of the function.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Evaluate a template string and return its value.  See\n[the templating docs](https://puppet.com/docs/puppet/latest/lang_template.html) for\nmore information. Note that if multiple template strings are specified, their\noutput is all concatenated and returned as the output of the function.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:inline_template, :type => :rvalue, :arity => -2, :doc =>\n  \"Evaluate a template string and return its value.  See\n  [the templating docs](https://puppet.com/docs/puppet/latest/lang_template.html) for\n  more information. Note that if multiple template strings are specified, their\n  output is all concatenated and returned as the output of the function.\") do |vals|\n\n  if Puppet[:tasks]\n    raise Puppet::ParseErrorWithIssue.from_issue_and_stack(\n      Puppet::Pops::Issues::FEATURE_NOT_SUPPORTED_WHEN_SCRIPTING,\n      {:feature => 'ERB inline_template'})\n  end\n\n  require 'erb'\n\n    vals.collect do |string|\n      # Use a wrapper, so the template can't get access to the full\n      # Scope object.\n\n      wrapper = Puppet::Parser::TemplateWrapper.new(self)\n      begin\n        wrapper.result(string)\n      rescue => detail\n        raise Puppet::ParseError, _(\"Failed to parse inline template: %{detail}\") % { detail: detail }, detail.backtrace\n      end\n    end.join(\"\")\nend"
    },
    {
      "name"=>"join",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/join.rb",
      "line"=>47,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"join(Array $arg, Optional[String] $delimiter)",
          "docstring"=>{
            "text"=>"Joins the values of an Array into a string with elements separated by a delimiter.\n\nSupports up to two arguments\n* **values** - first argument is required and must be an an `Array`\n* **delimiter** - second arguments is the delimiter between elements, must be a `String` if given, and defaults to an empty string.\n\n```puppet\njoin(['a','b','c'], \",\")\n# Would result in: \"a,b,c\"\n```\n\nNote that array is flattened before elements are joined, but flattening does not extend to arrays nested in hashes or other objects.\n\n```puppet\n$a = [1,2, undef, 'hello', [x,y,z], {a => 2, b => [3, 4]}]\nnotice join($a, ', ')\n\n# would result in noticing:\n# 1, 2, , hello, x, y, z, {\"a\"=>2, \"b\"=>[3, 4]}\n```\n\nFor joining iterators and other containers of elements a conversion must first be made to\nan `Array`. The reason for this is that there are many options how such a conversion should\nbe made.\n\n```puppet\n[1,2,3].reverse_each.convert_to(Array).join(', ')\n# would result in: \"3, 2, 1\"\n```\n```puppet\n{a => 1, b => 2}.convert_to(Array).join(', ')\n# would result in \"a, 1, b, 2\"\n```\n\nFor more detailed control over the formatting (including indentations and line breaks, delimiters around arrays\nand hash entries, between key/values in hash entries, and individual formatting of values in the array)\nsee the `new` function for `String` and its formatting options for `Array` and `Hash`.",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Typical use of `join`"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Arrays nested in hashes are not joined"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Joining the result of a reverse_each converted to an array"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Joining a hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[String]"
                ],
                "name"=>"delimiter"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Joins the values of an Array into a string with elements separated by a delimiter.\n\nSupports up to two arguments\n* **values** - first argument is required and must be an an `Array`\n* **delimiter** - second arguments is the delimiter between elements, must be a `String` if given, and defaults to an empty string.\n\n```puppet\njoin(['a','b','c'], \",\")\n# Would result in: \"a,b,c\"\n```\n\nNote that array is flattened before elements are joined, but flattening does not extend to arrays nested in hashes or other objects.\n\n```puppet\n$a = [1,2, undef, 'hello', [x,y,z], {a => 2, b => [3, 4]}]\nnotice join($a, ', ')\n\n# would result in noticing:\n# 1, 2, , hello, x, y, z, {\"a\"=>2, \"b\"=>[3, 4]}\n```\n\nFor joining iterators and other containers of elements a conversion must first be made to\nan `Array`. The reason for this is that there are many options how such a conversion should\nbe made.\n\n```puppet\n[1,2,3].reverse_each.convert_to(Array).join(', ')\n# would result in: \"3, 2, 1\"\n```\n```puppet\n{a => 1, b => 2}.convert_to(Array).join(', ')\n# would result in \"a, 1, b, 2\"\n```\n\nFor more detailed control over the formatting (including indentations and line breaks, delimiters around arrays\nand hash entries, between key/values in hash entries, and individual formatting of values in the array)\nsee the `new` function for `String` and its formatting options for `Array` and `Hash`.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Typical use of `join`"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Arrays nested in hashes are not joined"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Joining the result of a reverse_each converted to an array"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Joining a hash"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Array"
            ],
            "name"=>"arg"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[String]"
            ],
            "name"=>"delimiter"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:join) do\n  dispatch :join do\n    param 'Array', :arg\n    optional_param 'String', :delimiter\n  end\n\n  def join(arg, delimiter = '', puppet_formatting = false)\n      arg.join(delimiter)\n  end\nend"
    },
    {
      "name"=>"json_data",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/json_data.rb",
      "line"=>7,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"json_data(Struct[{path=>String[1]}] $options, Puppet::LookupContext $context)",
          "docstring"=>{
            "text"=>"The `json_data` is a hiera 5 `data_hash` data provider function.\nSee [the configuration guide documentation](https://puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#configuring-a-hierarchy-level-built-in-backends) for\nhow to use this function.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Struct[{path=>String[1]}]"
                ],
                "name"=>"options"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Puppet::LookupContext"
                ],
                "name"=>"context"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"The `json_data` is a hiera 5 `data_hash` data provider function.\nSee [the configuration guide documentation](https://puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#configuring-a-hierarchy-level-built-in-backends) for\nhow to use this function.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Struct[{path=>String[1]}]"
            ],
            "name"=>"options"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Puppet::LookupContext"
            ],
            "name"=>"context"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.8.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:json_data) do\n  dispatch :json_data do\n    param 'Struct[{path=>String[1]}]', :options\n    param 'Puppet::LookupContext', :context\n  end\n\n  argument_mismatch :missing_path do\n    param 'Hash', :options\n    param 'Puppet::LookupContext', :context\n  end\n\n  def json_data(options, context)\n    path = options['path']\n    context.cached_file_data(path) do |content|\n      begin\n        Puppet::Util::Json.load(content)\n      rescue Puppet::Util::Json::ParseError => ex\n        # Filename not included in message, so we add it here.\n        raise Puppet::DataBinding::LookupError, \"Unable to parse (%{path}): %{message}\" % { path: path, message: ex.message }\n      end\n    end\n  end\n\n  def missing_path(options, context)\n    \"one of 'path', 'paths' 'glob', 'globs' or 'mapped_paths' must be declared in hiera.yaml when using this data_hash function\"\n  end\nend"
    },
    {
      "name"=>"keys",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/keys.rb",
      "line"=>17,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"keys(Hash $hsh)",
          "docstring"=>{
            "text"=>"Returns the keys of a hash as an Array\n\n```puppet\n$hsh = {\"apples\" => 3, \"oranges\" => 4 }\n$hsh.keys()\nkeys($hsh)\n# both results in the array [\"apples\", \"oranges\"]\n```\n\n* Note that a hash in the puppet language accepts any data value (including `undef`) unless\n  it is constrained with a `Hash` data type that narrows the allowed data types.\n* For an empty hash, an empty array is returned.\n* The order of the keys is the same as the order in the hash (typically the order in which they were added).",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `keys`"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash"
                ],
                "name"=>"hsh"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns the keys of a hash as an Array\n\n```puppet\n$hsh = {\"apples\" => 3, \"oranges\" => 4 }\n$hsh.keys()\nkeys($hsh)\n# both results in the array [\"apples\", \"oranges\"]\n```\n\n* Note that a hash in the puppet language accepts any data value (including `undef`) unless\n  it is constrained with a `Hash` data type that narrows the allowed data types.\n* For an empty hash, an empty array is returned.\n* The order of the keys is the same as the order in the hash (typically the order in which they were added).",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `keys`"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Hash"
            ],
            "name"=>"hsh"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:keys) do\n  dispatch :keys do\n    param 'Hash', :hsh\n  end\n\n  def keys(hsh)\n    hsh.keys\n  end\nend"
    },
    {
      "name"=>"length",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/length.rb",
      "line"=>19,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"length(Collection $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Collection"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"length(String $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"length(Binary $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Binary"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns the length of an Array, Hash, String, or Binary value.\n\nThe returned value is a positive integer indicating the number\nof elements in the container; counting (possibly multibyte) characters for a `String`,\nbytes in a `Binary`, number of elements in an `Array`, and number of\nkey-value associations in a Hash.\n\n```puppet\n\"roses\".length()        # 5\nlength(\"violets\")       # 7\n[10, 20].length         # 2\n{a => 1, b => 3}.length # 2\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `length`"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"length(Collection $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Collection"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"length"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"length(String $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"length"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"length(Binary $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Binary"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"length"
          },
          {
            "tag_name"=>"since",
            "text"=>"5.5.0 - also supporting Binary"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:length) do\n  dispatch :collection_length do\n    param 'Collection', :arg\n  end\n\n  dispatch :string_length do\n    param 'String', :arg\n  end\n\n  dispatch :binary_length do\n    param 'Binary', :arg\n  end\n\n  def collection_length(col)\n    col.size\n  end\n\n  def string_length(s)\n    s.length\n  end\n\n  def binary_length(bin)\n    bin.length\n  end\n\nend"
    },
    {
      "name"=>"lest",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/lest.rb",
      "line"=>42,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"lest(Any $arg, Callable[0,0] &$block)",
          "docstring"=>{
            "text"=>"Calls a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nwithout arguments if the value given to `lest` is `undef`.\nReturns the result of calling the lambda if the argument is `undef`, otherwise the\ngiven argument.\n\nThe `lest` function is useful in a chain of `then` calls, or in general\nas a guard against `undef` values. The function can be used to call `fail`, or to\nreturn a default value.\n\nThese two expressions are equivalent:\n\n```puppet\nif $x == undef { do_things() }\nlest($x) || { do_things() }\n```\n\n```puppet\n$data = {a => [ b, c ] }\nnotice $data.dig(a, b, c)\n .then |$x| { $x * 2 }\n .lest || { fail(\"no value for $data[a][b][c]\" }\n```\n\nWould fail the operation because $data[a][b][c] results in `undef`\n(there is no `b` key in `a`).\n\nIn contrast - this example:\n\n```puppet\n$data = {a => { b => { c => 10 } } }\nnotice $data.dig(a, b, c)\n .then |$x| { $x * 2 }\n .lest || { fail(\"no value for $data[a][b][c]\" }\n```\n\nWould notice the value `20`",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using the `lest` function"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[0,0]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Calls a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nwithout arguments if the value given to `lest` is `undef`.\nReturns the result of calling the lambda if the argument is `undef`, otherwise the\ngiven argument.\n\nThe `lest` function is useful in a chain of `then` calls, or in general\nas a guard against `undef` values. The function can be used to call `fail`, or to\nreturn a default value.\n\nThese two expressions are equivalent:\n\n```puppet\nif $x == undef { do_things() }\nlest($x) || { do_things() }\n```\n\n```puppet\n$data = {a => [ b, c ] }\nnotice $data.dig(a, b, c)\n .then |$x| { $x * 2 }\n .lest || { fail(\"no value for $data[a][b][c]\" }\n```\n\nWould fail the operation because $data[a][b][c] results in `undef`\n(there is no `b` key in `a`).\n\nIn contrast - this example:\n\n```puppet\n$data = {a => { b => { c => 10 } } }\nnotice $data.dig(a, b, c)\n .then |$x| { $x * 2 }\n .lest || { fail(\"no value for $data[a][b][c]\" }\n```\n\nWould notice the value `20`",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `lest` function"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Any"
            ],
            "name"=>"arg"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Callable[0,0]"
            ],
            "name"=>"&block"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.5.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:lest) do\n  dispatch :lest do\n    param 'Any', :arg\n    block_param 'Callable[0,0]', :block\n  end\n\n  def lest(arg)\n    if arg.nil?\n      yield()\n    else\n      arg\n    end\n  end\nend"
    },
    {
      "name"=>"lest",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/lest.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"lest()",
          "docstring"=>{
            "text"=>"Call a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\n(which should accept no arguments) if the argument given to the function is `undef`.\nReturns the result of calling the lambda if the argument is `undef`, otherwise the\ngiven argument.\n\nThe `lest` function is useful in a chain of `then` calls, or in general\nas a guard against `undef` values. The function can be used to call `fail`, or to\nreturn a default value.\n\nThese two expressions are equivalent:\n\n```puppet\nif $x == undef { do_things() }\nlest($x) || { do_things() }\n```\n\n**Example:** Using the `lest` function\n\n```puppet\n$data = {a => [ b, c ] }\nnotice $data.dig(a, b, c)\n .then |$x| { $x * 2 }\n .lest || { fail(\"no value for $data[a][b][c]\" }\n```\n\nWould fail the operation because $data[a][b][c] results in `undef`\n(there is no `b` key in `a`).\n\nIn contrast - this example:\n\n```puppet\n$data = {a => { b => { c => 10 } } }\nnotice $data.dig(a, b, c)\n .then |$x| { $x * 2 }\n .lest || { fail(\"no value for $data[a][b][c]\" }\n```\n\nWould notice the value `20`\n\n* Since 4.5.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Call a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\n(which should accept no arguments) if the argument given to the function is `undef`.\nReturns the result of calling the lambda if the argument is `undef`, otherwise the\ngiven argument.\n\nThe `lest` function is useful in a chain of `then` calls, or in general\nas a guard against `undef` values. The function can be used to call `fail`, or to\nreturn a default value.\n\nThese two expressions are equivalent:\n\n```puppet\nif $x == undef { do_things() }\nlest($x) || { do_things() }\n```\n\n**Example:** Using the `lest` function\n\n```puppet\n$data = {a => [ b, c ] }\nnotice $data.dig(a, b, c)\n .then |$x| { $x * 2 }\n .lest || { fail(\"no value for $data[a][b][c]\" }\n```\n\nWould fail the operation because $data[a][b][c] results in `undef`\n(there is no `b` key in `a`).\n\nIn contrast - this example:\n\n```puppet\n$data = {a => { b => { c => 10 } } }\nnotice $data.dig(a, b, c)\n .then |$x| { $x * 2 }\n .lest || { fail(\"no value for $data[a][b][c]\" }\n```\n\nWould notice the value `20`\n\n* Since 4.5.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :lest,\n  :type => :rvalue,\n  :arity => -2,\n  :doc => <<-DOC\nCall a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\n(which should accept no arguments) if the argument given to the function is `undef`.\nReturns the result of calling the lambda if the argument is `undef`, otherwise the\ngiven argument.\n\nThe `lest` function is useful in a chain of `then` calls, or in general\nas a guard against `undef` values. The function can be used to call `fail`, or to\nreturn a default value.\n\nThese two expressions are equivalent:\n\n```puppet\nif $x == undef { do_things() }\nlest($x) || { do_things() }\n```\n\n**Example:** Using the `lest` function\n\n```puppet\n$data = {a => [ b, c ] }\nnotice $data.dig(a, b, c)\n .then |$x| { $x * 2 }\n .lest || { fail(\"no value for $data[a][b][c]\" }\n```\n\nWould fail the operation because $data[a][b][c] results in `undef`\n(there is no `b` key in `a`).\n\nIn contrast - this example:\n\n```puppet\n$data = {a => { b => { c => 10 } } }\nnotice $data.dig(a, b, c)\n .then |$x| { $x * 2 }\n .lest || { fail(\"no value for $data[a][b][c]\" }\n```\n\nWould notice the value `20`\n\n* Since 4.5.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('lest')\nend"
    },
    {
      "name"=>"lookup",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/lookup.rb",
      "line"=>125,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"lookup(NameType $name, Optional[ValueType] $value_type, Optional[MergeType] $merge)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "NameType"
                ],
                "name"=>"name"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[ValueType]"
                ],
                "name"=>"value_type"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[MergeType]"
                ],
                "name"=>"merge"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"lookup(NameType $name, Optional[ValueType] $value_type, Optional[MergeType] $merge, DefaultValueType $default_value)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "NameType"
                ],
                "name"=>"name"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[ValueType]"
                ],
                "name"=>"value_type"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[MergeType]"
                ],
                "name"=>"merge"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "DefaultValueType"
                ],
                "name"=>"default_value"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"lookup(NameType $name, Optional[ValueType] $value_type, Optional[MergeType] $merge, BlockType &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "NameType"
                ],
                "name"=>"name"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[ValueType]"
                ],
                "name"=>"value_type"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[MergeType]"
                ],
                "name"=>"merge"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "BlockType"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"lookup(OptionsWithName $options_hash, Optional[BlockType] &$block)",
          "docstring"=>{
            "text"=>"Lookup without name. Name then becomes a required entry in the options hash",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "OptionsWithName"
                ],
                "name"=>"options_hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[BlockType]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"lookup(Variant[String,Array[String]] $name, OptionsWithoutName $options_hash, Optional[BlockType] &$block)",
          "docstring"=>{
            "text"=>"Lookup using name and options hash.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Variant[String,Array[String]]"
                ],
                "name"=>"name"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "OptionsWithoutName"
                ],
                "name"=>"options_hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[BlockType]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Uses the Puppet lookup system to retrieve a value for a given key. By default,\nthis returns the first value found (and fails compilation if no values are\navailable), but you can configure it to merge multiple values into one, fail\ngracefully, and more.\n\nWhen looking up a key, Puppet will search up to three tiers of data, in the\nfollowing order:\n\n1. Hiera.\n2. The current environment's data provider.\n3. The indicated module's data provider, if the key is of the form\n   `<MODULE NAME>::<SOMETHING>`.\n\n#### Arguments\n\nYou must provide the name of a key to look up, and can optionally provide other\narguments. You can combine these arguments in the following ways:\n\n* `lookup( <NAME>, [<VALUE TYPE>], [<MERGE BEHAVIOR>], [<DEFAULT VALUE>] )`\n* `lookup( [<NAME>], <OPTIONS HASH> )`\n* `lookup( as above ) |$key| { # lambda returns a default value }`\n\nArguments in `[square brackets]` are optional.\n\nThe arguments accepted by `lookup` are as follows:\n\n1. `<NAME>` (string or array) --- The name of the key to look up.\n    * This can also be an array of keys. If Puppet doesn't find anything for the\n    first key, it will try again with the subsequent ones, only resorting to a\n    default value if none of them succeed.\n2. `<VALUE TYPE>` (data type) --- A\n[data type](https://puppet.com/docs/puppet/latest/lang_data_type.html)\nthat must match the retrieved value; if not, the lookup (and catalog\ncompilation) will fail. Defaults to `Data` (accepts any normal value).\n3. `<MERGE BEHAVIOR>` (string or hash; see **\"Merge Behaviors\"** below) ---\nWhether (and how) to combine multiple values. If present, this overrides any\nmerge behavior specified in the data sources. Defaults to no value; Puppet will\nuse merge behavior from the data sources if present, and will otherwise do a\nfirst-found lookup.\n4. `<DEFAULT VALUE>` (any normal value) --- If present, `lookup` returns this\nwhen it can't find a normal value. Default values are never merged with found\nvalues. Like a normal value, the default must match the value type. Defaults to\nno value; if Puppet can't find a normal value, the lookup (and compilation) will\nfail.\n5. `<OPTIONS HASH>` (hash) --- Alternate way to set the arguments above, plus\nsome less-common extra options. If you pass an options hash, you can't combine\nit with any regular arguments (except `<NAME>`). An options hash can have the\nfollowing keys:\n    * `'name'` --- Same as `<NAME>` (argument 1). You can pass this as an\n    argument or in the hash, but not both.\n    * `'value_type'` --- Same as `<VALUE TYPE>` (argument 2).\n    * `'merge'` --- Same as `<MERGE BEHAVIOR>` (argument 3).\n    * `'default_value'` --- Same as `<DEFAULT VALUE>` (argument 4).\n    * `'default_values_hash'` (hash) --- A hash of lookup keys and default\n    values. If Puppet can't find a normal value, it will check this hash for the\n    requested key before giving up. You can combine this with `default_value` or\n    a lambda, which will be used if the key isn't present in this hash. Defaults\n    to an empty hash.\n    * `'override'` (hash) --- A hash of lookup keys and override values. Puppet\n    will check for the requested key in the overrides hash _first;_ if found, it\n    returns that value as the _final_ value, ignoring merge behavior. Defaults\n    to an empty hash.\n\nFinally, `lookup` can take a lambda, which must accept a single parameter.\nThis is yet another way to set a default value for the lookup; if no results are\nfound, Puppet will pass the requested key to the lambda and use its result as\nthe default value.\n\n#### Merge Behaviors\n\nPuppet lookup uses a hierarchy of data sources, and a given key might have\nvalues in multiple sources. By default, Puppet returns the first value it finds,\nbut it can also continue searching and merge all the values together.\n\n> **Note:** Data sources can use the special `lookup_options` metadata key to\nrequest a specific merge behavior for a key. The `lookup` function will use that\nrequested behavior unless you explicitly specify one.\n\nThe valid merge behaviors are:\n\n* `'first'` --- Returns the first value found, with no merging. Puppet lookup's\ndefault behavior.\n* `'unique'` (called \"array merge\" in classic Hiera) --- Combines any number of\narrays and scalar values to return a merged, flattened array with all duplicate\nvalues removed. The lookup will fail if any hash values are found.\n* `'hash'` --- Combines the keys and values of any number of hashes to return a\nmerged hash. If the same key exists in multiple source hashes, Puppet will use\nthe value from the highest-priority data source; it won't recursively merge the\nvalues.\n* `'deep'` --- Combines the keys and values of any number of hashes to return a\nmerged hash. If the same key exists in multiple source hashes, Puppet will\nrecursively merge hash or array values (with duplicate values removed from\narrays). For conflicting scalar values, the highest-priority value will win.\n* `{'strategy' => 'first'}`, `{'strategy' => 'unique'}`,\nor `{'strategy' => 'hash'}` --- Same as the string versions of these merge behaviors.\n* `{'strategy' => 'deep', <DEEP OPTION> => <VALUE>, ...}` --- Same as `'deep'`,\nbut can adjust the merge with additional options. The available options are:\n    * `'knockout_prefix'` (string or undef) --- A string prefix to indicate a\n    value should be _removed_ from the final result. If a value is exactly equal\n    to the prefix, it will knockout the entire element. Defaults to `undef`, which\n    disables this feature.\n    * `'sort_merged_arrays'` (boolean) --- Whether to sort all arrays that are\n    merged together. Defaults to `false`.\n    * `'merge_hash_arrays'` (boolean) --- Whether to merge hashes within arrays.\n    Defaults to `false`.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"\nlookup('ntp::service_name')",
            "name"=>"Look up a key and return the first value found"
          },
          {
            "tag_name"=>"example",
            "text"=>"\nlookup('classes', Array[String], 'unique').include",
            "name"=>"Do a unique merge lookup of class names, then add all of those classes to the catalog (like `hiera_include`)"
          },
          {
            "tag_name"=>"example",
            "text"=>"\nlookup( { 'name'  => 'users',\n          'merge' => {\n            'strategy'        => 'deep',\n            'knockout_prefix' => '--',\n          },\n})",
            "name"=>"Do a deep hash merge lookup of user data, but let higher priority sources remove values by prefixing them with `--`"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"lookup(NameType $name, Optional[ValueType] $value_type, Optional[MergeType] $merge)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "NameType"
                  ],
                  "name"=>"name"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[ValueType]"
                  ],
                  "name"=>"value_type"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[MergeType]"
                  ],
                  "name"=>"merge"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"lookup"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"lookup(NameType $name, Optional[ValueType] $value_type, Optional[MergeType] $merge, DefaultValueType $default_value)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "NameType"
                  ],
                  "name"=>"name"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[ValueType]"
                  ],
                  "name"=>"value_type"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[MergeType]"
                  ],
                  "name"=>"merge"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "DefaultValueType"
                  ],
                  "name"=>"default_value"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"lookup"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"lookup(NameType $name, Optional[ValueType] $value_type, Optional[MergeType] $merge, BlockType &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "NameType"
                  ],
                  "name"=>"name"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[ValueType]"
                  ],
                  "name"=>"value_type"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[MergeType]"
                  ],
                  "name"=>"merge"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "BlockType"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"lookup"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"lookup(OptionsWithName $options_hash, Optional[BlockType] &$block)",
            "docstring"=>{
              "text"=>"Lookup without name. Name then becomes a required entry in the options hash",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "OptionsWithName"
                  ],
                  "name"=>"options_hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[BlockType]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"lookup"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"lookup(Variant[String,Array[String]] $name, OptionsWithoutName $options_hash, Optional[BlockType] &$block)",
            "docstring"=>{
              "text"=>"Lookup using name and options hash.",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Variant[String,Array[String]]"
                  ],
                  "name"=>"name"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "OptionsWithoutName"
                  ],
                  "name"=>"options_hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[BlockType]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"lookup"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:lookup, Puppet::Functions::InternalFunction) do\n\n  local_types do\n    type 'NameType         = Variant[String, Array[String]]'\n    type 'ValueType        = Type'\n    type 'DefaultValueType = Any'\n    type 'MergeType        = Variant[String[1], Hash[String, Scalar]]'\n    type 'BlockType        = Callable[NameType]'\n    type \"OptionsWithName  = Struct[{\\\n      name                => NameType,\\\n      value_type          => Optional[ValueType],\\\n      default_value       => Optional[DefaultValueType],\\\n      override            => Optional[Hash[String,Any]],\\\n      default_values_hash => Optional[Hash[String,Any]],\\\n      merge               => Optional[MergeType]\\\n    }]\"\n    type \"OptionsWithoutName = Struct[{\\\n      value_type          => Optional[ValueType],\\\n      default_value       => Optional[DefaultValueType],\\\n      override            => Optional[Hash[String,Any]],\\\n      default_values_hash => Optional[Hash[String,Any]],\\\n      merge               => Optional[MergeType]\\\n    }]\"\n\n  end\n\n  dispatch :lookup_1 do\n    scope_param\n    param           'NameType',       :name\n    optional_param  'ValueType',      :value_type\n    optional_param  'MergeType',      :merge\n  end\n\n  dispatch :lookup_2 do\n    scope_param\n    param 'NameType',                 :name\n    param 'Optional[ValueType]',      :value_type\n    param 'Optional[MergeType]',      :merge\n    param 'DefaultValueType',         :default_value\n  end\n\n  dispatch :lookup_3 do\n    scope_param\n    param                'NameType',   :name\n    optional_param       'ValueType',  :value_type\n    optional_param       'MergeType',  :merge\n    required_block_param 'BlockType',  :block\n  end\n\n  # Lookup without name. Name then becomes a required entry in the options hash\n  dispatch :lookup_4 do\n    scope_param\n    param                'OptionsWithName', :options_hash\n    optional_block_param 'BlockType',       :block\n  end\n\n  # Lookup using name and options hash.\n  dispatch :lookup_5 do\n    scope_param\n    param                'Variant[String,Array[String]]', :name\n    param                'OptionsWithoutName',            :options_hash\n    optional_block_param 'BlockType',                     :block\n  end\n\n  def lookup_1(scope, name, value_type=nil, merge=nil)\n    do_lookup(scope, name, value_type, nil, false, {}, {}, merge)\n  end\n\n  def lookup_2(scope, name, value_type, merge, default_value)\n    do_lookup(scope, name, value_type, default_value, true, {}, {}, merge)\n  end\n\n  def lookup_3(scope, name, value_type=nil, merge=nil, &block)\n    do_lookup(scope, name, value_type, nil, false, {}, {}, merge, &block)\n  end\n\n  def lookup_4(scope, options_hash, &block)\n    do_lookup(scope, options_hash['name'], *hash_args(options_hash), &block)\n  end\n\n  def lookup_5(scope, name, options_hash, &block)\n    do_lookup(scope, name, *hash_args(options_hash), &block)\n  end\n\n  def do_lookup(scope, name, value_type, default_value, has_default, override, default_values_hash, merge, &block)\n    Puppet::Pops::Lookup.lookup(name, value_type, default_value, has_default, merge,\n      Puppet::Pops::Lookup::Invocation.new(scope, override, default_values_hash), &block)\n  end\n\n  def hash_args(options_hash)\n    [\n        options_hash['value_type'],\n        options_hash['default_value'],\n        options_hash.include?('default_value'),\n        options_hash['override'] || {},\n        options_hash['default_values_hash'] || {},\n        options_hash['merge']\n    ]\n  end\nend"
    },
    {
      "name"=>"lookup",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/lookup.rb",
      "line"=>2,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"lookup()",
          "docstring"=>{
            "text"=>"Uses the Puppet lookup system to retrieve a value for a given key. By default,\nthis returns the first value found (and fails compilation if no values are\navailable), but you can configure it to merge multiple values into one, fail\ngracefully, and more.\n\nWhen looking up a key, Puppet will search up to three tiers of data, in the\nfollowing order:\n\n1. Hiera.\n2. The current environment's data provider.\n3. The indicated module's data provider, if the key is of the form\n   `<MODULE NAME>::<SOMETHING>`.\n\n#### Arguments\n\nYou must provide the name of a key to look up, and can optionally provide other\narguments. You can combine these arguments in the following ways:\n\n* `lookup( <NAME>, [<VALUE TYPE>], [<MERGE BEHAVIOR>], [<DEFAULT VALUE>] )`\n* `lookup( [<NAME>], <OPTIONS HASH> )`\n* `lookup( as above ) |$key| { # lambda returns a default value }`\n\nArguments in `[square brackets]` are optional.\n\nThe arguments accepted by `lookup` are as follows:\n\n1. `<NAME>` (string or array) --- The name of the key to look up.\n    * This can also be an array of keys. If Puppet doesn't find anything for the\n    first key, it will try again with the subsequent ones, only resorting to a\n    default value if none of them succeed.\n2. `<VALUE TYPE>` (data type) --- A\n[data type](https://puppet.com/docs/puppet/latest/lang_data_type.html)\nthat must match the retrieved value; if not, the lookup (and catalog\ncompilation) will fail. Defaults to `Data` (accepts any normal value).\n3. `<MERGE BEHAVIOR>` (string or hash; see **\"Merge Behaviors\"** below) ---\nWhether (and how) to combine multiple values. If present, this overrides any\nmerge behavior specified in the data sources. Defaults to no value; Puppet will\nuse merge behavior from the data sources if present, and will otherwise do a\nfirst-found lookup.\n4. `<DEFAULT VALUE>` (any normal value) --- If present, `lookup` returns this\nwhen it can't find a normal value. Default values are never merged with found\nvalues. Like a normal value, the default must match the value type. Defaults to\nno value; if Puppet can't find a normal value, the lookup (and compilation) will\nfail.\n5. `<OPTIONS HASH>` (hash) --- Alternate way to set the arguments above, plus\nsome less-common extra options. If you pass an options hash, you can't combine\nit with any regular arguments (except `<NAME>`). An options hash can have the\nfollowing keys:\n    * `'name'` --- Same as `<NAME>` (argument 1). You can pass this as an\n    argument or in the hash, but not both.\n    * `'value_type'` --- Same as `<VALUE TYPE>` (argument 2).\n    * `'merge'` --- Same as `<MERGE BEHAVIOR>` (argument 3).\n    * `'default_value'` --- Same as `<DEFAULT VALUE>` (argument 4).\n    * `'default_values_hash'` (hash) --- A hash of lookup keys and default\n    values. If Puppet can't find a normal value, it will check this hash for the\n    requested key before giving up. You can combine this with `default_value` or\n    a lambda, which will be used if the key isn't present in this hash. Defaults\n    to an empty hash.\n    * `'override'` (hash) --- A hash of lookup keys and override values. Puppet\n    will check for the requested key in the overrides hash _first;_ if found, it\n    returns that value as the _final_ value, ignoring merge behavior. Defaults\n    to an empty hash.\n\nFinally, `lookup` can take a lambda, which must accept a single parameter.\nThis is yet another way to set a default value for the lookup; if no results are\nfound, Puppet will pass the requested key to the lambda and use its result as\nthe default value.\n\n#### Merge Behaviors\n\nPuppet lookup uses a hierarchy of data sources, and a given key might have\nvalues in multiple sources. By default, Puppet returns the first value it finds,\nbut it can also continue searching and merge all the values together.\n\n> **Note:** Data sources can use the special `lookup_options` metadata key to\nrequest a specific merge behavior for a key. The `lookup` function will use that\nrequested behavior unless you explicitly specify one.\n\nThe valid merge behaviors are:\n\n* `'first'` --- Returns the first value found, with no merging. Puppet lookup's\ndefault behavior.\n* `'unique'` (called \"array merge\" in classic Hiera) --- Combines any number of\narrays and scalar values to return a merged, flattened array with all duplicate\nvalues removed. The lookup will fail if any hash values are found.\n* `'hash'` --- Combines the keys and values of any number of hashes to return a\nmerged hash. If the same key exists in multiple source hashes, Puppet will use\nthe value from the highest-priority data source; it won't recursively merge the\nvalues.\n* `'deep'` --- Combines the keys and values of any number of hashes to return a\nmerged hash. If the same key exists in multiple source hashes, Puppet will\nrecursively merge hash or array values (with duplicate values removed from\narrays). For conflicting scalar values, the highest-priority value will win.\n* `{'strategy' => 'first|unique|hash'}` --- Same as the string versions of these\nmerge behaviors.\n* `{'strategy' => 'deep', <DEEP OPTION> => <VALUE>, ...}` --- Same as `'deep'`,\nbut can adjust the merge with additional options. The available options are:\n    * `'knockout_prefix'` (string or undef) --- A string prefix to indicate a\n    value should be _removed_ from the final result. Defaults to `undef`, which\n    disables this feature.\n    * `'sort_merged_arrays'` (boolean) --- Whether to sort all arrays that are\n    merged together. Defaults to `false`.\n    * `'merge_hash_arrays'` (boolean) --- Whether to merge hashes within arrays.\n    Defaults to `false`.\n\n#### Examples\n\nLook up a key and return the first value found:\n\n    lookup('ntp::service_name')\n\nDo a unique merge lookup of class names, then add all of those classes to the\ncatalog (like `hiera_include`):\n\n    lookup('classes', Array[String], 'unique').include\n\nDo a deep hash merge lookup of user data, but let higher priority sources\nremove values by prefixing them with `--`:\n\n    lookup( { 'name'  => 'users',\n              'merge' => {\n                'strategy'        => 'deep',\n                'knockout_prefix' => '--',\n              },\n    })",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Uses the Puppet lookup system to retrieve a value for a given key. By default,\nthis returns the first value found (and fails compilation if no values are\navailable), but you can configure it to merge multiple values into one, fail\ngracefully, and more.\n\nWhen looking up a key, Puppet will search up to three tiers of data, in the\nfollowing order:\n\n1. Hiera.\n2. The current environment's data provider.\n3. The indicated module's data provider, if the key is of the form\n   `<MODULE NAME>::<SOMETHING>`.\n\n#### Arguments\n\nYou must provide the name of a key to look up, and can optionally provide other\narguments. You can combine these arguments in the following ways:\n\n* `lookup( <NAME>, [<VALUE TYPE>], [<MERGE BEHAVIOR>], [<DEFAULT VALUE>] )`\n* `lookup( [<NAME>], <OPTIONS HASH> )`\n* `lookup( as above ) |$key| { # lambda returns a default value }`\n\nArguments in `[square brackets]` are optional.\n\nThe arguments accepted by `lookup` are as follows:\n\n1. `<NAME>` (string or array) --- The name of the key to look up.\n    * This can also be an array of keys. If Puppet doesn't find anything for the\n    first key, it will try again with the subsequent ones, only resorting to a\n    default value if none of them succeed.\n2. `<VALUE TYPE>` (data type) --- A\n[data type](https://puppet.com/docs/puppet/latest/lang_data_type.html)\nthat must match the retrieved value; if not, the lookup (and catalog\ncompilation) will fail. Defaults to `Data` (accepts any normal value).\n3. `<MERGE BEHAVIOR>` (string or hash; see **\"Merge Behaviors\"** below) ---\nWhether (and how) to combine multiple values. If present, this overrides any\nmerge behavior specified in the data sources. Defaults to no value; Puppet will\nuse merge behavior from the data sources if present, and will otherwise do a\nfirst-found lookup.\n4. `<DEFAULT VALUE>` (any normal value) --- If present, `lookup` returns this\nwhen it can't find a normal value. Default values are never merged with found\nvalues. Like a normal value, the default must match the value type. Defaults to\nno value; if Puppet can't find a normal value, the lookup (and compilation) will\nfail.\n5. `<OPTIONS HASH>` (hash) --- Alternate way to set the arguments above, plus\nsome less-common extra options. If you pass an options hash, you can't combine\nit with any regular arguments (except `<NAME>`). An options hash can have the\nfollowing keys:\n    * `'name'` --- Same as `<NAME>` (argument 1). You can pass this as an\n    argument or in the hash, but not both.\n    * `'value_type'` --- Same as `<VALUE TYPE>` (argument 2).\n    * `'merge'` --- Same as `<MERGE BEHAVIOR>` (argument 3).\n    * `'default_value'` --- Same as `<DEFAULT VALUE>` (argument 4).\n    * `'default_values_hash'` (hash) --- A hash of lookup keys and default\n    values. If Puppet can't find a normal value, it will check this hash for the\n    requested key before giving up. You can combine this with `default_value` or\n    a lambda, which will be used if the key isn't present in this hash. Defaults\n    to an empty hash.\n    * `'override'` (hash) --- A hash of lookup keys and override values. Puppet\n    will check for the requested key in the overrides hash _first;_ if found, it\n    returns that value as the _final_ value, ignoring merge behavior. Defaults\n    to an empty hash.\n\nFinally, `lookup` can take a lambda, which must accept a single parameter.\nThis is yet another way to set a default value for the lookup; if no results are\nfound, Puppet will pass the requested key to the lambda and use its result as\nthe default value.\n\n#### Merge Behaviors\n\nPuppet lookup uses a hierarchy of data sources, and a given key might have\nvalues in multiple sources. By default, Puppet returns the first value it finds,\nbut it can also continue searching and merge all the values together.\n\n> **Note:** Data sources can use the special `lookup_options` metadata key to\nrequest a specific merge behavior for a key. The `lookup` function will use that\nrequested behavior unless you explicitly specify one.\n\nThe valid merge behaviors are:\n\n* `'first'` --- Returns the first value found, with no merging. Puppet lookup's\ndefault behavior.\n* `'unique'` (called \"array merge\" in classic Hiera) --- Combines any number of\narrays and scalar values to return a merged, flattened array with all duplicate\nvalues removed. The lookup will fail if any hash values are found.\n* `'hash'` --- Combines the keys and values of any number of hashes to return a\nmerged hash. If the same key exists in multiple source hashes, Puppet will use\nthe value from the highest-priority data source; it won't recursively merge the\nvalues.\n* `'deep'` --- Combines the keys and values of any number of hashes to return a\nmerged hash. If the same key exists in multiple source hashes, Puppet will\nrecursively merge hash or array values (with duplicate values removed from\narrays). For conflicting scalar values, the highest-priority value will win.\n* `{'strategy' => 'first|unique|hash'}` --- Same as the string versions of these\nmerge behaviors.\n* `{'strategy' => 'deep', <DEEP OPTION> => <VALUE>, ...}` --- Same as `'deep'`,\nbut can adjust the merge with additional options. The available options are:\n    * `'knockout_prefix'` (string or undef) --- A string prefix to indicate a\n    value should be _removed_ from the final result. Defaults to `undef`, which\n    disables this feature.\n    * `'sort_merged_arrays'` (boolean) --- Whether to sort all arrays that are\n    merged together. Defaults to `false`.\n    * `'merge_hash_arrays'` (boolean) --- Whether to merge hashes within arrays.\n    Defaults to `false`.\n\n#### Examples\n\nLook up a key and return the first value found:\n\n    lookup('ntp::service_name')\n\nDo a unique merge lookup of class names, then add all of those classes to the\ncatalog (like `hiera_include`):\n\n    lookup('classes', Array[String], 'unique').include\n\nDo a deep hash merge lookup of user data, but let higher priority sources\nremove values by prefixing them with `--`:\n\n    lookup( { 'name'  => 'users',\n              'merge' => {\n                'strategy'        => 'deep',\n                'knockout_prefix' => '--',\n              },\n    })",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"newfunction(:lookup, :type => :rvalue, :arity => -2, :doc => <<-'ENDHEREDOC') do |args|\nUses the Puppet lookup system to retrieve a value for a given key. By default,\nthis returns the first value found (and fails compilation if no values are\navailable), but you can configure it to merge multiple values into one, fail\ngracefully, and more.\n\nWhen looking up a key, Puppet will search up to three tiers of data, in the\nfollowing order:\n\n1. Hiera.\n2. The current environment's data provider.\n3. The indicated module's data provider, if the key is of the form\n   `<MODULE NAME>::<SOMETHING>`.\n\n#### Arguments\n\nYou must provide the name of a key to look up, and can optionally provide other\narguments. You can combine these arguments in the following ways:\n\n* `lookup( <NAME>, [<VALUE TYPE>], [<MERGE BEHAVIOR>], [<DEFAULT VALUE>] )`\n* `lookup( [<NAME>], <OPTIONS HASH> )`\n* `lookup( as above ) |$key| { # lambda returns a default value }`\n\nArguments in `[square brackets]` are optional.\n\nThe arguments accepted by `lookup` are as follows:\n\n1. `<NAME>` (string or array) --- The name of the key to look up.\n    * This can also be an array of keys. If Puppet doesn't find anything for the\n    first key, it will try again with the subsequent ones, only resorting to a\n    default value if none of them succeed.\n2. `<VALUE TYPE>` (data type) --- A\n[data type](https://puppet.com/docs/puppet/latest/lang_data_type.html)\nthat must match the retrieved value; if not, the lookup (and catalog\ncompilation) will fail. Defaults to `Data` (accepts any normal value).\n3. `<MERGE BEHAVIOR>` (string or hash; see **\"Merge Behaviors\"** below) ---\nWhether (and how) to combine multiple values. If present, this overrides any\nmerge behavior specified in the data sources. Defaults to no value; Puppet will\nuse merge behavior from the data sources if present, and will otherwise do a\nfirst-found lookup.\n4. `<DEFAULT VALUE>` (any normal value) --- If present, `lookup` returns this\nwhen it can't find a normal value. Default values are never merged with found\nvalues. Like a normal value, the default must match the value type. Defaults to\nno value; if Puppet can't find a normal value, the lookup (and compilation) will\nfail.\n5. `<OPTIONS HASH>` (hash) --- Alternate way to set the arguments above, plus\nsome less-common extra options. If you pass an options hash, you can't combine\nit with any regular arguments (except `<NAME>`). An options hash can have the\nfollowing keys:\n    * `'name'` --- Same as `<NAME>` (argument 1). You can pass this as an\n    argument or in the hash, but not both.\n    * `'value_type'` --- Same as `<VALUE TYPE>` (argument 2).\n    * `'merge'` --- Same as `<MERGE BEHAVIOR>` (argument 3).\n    * `'default_value'` --- Same as `<DEFAULT VALUE>` (argument 4).\n    * `'default_values_hash'` (hash) --- A hash of lookup keys and default\n    values. If Puppet can't find a normal value, it will check this hash for the\n    requested key before giving up. You can combine this with `default_value` or\n    a lambda, which will be used if the key isn't present in this hash. Defaults\n    to an empty hash.\n    * `'override'` (hash) --- A hash of lookup keys and override values. Puppet\n    will check for the requested key in the overrides hash _first;_ if found, it\n    returns that value as the _final_ value, ignoring merge behavior. Defaults\n    to an empty hash.\n\nFinally, `lookup` can take a lambda, which must accept a single parameter.\nThis is yet another way to set a default value for the lookup; if no results are\nfound, Puppet will pass the requested key to the lambda and use its result as\nthe default value.\n\n#### Merge Behaviors\n\nPuppet lookup uses a hierarchy of data sources, and a given key might have\nvalues in multiple sources. By default, Puppet returns the first value it finds,\nbut it can also continue searching and merge all the values together.\n\n> **Note:** Data sources can use the special `lookup_options` metadata key to\nrequest a specific merge behavior for a key. The `lookup` function will use that\nrequested behavior unless you explicitly specify one.\n\nThe valid merge behaviors are:\n\n* `'first'` --- Returns the first value found, with no merging. Puppet lookup's\ndefault behavior.\n* `'unique'` (called \"array merge\" in classic Hiera) --- Combines any number of\narrays and scalar values to return a merged, flattened array with all duplicate\nvalues removed. The lookup will fail if any hash values are found.\n* `'hash'` --- Combines the keys and values of any number of hashes to return a\nmerged hash. If the same key exists in multiple source hashes, Puppet will use\nthe value from the highest-priority data source; it won't recursively merge the\nvalues.\n* `'deep'` --- Combines the keys and values of any number of hashes to return a\nmerged hash. If the same key exists in multiple source hashes, Puppet will\nrecursively merge hash or array values (with duplicate values removed from\narrays). For conflicting scalar values, the highest-priority value will win.\n* `{'strategy' => 'first|unique|hash'}` --- Same as the string versions of these\nmerge behaviors.\n* `{'strategy' => 'deep', <DEEP OPTION> => <VALUE>, ...}` --- Same as `'deep'`,\nbut can adjust the merge with additional options. The available options are:\n    * `'knockout_prefix'` (string or undef) --- A string prefix to indicate a\n    value should be _removed_ from the final result. Defaults to `undef`, which\n    disables this feature.\n    * `'sort_merged_arrays'` (boolean) --- Whether to sort all arrays that are\n    merged together. Defaults to `false`.\n    * `'merge_hash_arrays'` (boolean) --- Whether to merge hashes within arrays.\n    Defaults to `false`.\n\n#### Examples\n\nLook up a key and return the first value found:\n\n    lookup('ntp::service_name')\n\nDo a unique merge lookup of class names, then add all of those classes to the\ncatalog (like `hiera_include`):\n\n    lookup('classes', Array[String], 'unique').include\n\nDo a deep hash merge lookup of user data, but let higher priority sources\nremove values by prefixing them with `--`:\n\n    lookup( { 'name'  => 'users',\n              'merge' => {\n                'strategy'        => 'deep',\n                'knockout_prefix' => '--',\n              },\n    })\n\nENDHEREDOC\n  Error.is4x('lookup')\nend"
    },
    {
      "name"=>"lstrip",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/lstrip.rb",
      "line"=>27,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"lstrip(Numeric $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"lstrip(String $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"lstrip(Iterable[Variant[String, Numeric]] $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable[Variant[String, Numeric]]"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Strips leading spaces from a String\n\nThis function is compatible with the stdlib function with the same name.\n\nThe function does the following:\n* For a `String` the conversion removes all leading ASCII white space characters such as space, tab, newline, and return.\n  It does not remove other space-like characters like hard space (Unicode U+00A0). (Tip, `/^[[:space:]]/` regular expression\n  matches all space-like characters).\n* For an `Iterable[Variant[String, Numeric]]` (for example an `Array`) each value is processed and the conversion is not recursive.\n* If the value is `Numeric` it is simply returned (this is for backwards compatibility).\n* An error is raised for all other data types.\n\n```puppet\n\"\\n\\thello \".lstrip()\nlstrip(\"\\n\\thello \")\n```\nWould both result in `\"hello\"`\n\n```puppet\n[\"\\n\\thello \", \"\\n\\thi \"].lstrip()\nlstrip([\"\\n\\thello \", \"\\n\\thi \"])\n```\nWould both result in `['hello', 'hi']`",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Removing leading space from a String"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Removing leading space from strings in an Array"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"lstrip(Numeric $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"lstrip"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"lstrip(String $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"lstrip"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"lstrip(Iterable[Variant[String, Numeric]] $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable[Variant[String, Numeric]]"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"lstrip"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:lstrip) do\n\n  dispatch :on_numeric do\n    param 'Numeric', :arg\n  end\n\n  dispatch :on_string do\n    param 'String', :arg\n  end\n\n  dispatch :on_iterable do\n    param 'Iterable[Variant[String, Numeric]]', :arg\n  end\n\n  # unit function - since the old implementation skipped Numeric values\n  def on_numeric(n)\n    n\n  end\n\n  def on_string(s)\n    s.lstrip\n  end\n\n  def on_iterable(a)\n    a.map {|x| do_lstrip(x) }\n  end\n\n  def do_lstrip(x)\n    # x can only be a String or Numeric because type constraints have been automatically applied\n    x.is_a?(String) ? x.lstrip : x\n  end\nend"
    },
    {
      "name"=>"map",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/map.rb",
      "line"=>69,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"map(Hash[Any, Any] $hash, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Any, Any]"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"map(Hash[Any, Any] $hash, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Any, Any]"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"map(Iterable $enumerable, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"map(Iterable $enumerable, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Applies a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nto every value in a data structure and returns an array containing the results.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array, hash, or other iterable object that the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n`$transformed_data = $data.map |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`$transformed_data = map($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nvalue in turn to the lambda.\n\n```puppet\n# For the array $data, return an array containing each value multiplied by 10\n$data = [1,2,3]\n$transformed_data = $data.map |$items| { $items * 10 }\n# $transformed_data contains [10,20,30]\n```\n\nWhen the first argument is a hash, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]`.\n\n```puppet\n# For the hash $data, return an array containing the keys\n$data = {'a'=>1,'b'=>2,'c'=>3}\n$transformed_data = $data.map |$items| { $items[0] }\n# $transformed_data contains ['a','b','c']\n```\n\nWhen the first argument is an array and the lambda has two parameters, Puppet passes the\narray's indexes (enumerated from 0) in the first parameter and its values in the second\nparameter.\n\n```puppet\n# For the array $data, return an array containing the indexes\n$data = [1,2,3]\n$transformed_data = $data.map |$index,$value| { $index }\n# $transformed_data contains [0,1,2]\n```\n\nWhen the first argument is a hash, Puppet passes its keys to the first parameter and its\nvalues to the second parameter.\n\n```puppet\n# For the hash $data, return an array containing each value\n$data = {'a'=>1,'b'=>2,'c'=>3}\n$transformed_data = $data.map |$key,$value| { $value }\n# $transformed_data contains [1,2,3]\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `map` function"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `map` function with an array and a one-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `map` function with a hash and a one-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `map` function with an array and a two-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `map` function with a hash and a two-parameter lambda"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"map(Hash[Any, Any] $hash, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Any, Any]"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"map"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"map(Hash[Any, Any] $hash, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Any, Any]"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"map"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"map(Iterable $enumerable, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"map"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"map(Iterable $enumerable, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"map"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:map) do\n  dispatch :map_Hash_2 do\n    param 'Hash[Any, Any]', :hash\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :map_Hash_1 do\n    param 'Hash[Any, Any]', :hash\n    block_param 'Callable[1,1]', :block\n  end\n\n  dispatch :map_Enumerable_2 do\n    param 'Iterable', :enumerable\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :map_Enumerable_1 do\n    param 'Iterable', :enumerable\n    block_param 'Callable[1,1]', :block\n  end\n\n  def map_Hash_1(hash)\n    result = []\n    begin\n      hash.map {|x, y| result << yield([x, y]) }\n    rescue StopIteration\n    end\n    result\n  end\n\n  def map_Hash_2(hash)\n    result = []\n    begin\n      hash.map {|x, y| result << yield(x, y) }\n    rescue StopIteration\n    end\n    result\n  end\n\n  def map_Enumerable_1(enumerable)\n    result = []\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n    begin\n      loop { result << yield(enum.next) }\n    rescue StopIteration\n    end\n    result\n  end\n\n  def map_Enumerable_2(enumerable)\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n    if enum.hash_style?\n      enum.map { |entry| yield(*entry) }\n    else\n      result = []\n      begin\n        index = 0\n        loop do\n          result << yield(index, enum.next)\n          index = index + 1\n        end\n      rescue StopIteration\n      end\n\n      result\n    end\n  end\nend"
    },
    {
      "name"=>"map",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/map.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"map()",
          "docstring"=>{
            "text"=>"Applies a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nto every value in a data structure and returns an array containing the results.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array or hash the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n**Example**: Using the `map` function\n\n`$transformed_data = $data.map |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`$transformed_data = map($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nvalue in turn to the lambda.\n\n**Example**: Using the `map` function with an array and a one-parameter lambda\n\n~~~ puppet\n# For the array $data, return an array containing each value multiplied by 10\n$data = [1,2,3]\n$transformed_data = $data.map |$items| { $items * 10 }\n# $transformed_data contains [10,20,30]\n~~~\n\nWhen the first argument is a hash, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]`.\n\n**Example**: Using the `map` function with a hash and a one-parameter lambda\n\n~~~ puppet\n# For the hash $data, return an array containing the keys\n$data = {'a'=>1,'b'=>2,'c'=>3}\n$transformed_data = $data.map |$items| { $items[0] }\n# $transformed_data contains ['a','b','c']\n~~~\n\nWhen the first argument is an array and the lambda has two parameters, Puppet passes the\narray's indexes (enumerated from 0) in the first parameter and its values in the second\nparameter.\n\n**Example**: Using the `map` function with an array and a two-parameter lambda\n\n~~~ puppet\n# For the array $data, return an array containing the indexes\n$data = [1,2,3]\n$transformed_data = $data.map |$index,$value| { $index }\n# $transformed_data contains [0,1,2]\n~~~\n\nWhen the first argument is a hash, Puppet passes its keys to the first parameter and its\nvalues to the second parameter.\n\n**Example**: Using the `map` function with a hash and a two-parameter lambda\n\n~~~ puppet\n# For the hash $data, return an array containing each value\n$data = {'a'=>1,'b'=>2,'c'=>3}\n$transformed_data = $data.map |$key,$value| { $value }\n# $transformed_data contains [1,2,3]\n~~~\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Applies a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nto every value in a data structure and returns an array containing the results.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array or hash the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n**Example**: Using the `map` function\n\n`$transformed_data = $data.map |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`$transformed_data = map($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nvalue in turn to the lambda.\n\n**Example**: Using the `map` function with an array and a one-parameter lambda\n\n~~~ puppet\n# For the array $data, return an array containing each value multiplied by 10\n$data = [1,2,3]\n$transformed_data = $data.map |$items| { $items * 10 }\n# $transformed_data contains [10,20,30]\n~~~\n\nWhen the first argument is a hash, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]`.\n\n**Example**: Using the `map` function with a hash and a one-parameter lambda\n\n~~~ puppet\n# For the hash $data, return an array containing the keys\n$data = {'a'=>1,'b'=>2,'c'=>3}\n$transformed_data = $data.map |$items| { $items[0] }\n# $transformed_data contains ['a','b','c']\n~~~\n\nWhen the first argument is an array and the lambda has two parameters, Puppet passes the\narray's indexes (enumerated from 0) in the first parameter and its values in the second\nparameter.\n\n**Example**: Using the `map` function with an array and a two-parameter lambda\n\n~~~ puppet\n# For the array $data, return an array containing the indexes\n$data = [1,2,3]\n$transformed_data = $data.map |$index,$value| { $index }\n# $transformed_data contains [0,1,2]\n~~~\n\nWhen the first argument is a hash, Puppet passes its keys to the first parameter and its\nvalues to the second parameter.\n\n**Example**: Using the `map` function with a hash and a two-parameter lambda\n\n~~~ puppet\n# For the hash $data, return an array containing each value\n$data = {'a'=>1,'b'=>2,'c'=>3}\n$transformed_data = $data.map |$key,$value| { $value }\n# $transformed_data contains [1,2,3]\n~~~\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :map,\n  :type => :rvalue,\n  :arity => -3,\n  :doc => <<-DOC\nApplies a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nto every value in a data structure and returns an array containing the results.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array or hash the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It can\nrequest one or two parameters.\n\n**Example**: Using the `map` function\n\n`$transformed_data = $data.map |$parameter| { <PUPPET CODE BLOCK> }`\n\nor\n\n`$transformed_data = map($data) |$parameter| { <PUPPET CODE BLOCK> }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nvalue in turn to the lambda.\n\n**Example**: Using the `map` function with an array and a one-parameter lambda\n\n~~~ puppet\n# For the array $data, return an array containing each value multiplied by 10\n$data = [1,2,3]\n$transformed_data = $data.map |$items| { $items * 10 }\n# $transformed_data contains [10,20,30]\n~~~\n\nWhen the first argument is a hash, Puppet passes each key and value pair to the lambda\nas an array in the form `[key, value]`.\n\n**Example**: Using the `map` function with a hash and a one-parameter lambda\n\n~~~ puppet\n# For the hash $data, return an array containing the keys\n$data = {'a'=>1,'b'=>2,'c'=>3}\n$transformed_data = $data.map |$items| { $items[0] }\n# $transformed_data contains ['a','b','c']\n~~~\n\nWhen the first argument is an array and the lambda has two parameters, Puppet passes the\narray's indexes (enumerated from 0) in the first parameter and its values in the second\nparameter.\n\n**Example**: Using the `map` function with an array and a two-parameter lambda\n\n~~~ puppet\n# For the array $data, return an array containing the indexes\n$data = [1,2,3]\n$transformed_data = $data.map |$index,$value| { $index }\n# $transformed_data contains [0,1,2]\n~~~\n\nWhen the first argument is a hash, Puppet passes its keys to the first parameter and its\nvalues to the second parameter.\n\n**Example**: Using the `map` function with a hash and a two-parameter lambda\n\n~~~ puppet\n# For the hash $data, return an array containing each value\n$data = {'a'=>1,'b'=>2,'c'=>3}\n$transformed_data = $data.map |$key,$value| { $value }\n# $transformed_data contains [1,2,3]\n~~~\n\n- Since 4.0.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('map')\nend"
    },
    {
      "name"=>"match",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/match.rb",
      "line"=>37,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"match(String $string, Variant[Any, Type] $pattern)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"string"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Variant[Any, Type]"
                ],
                "name"=>"pattern"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"match(Array[String] $string, Variant[Any, Type] $pattern)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array[String]"
                ],
                "name"=>"string"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Variant[Any, Type]"
                ],
                "name"=>"pattern"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Matches a regular expression against a string and returns an array containing the match\nand any matched capturing groups.\n\nThe first argument is a string or array of strings. The second argument is either a\nregular expression, regular expression represented as a string, or Regex or Pattern\ndata type that the function matches against the first argument.\n\nThe returned array contains the entire match at index 0, and each captured group at\nsubsequent index values. If the value or expression being matched is an array, the\nfunction returns an array with mapped match results.\n\nIf the function doesn't find a match, it returns 'undef'.\n\n```puppet\n$matches = \"abc123\".match(/[a-z]+[1-9]+/)\n# $matches contains [abc123]\n```\n\n```puppet\n$matches = \"abc123\".match(/([a-z]+)([1-9]+)/)\n# $matches contains [abc123, abc, 123]\n```\n\n```puppet\n$matches = [\"abc123\",\"def456\"].match(/([a-z]+)([1-9]+)/)\n# $matches contains [[abc123, abc, 123], [def456, def, 456]]\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Matching a regular expression in a string"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Matching a regular expressions with grouping captures in a string"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Matching a regular expression with grouping captures in an array of strings"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"match(String $string, Variant[Any, Type] $pattern)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"string"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Variant[Any, Type]"
                  ],
                  "name"=>"pattern"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"match"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"match(Array[String] $string, Variant[Any, Type] $pattern)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array[String]"
                  ],
                  "name"=>"string"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Variant[Any, Type]"
                  ],
                  "name"=>"pattern"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"match"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:match) do\n  dispatch :match do\n    param 'String', :string\n    param 'Variant[Any, Type]', :pattern\n  end\n\n  dispatch :enumerable_match do\n    param 'Array[String]', :string\n    param 'Variant[Any, Type]', :pattern\n  end\n\n  def initialize(closure_scope, loader)\n    super\n\n    # Make this visitor shared among all instantiations of this function since it is faster.\n    # This can be used because it is not possible to replace\n    # a puppet runtime (where this function is) without a reboot. If you model a function in a module after\n    # this class, use a regular instance variable instead to enable reloading of the module without reboot\n    #\n    @@match_visitor   ||= Puppet::Pops::Visitor.new(self, \"match\", 1, 1)\n  end\n\n  # Matches given string against given pattern and returns an Array with matches.\n  # @param string [String] the string to match\n  # @param pattern [String, Regexp, Puppet::Pops::Types::PPatternType, Puppet::Pops::PRegexpType, Array] the pattern\n  # @return [Array<String>] matches where first match is the entire match, and index 1-n are captures from left to right\n  #\n  def match(string, pattern)\n    @@match_visitor.visit_this_1(self, pattern, string)\n  end\n\n  # Matches given Array[String] against given pattern and returns an Array with mapped match results.\n  #\n  # @param array [Array<String>] the array of strings to match\n  # @param pattern [String, Regexp, Puppet::Pops::Types::PPatternType, Puppet::Pops::PRegexpType, Array] the pattern\n  # @return [Array<Array<String, nil>>] Array with matches (see {#match}), non matching entries produce a nil entry\n  #\n  def enumerable_match(array, pattern)\n    array.map {|s| match(s, pattern) }\n  end\n\n  protected\n\n  def match_Object(obj, s)\n    msg = _(\"match() expects pattern of T, where T is String, Regexp, Regexp[r], Pattern[p], or Array[T]. Got %{klass}\") % { klass: obj.class }\n    raise ArgumentError, msg\n  end\n\n  def match_String(pattern_string, s)\n    do_match(s, Regexp.new(pattern_string))\n  end\n\n  def match_Regexp(regexp, s)\n    do_match(s, regexp)\n  end\n\n  def match_PTypeAliasType(alias_t, s)\n    match(s, alias_t.resolved_type)\n  end\n\n  def match_PVariantType(var_t, s)\n    # Find first matching type (or error out if one of the variants is not acceptable)\n    result = nil\n    var_t.types.find {|t| result = match(s, t) }\n    result\n  end\n\n  def match_PRegexpType(regexp_t, s)\n    raise ArgumentError, _(\"Given Regexp Type has no regular expression\") unless regexp_t.pattern\n    do_match(s, regexp_t.regexp)\n  end\n\n  def match_PPatternType(pattern_t, s)\n    # Since we want the actual match result (not just a boolean), an iteration over\n    # Pattern's regular expressions is needed. (They are of PRegexpType)\n    result = nil\n    pattern_t.patterns.find {|pattern| result = match(s, pattern) }\n    result\n  end\n\n  # Returns the first matching entry\n  def match_Array(array, s)\n    result = nil\n    array.flatten.find {|entry| result = match(s, entry) }\n    result\n  end\n\n  private\n\n  def do_match(s, regexp)\n    result = regexp.match(s)\n    result.to_a if result\n  end\nend"
    },
    {
      "name"=>"match",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/match.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"match()",
          "docstring"=>{
            "text"=>"Matches a regular expression against a string and returns an array containing the match\nand any matched capturing groups.\n\nThe first argument is a string or array of strings. The second argument is either a\nregular expression, regular expression represented as a string, or Regex or Pattern\ndata type that the function matches against the first argument.\n\nThe returned array contains the entire match at index 0, and each captured group at\nsubsequent index values. If the value or expression being matched is an array, the\nfunction returns an array with mapped match results.\n\nIf the function doesn't find a match, it returns 'undef'.\n\n**Example**: Matching a regular expression in a string\n\n~~~ ruby\n$matches = \"abc123\".match(/[a-z]+[1-9]+/)\n# $matches contains [abc123]\n~~~\n\n**Example**: Matching a regular expressions with grouping captures in a string\n\n~~~ ruby\n$matches = \"abc123\".match(/([a-z]+)([1-9]+)/)\n# $matches contains [abc123, abc, 123]\n~~~\n\n**Example**: Matching a regular expression with grouping captures in an array of strings\n\n~~~ ruby\n$matches = [\"abc123\",\"def456\"].match(/([a-z]+)([1-9]+)/)\n# $matches contains [[abc123, abc, 123], [def456, def, 456]]\n~~~\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Matches a regular expression against a string and returns an array containing the match\nand any matched capturing groups.\n\nThe first argument is a string or array of strings. The second argument is either a\nregular expression, regular expression represented as a string, or Regex or Pattern\ndata type that the function matches against the first argument.\n\nThe returned array contains the entire match at index 0, and each captured group at\nsubsequent index values. If the value or expression being matched is an array, the\nfunction returns an array with mapped match results.\n\nIf the function doesn't find a match, it returns 'undef'.\n\n**Example**: Matching a regular expression in a string\n\n~~~ ruby\n$matches = \"abc123\".match(/[a-z]+[1-9]+/)\n# $matches contains [abc123]\n~~~\n\n**Example**: Matching a regular expressions with grouping captures in a string\n\n~~~ ruby\n$matches = \"abc123\".match(/([a-z]+)([1-9]+)/)\n# $matches contains [abc123, abc, 123]\n~~~\n\n**Example**: Matching a regular expression with grouping captures in an array of strings\n\n~~~ ruby\n$matches = [\"abc123\",\"def456\"].match(/([a-z]+)([1-9]+)/)\n# $matches contains [[abc123, abc, 123], [def456, def, 456]]\n~~~\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :match,\n  :arity => 2,\n  :doc => <<-DOC\nMatches a regular expression against a string and returns an array containing the match\nand any matched capturing groups.\n\nThe first argument is a string or array of strings. The second argument is either a\nregular expression, regular expression represented as a string, or Regex or Pattern\ndata type that the function matches against the first argument.\n\nThe returned array contains the entire match at index 0, and each captured group at\nsubsequent index values. If the value or expression being matched is an array, the\nfunction returns an array with mapped match results.\n\nIf the function doesn't find a match, it returns 'undef'.\n\n**Example**: Matching a regular expression in a string\n\n~~~ ruby\n$matches = \"abc123\".match(/[a-z]+[1-9]+/)\n# $matches contains [abc123]\n~~~\n\n**Example**: Matching a regular expressions with grouping captures in a string\n\n~~~ ruby\n$matches = \"abc123\".match(/([a-z]+)([1-9]+)/)\n# $matches contains [abc123, abc, 123]\n~~~\n\n**Example**: Matching a regular expression with grouping captures in an array of strings\n\n~~~ ruby\n$matches = [\"abc123\",\"def456\"].match(/([a-z]+)([1-9]+)/)\n# $matches contains [[abc123, abc, 123], [def456, def, 456]]\n~~~\n\n- Since 4.0.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('match')\nend"
    },
    {
      "name"=>"max",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/max.rb",
      "line"=>76,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"max(Numeric *$values)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"max(String *$values)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"max(Array[Numeric] $values, Optional[Callable[2,2]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array[Numeric]"
                ],
                "name"=>"values"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[2,2]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"max(Array[String] $values, Optional[Callable[2,2]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array[String]"
                ],
                "name"=>"values"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[2,2]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"max(Array $values, Optional[Callable[2,2]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array"
                ],
                "name"=>"values"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[2,2]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"max(Any *$values, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"max(Any *$values)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns the highest value among a variable number of arguments.\nTakes at least one argument.\n\nThis function is (with one exception) compatible with the stdlib function\nwith the same name and performs deprecated type conversion before\ncomparison as follows:\n\n* If a value converted to String is an optionally '-' prefixed,\n  string of digits, one optional decimal point, followed by optional\n  decimal digits - then the comparison is performed on the values\n  converted to floating point.\n* If a value is not considered convertible to float, it is converted\n  to a `String` and the comparison is a lexical compare where min is\n  the lexicographical later value.\n* A lexicographical compare is performed in a system locale - international\n  characters may therefore not appear in what a user thinks is the correct order.\n* The conversion rules apply to values in pairs - the rule must hold for both\n  values - a value may therefore be compared using different rules depending\n  on the \"other value\".\n* The returned result found to be the \"highest\" is the original unconverted value.\n\nThe above rules have been deprecated in Puppet 6.0.0 as they produce strange results when\ngiven values of mixed data types. In general, either convert values to be\nall `String` or all `Numeric` values before calling the function, or call the\nfunction with a lambda that performs type conversion and comparison. This because one\nsimply cannot compare `Boolean` with `Regexp` and with any arbitrary `Array`, `Hash` or\n`Object` and getting a meaningful result.\n\nThe one change in the function's behavior is when the function is given a single\narray argument. The stdlib implementation would return that array as the result where\nit now instead returns the max value from that array.\n\n```puppet\nnotice(max(1)) # would notice 1\nnotice(max(1,2)) # would notice 2\nnotice(max(\"1\", 2)) # would notice 2\nnotice(max(\"0777\", 512)) # would notice \"0777\", since \"0777\" is not converted from octal form\nnotice(max(0777, 512)) # would notice 512, since 0777 is decimal 511\nnotice(max('aa', 'ab')) # would notice 'ab'\nnotice(max(['a'], ['b'])) # would notice ['b'], since \"['b']\" is after \"['a']\"\n```\n\n```puppet\n$x = [1,2,3,4]\nnotice(max(*$x)) # would notice 4\n```\n\n```puppet\n$x = [1,2,3,4]\nnotice(max($x)) # would notice 4\nnotice($x.max) # would notice 4\n```\nThis example shows that a single array argument is used as the set of values\nas opposed to being a single returned value.\n\nWhen calling with a lambda, it must accept two variables and it must return\none of -1, 0, or 1 depending on if first argument is before/lower than, equal to,\nor higher/after the second argument.\n\n```puppet\nnotice(max(\"2\", \"10\", \"100\") |$a, $b| { compare($a, $b) })\n```\n\nWould notice \"2\" as higher since it is lexicographically higher/after the other values. Without the\nlambda the stdlib compatible (deprecated) behavior would have been to return \"100\" since number conversion\nkicks in.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"'max of values - stdlib compatible'"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"find 'max' value in an array - stdlib compatible"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"find 'max' value in an array directly - since Puppet 6.0.0"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"'max of values using a lambda - since Puppet 6.0.0'"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"max(Numeric *$values)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"*values"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"max"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"max(String *$values)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"*values"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"max"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"max(Array[Numeric] $values, Optional[Callable[2,2]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array[Numeric]"
                  ],
                  "name"=>"values"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[2,2]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"max"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"max(Array[String] $values, Optional[Callable[2,2]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array[String]"
                  ],
                  "name"=>"values"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[2,2]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"max"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"max(Array $values, Optional[Callable[2,2]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array"
                  ],
                  "name"=>"values"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[2,2]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"max"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"max(Any *$values, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"*values"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"max"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"max(Any *$values)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"*values"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"max"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:max) do\n  dispatch :on_numeric do\n    repeated_param 'Numeric', :values\n  end\n\n  dispatch :on_string do\n    repeated_param 'String', :values\n  end\n\n  dispatch :on_single_numeric_array do\n    param 'Array[Numeric]', :values\n    optional_block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :on_single_string_array do\n    param 'Array[String]', :values\n    optional_block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :on_single_any_array do\n    param 'Array', :values\n    optional_block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :on_any_with_block do\n    repeated_param 'Any', :values\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :on_any do\n    repeated_param 'Any', :values\n  end\n\n\n  # All are Numeric - ok now, will be ok later\n  def on_numeric(*args)\n    assert_arg_count(args)\n    args.max\n  end\n\n  # All are String, may convert to numeric (which is deprecated)\n  def on_string(*args)\n    assert_arg_count(args)\n\n    args.max do|a,b|\n      if a.to_s =~ %r{\\A^-?\\d+([._eE]\\d+)?\\z} && b.to_s =~ %r{\\A-?\\d+([._eE]\\d+)?\\z}\n        Puppet.warn_once('deprecations', 'max_function_numeric_coerce_string',\n          _(\"The max() function's auto conversion of String to Numeric is deprecated - change to convert input before calling, or use lambda\"))\n        a.to_f <=> b.to_f\n      else\n        # case sensitive as in the stdlib function\n        a <=> b\n      end\n    end\n  end\n\n  def on_any_with_block(*args, &block)\n    args.max {|x,y| block.call(x,y) }\n  end\n\n  def on_single_numeric_array(array, &block)\n    if block_given?\n      on_any_with_block(*array, &block)\n    else\n      on_numeric(*array)\n    end\n  end\n\n  def on_single_string_array(array, &block)\n    if block_given?\n      on_any_with_block(*array, &block)\n    else\n      on_string(*array)\n    end\n  end\n\n  def on_single_any_array(array, &block)\n    if block_given?\n      on_any_with_block(*array, &block)\n    else\n      on_any(*array)\n    end\n  end\n\n  # Mix of data types - while only some compares are actually bad it will deprecate\n  # the entire call\n  #\n  def on_any(*args)\n    assert_arg_count(args)\n    args.max do |a, b|\n      as = a.to_s\n      bs = b.to_s\n      if as =~ %r{\\A^-?\\d+([._eE]\\d+)?\\z} && bs =~ %r{\\A-?\\d+([._eE]\\d+)?\\z}\n        Puppet.warn_once('deprecations', 'max_function_numeric_coerce_string',\n          _(\"The max() function's auto conversion of String to Numeric is deprecated - change to convert input before calling, or use lambda\"))\n        a.to_f <=> b.to_f\n      else\n        Puppet.warn_once('deprecations', 'max_function_string_coerce_any',\n          _(\"The max() function's auto conversion of Any to String is deprecated - change to convert input before calling, or use lambda\"))\n        as <=> bs\n      end\n    end\n  end\n\n  def assert_arg_count(args)\n    raise(ArgumentError, 'max(): Wrong number of arguments need at least one') if args.empty?\n  end\nend"
    },
    {
      "name"=>"md5",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/md5.rb",
      "line"=>3,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"md5()",
          "docstring"=>{
            "text"=>"Returns a MD5 hash value from a provided string.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns a MD5 hash value from a provided string.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:md5, :type => :rvalue, :arity => 1, :doc => \"Returns a MD5 hash value from a provided string.\") do |args|\n      Digest::MD5.hexdigest(args[0])\nend"
    },
    {
      "name"=>"min",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/min.rb",
      "line"=>75,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"min(Numeric *$values)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"min(String *$values)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"min(Array[Numeric] $values, Optional[Callable[2,2]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array[Numeric]"
                ],
                "name"=>"values"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[2,2]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"min(Array[String] $values, Optional[Callable[2,2]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array[String]"
                ],
                "name"=>"values"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[2,2]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"min(Array $values, Optional[Callable[2,2]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array"
                ],
                "name"=>"values"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[2,2]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"min(Any *$values, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"min(Any *$values)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns the lowest value among a variable number of arguments.\nTakes at least one argument.\n\nThis function is (with one exception) compatible with the stdlib function\nwith the same name and performs deprecated type conversion before\ncomparison as follows:\n\n* If a value converted to String is an optionally '-' prefixed,\n  string of digits, one optional decimal point, followed by optional\n  decimal digits - then the comparison is performed on the values\n  converted to floating point.\n* If a value is not considered convertible to float, it is converted\n  to a `String` and the comparison is a lexical compare where min is\n  the lexicographical earlier value.\n* A lexicographical compare is performed in a system locale - international\n  characters may therefore not appear in what a user thinks is the correct order.\n* The conversion rules apply to values in pairs - the rule must hold for both\n  values - a value may therefore be compared using different rules depending\n  on the \"other value\".\n* The returned result found to be the \"lowest\" is the original unconverted value.\n\nThe above rules have been deprecated in Puppet 6.0.0 as they produce strange results when\ngiven values of mixed data types. In general, either convert values to be\nall `String` or all `Numeric` values before calling the function, or call the\nfunction with a lambda that performs type conversion and comparison. This because one\nsimply cannot compare `Boolean` with `Regexp` and with any arbitrary `Array`, `Hash` or\n`Object` and getting a meaningful result.\n\nThe one change in the function's behavior is when the function is given a single\narray argument. The stdlib implementation would return that array as the result where\nit now instead returns the max value from that array.\n\n```puppet\nnotice(min(1)) # would notice 1\nnotice(min(1,2)) # would notice 1\nnotice(min(\"1\", 2)) # would notice 1\nnotice(min(\"0777\", 512)) # would notice 512, since \"0777\" is not converted from octal form\nnotice(min(0777, 512)) # would notice 511, since 0777 is decimal 511\nnotice(min('aa', 'ab')) # would notice 'aa'\nnotice(min(['a'], ['b'])) # would notice ['a'], since \"['a']\" is before \"['b']\"\n```\n\n```puppet\n$x = [1,2,3,4]\nnotice(min(*$x)) # would notice 1\n```\n\n```puppet\n$x = [1,2,3,4]\nnotice(min($x)) # would notice 1\nnotice($x.min) # would notice 1\n```\nThis example shows that a single array argument is used as the set of values\nas opposed to being a single returned value.\n\nWhen calling with a lambda, it must accept two variables and it must return\none of -1, 0, or 1 depending on if first argument is before/lower than, equal to,\nor higher/after the second argument.\n\n```puppet\nnotice(min(\"2\", \"10\", \"100\") |$a, $b| { compare($a, $b) })\n```\n\nWould notice \"10\" as lower since it is lexicographically lower/before the other values. Without the\nlambda the stdlib compatible (deprecated) behavior would have been to return \"2\" since number conversion kicks in.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"'min of values - stdlib compatible'"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"find 'min' value in an array"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"find 'min' value in an array directly - since Puppet 6.0.0"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"'min of values using a lambda'"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"min(Numeric *$values)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"*values"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"min"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"min(String *$values)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"*values"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"min"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"min(Array[Numeric] $values, Optional[Callable[2,2]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array[Numeric]"
                  ],
                  "name"=>"values"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[2,2]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"min"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"min(Array[String] $values, Optional[Callable[2,2]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array[String]"
                  ],
                  "name"=>"values"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[2,2]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"min"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"min(Array $values, Optional[Callable[2,2]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array"
                  ],
                  "name"=>"values"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[2,2]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"min"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"min(Any *$values, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"*values"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"min"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"min(Any *$values)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"*values"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"min"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:min) do\n  dispatch :on_numeric do\n    repeated_param 'Numeric', :values\n  end\n\n  dispatch :on_string do\n    repeated_param 'String', :values\n  end\n\n  dispatch :on_single_numeric_array do\n    param 'Array[Numeric]', :values\n    optional_block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :on_single_string_array do\n    param 'Array[String]', :values\n    optional_block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :on_single_any_array do\n    param 'Array', :values\n    optional_block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :on_any_with_block do\n    repeated_param 'Any', :values\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :on_any do\n    repeated_param 'Any', :values\n  end\n\n\n  # All are Numeric - ok now, will be ok later\n  def on_numeric(*args)\n    assert_arg_count(args)\n    args.min\n  end\n\n  # All are String, may convert to numeric (which is deprecated)\n  def on_string(*args)\n    assert_arg_count(args)\n\n    args.min do|a,b|\n      if a.to_s =~ %r{\\A^-?\\d+([._eE]\\d+)?\\z} && b.to_s =~ %r{\\A-?\\d+([._eE]\\d+)?\\z}\n        Puppet.warn_once('deprecations', 'min_function_numeric_coerce_string',\n          _(\"The min() function's auto conversion of String to Numeric is deprecated - change to convert input before calling, or use lambda\"))\n        a.to_f <=> b.to_f\n      else\n        # case sensitive as in the stdlib function\n        a <=> b\n      end\n    end\n  end\n\n  def on_any_with_block(*args, &block)\n    args.min {|x,y| block.call(x,y) }\n  end\n\n  def on_single_numeric_array(array, &block)\n    if block_given?\n      on_any_with_block(*array, &block)\n    else\n      on_numeric(*array)\n    end\n  end\n\n  def on_single_string_array(array, &block)\n    if block_given?\n      on_any_with_block(*array, &block)\n    else\n      on_string(*array)\n    end\n  end\n\n  def on_single_any_array(array, &block)\n    if block_given?\n      on_any_with_block(*array, &block)\n    else\n      on_any(*array)\n    end\n  end\n\n  # Mix of data types - while only some compares are actually bad it will deprecate\n  # the entire call\n  #\n  def on_any(*args)\n    assert_arg_count(args)\n    args.min do |a, b|\n      as = a.to_s\n      bs = b.to_s\n      if as =~ %r{\\A^-?\\d+([._eE]\\d+)?\\z} && bs =~ %r{\\A-?\\d+([._eE]\\d+)?\\z}\n        Puppet.warn_once('deprecations', 'min_function_numeric_coerce_string',\n          _(\"The min() function's auto conversion of String to Numeric is deprecated - change to convert input before calling, or use lambda\"))\n        a.to_f <=> b.to_f\n      else\n        Puppet.warn_once('deprecations', 'min_function_string_coerce_any',\n          _(\"The min() function's auto conversion of Any to String is deprecated - change to convert input before calling, or use lambda\"))\n        as <=> bs\n      end\n    end\n  end\n\n  def assert_arg_count(args)\n    raise(ArgumentError, 'min(): Wrong number of arguments need at least one') if args.empty?\n  end\nend"
    },
    {
      "name"=>"module_directory",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/module_directory.rb",
      "line"=>19,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"module_directory(String *$names)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"*names"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"module_directory(Array[String] *$names)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array[String]"
                ],
                "name"=>"*names"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Finds an existing module and returns the path to its root directory.\n\nThe argument to this function should be a module name String\nFor example, the reference `mysql` will search for the\ndirectory `<MODULES DIRECTORY>/mysql` and return the first\nfound on the modulepath.\n\nThis function can also accept:\n\n* Multiple String arguments, which will return the path of the **first** module\n found, skipping non existing modules.\n* An array of module names, which will return the path of the **first** module\n found from the given names in the array, skipping non existing modules.\n\nThe function returns `undef` if none of the given modules were found",
        "tags"=>[
          {
            "tag_name"=>"overload",
            "signature"=>"module_directory(String *$names)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"*names"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"module_directory"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"module_directory(Array[String] *$names)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array[String]"
                  ],
                  "name"=>"*names"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"module_directory"
          },
          {
            "tag_name"=>"since",
            "text"=>"5.4.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:module_directory, Puppet::Functions::InternalFunction) do\n  dispatch :module_directory do\n    scope_param\n    repeated_param 'String', :names\n  end\n\n  dispatch :module_directory_array do\n    scope_param\n    repeated_param 'Array[String]', :names\n  end\n\n  def module_directory_array(scope, names)\n    module_directory(scope, *names)\n  end\n\n  def module_directory(scope, *names)\n    names.each do |module_name|\n      found = scope.compiler.environment.module(module_name)\n      return found.path if found\n    end\n    nil\n  end\nend"
    },
    {
      "name"=>"new",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/new.rb",
      "line"=>983,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"new(Type $type, Any *$args, Optional[Callable] &$block)",
          "docstring"=>{
            "text"=>"Creates a new instance/object of a given data type.\n\nThis function makes it possible to create new instances of\nconcrete data types. If a block is given it is called with the\njust created instance as an argument.\n\nCalling this function is equivalent to directly\ncalling the data type:\n\n```puppet\n$a = Integer.new(\"42\")\n$b = Integer(\"42\")\n```\n\nThese would both convert the string `\"42\"` to the decimal value `42`.\n\n```puppet\n$a = Integer.new(\"42\", 8)\n$b = Integer({from => \"42\", radix => 8})\n```\n\nThis would convert the octal (radix 8) number `\"42\"` in string form\nto the decimal value `34`.\n\nThe new function supports two ways of giving the arguments:\n\n* by name (using a hash with property to value mapping)\n* by position (as regular arguments)\n\nNote that it is not possible to create new instances of\nsome abstract data types (for example `Variant`). The data type `Optional[T]` is an\nexception as it will create an instance of `T` or `undef` if the\nvalue to convert is `undef`.\n\nThe arguments that can be given is determined by the data type.\n\n> An assertion is always made that the produced value complies with the given type constraints.\n\n```puppet\nInteger[0].new(\"-100\")\n```\n\nWould fail with an assertion error (since value is less than 0).\n\nThe following sections show the arguments and conversion rules\nper data type built into the Puppet Type System.\n\n### Conversion to Optional[T] and NotUndef[T]\n\nConversion to these data types is the same as a conversion to the type argument `T`.\nIn the case of `Optional[T]` it is accepted that the argument to convert may be `undef`.\nIt is however not acceptable to give other arguments (than `undef`) that cannot be\nconverted to `T`.\n\n### Conversion to Integer\n\nA new `Integer` can be created from `Integer`, `Float`, `Boolean`, and `String` values.\nFor conversion from `String` it is possible to specify the radix (base).\n\n```puppet\ntype Radix = Variant[Default, Integer[2,2], Integer[8,8], Integer[10,10], Integer[16,16]]\n\nfunction Integer.new(\n  String $value,\n  Radix $radix = 10,\n  Boolean $abs = false\n)\n\nfunction Integer.new(\n  Variant[Numeric, Boolean] $value,\n  Boolean $abs = false\n)\n```\n\n* When converting from `String` the default radix is 10.\n* If radix is not specified an attempt is made to detect the radix from the start of the string:\n  * `0b` or `0B` is taken as radix 2.\n  * `0x` or `0X` is taken as radix 16.\n  * `0` as radix 8.\n  * All others are decimal.\n* Conversion from `String` accepts an optional sign in the string.\n* For hexadecimal (radix 16) conversion an optional leading \"0x\", or \"0X\" is accepted.\n* For octal (radix 8) an optional leading \"0\" is accepted.\n* For binary (radix 2) an optional leading \"0b\" or \"0B\" is accepted.\n* When `radix` is set to `default`, the conversion is based on the leading.\n  characters in the string. A leading \"0\" for radix 8, a leading \"0x\", or \"0X\" for\n  radix 16, and leading \"0b\" or \"0B\" for binary.\n* Conversion from `Boolean` results in 0 for `false` and 1 for `true`.\n* Conversion from `Integer`, `Float`, and `Boolean` ignores the radix.\n* `Float` value fractions are truncated (no rounding).\n* When `abs` is set to `true`, the result will be an absolute integer.\n\n```puppet\n$a_number = Integer(\"0xFF\", 16)    # results in 255\n$a_number = Integer(\"010\")         # results in 8\n$a_number = Integer(\"010\", 10)     # results in 10\n$a_number = Integer(true)          # results in 1\n$a_number = Integer(-38, 10, true) # results in 38\n```\n\n### Conversion to Float\n\nA new `Float` can be created from `Integer`, `Float`, `Boolean`, and `String` values.\nFor conversion from `String` both float and integer formats are supported.\n\n```puppet\nfunction Float.new(\n  Variant[Numeric, Boolean, String] $value,\n  Boolean $abs = true\n)\n```\n\n* For an integer, the floating point fraction of `.0` is added to the value.\n* A `Boolean` `true` is converted to 1.0, and a `false` to 0.0\n* In `String` format, integer prefixes for hex and binary are understood (but not octal since\n  floating point in string format may start with a '0').\n* When `abs` is set to `true`, the result will be an absolute floating point value.\n\n### Conversion to Numeric\n\nA new `Integer` or `Float` can be created from `Integer`, `Float`, `Boolean` and\n`String` values.\n\n```puppet\nfunction Numeric.new(\n  Variant[Numeric, Boolean, String] $value,\n  Boolean $abs = true\n)\n```\n\n* If the value has a decimal period, or if given in scientific notation\n  (e/E), the result is a `Float`, otherwise the value is an `Integer`. The\n  conversion from `String` always uses a radix based on the prefix of the string.\n* Conversion from `Boolean` results in 0 for `false` and 1 for `true`.\n* When `abs` is set to `true`, the result will be an absolute `Float`or `Integer` value.\n\n```puppet\n$a_number = Numeric(true)        # results in 1\n$a_number = Numeric(\"0xFF\")      # results in 255\n$a_number = Numeric(\"010\")       # results in 8\n$a_number = Numeric(\"3.14\")      # results in 3.14 (a float)\n$a_number = Numeric(-42.3, true) # results in 42.3\n$a_number = Numeric(-42, true)   # results in 42\n```\n\n### Conversion to Timespan\n\nA new `Timespan` can be created from `Integer`, `Float`, `String`, and `Hash` values. Several variants of the constructor are provided.\n\n**Timespan from seconds**\n\nWhen a Float is used, the decimal part represents fractions of a second.\n\n```puppet\nfunction Timespan.new(\n  Variant[Float, Integer] $value\n)\n```\n\n**Timespan from days, hours, minutes, seconds, and fractions of a second**\n\nThe arguments can be passed separately in which case the first four, days, hours, minutes, and seconds are mandatory and the rest are optional.\nAll values may overflow and/or be negative. The internal 128-bit nano-second integer is calculated as:\n\n```\n(((((days * 24 + hours) * 60 + minutes) * 60 + seconds) * 1000 + milliseconds) * 1000 + microseconds) * 1000 + nanoseconds\n```\n\n```puppet\nfunction Timespan.new(\n  Integer $days, Integer $hours, Integer $minutes, Integer $seconds,\n  Integer $milliseconds = 0, Integer $microseconds = 0, Integer $nanoseconds = 0\n)\n```\n\nor, all arguments can be passed as a `Hash`, in which case all entries are optional:\n\n```puppet\nfunction Timespan.new(\n  Struct[{\n    Optional[negative] => Boolean,\n    Optional[days] => Integer,\n    Optional[hours] => Integer,\n    Optional[minutes] => Integer,\n    Optional[seconds] => Integer,\n    Optional[milliseconds] => Integer,\n    Optional[microseconds] => Integer,\n    Optional[nanoseconds] => Integer\n  }] $hash\n)\n```\n\n**Timespan from String and format directive patterns**\n\nThe first argument is parsed using the format optionally passed as a string or array of strings. When an array is used, an attempt\nwill be made to parse the string using the first entry and then with each entry in succession until parsing succeeds. If the second\nargument is omitted, an array of default formats will be used.\n\nAn exception is raised when no format was able to parse the given string.\n\n```puppet\nfunction Timespan.new(\n  String $string, Variant[String[2],Array[String[2], 1]] $format = <default format>)\n)\n```\n\nthe arguments may also be passed as a `Hash`:\n\n```puppet\nfunction Timespan.new(\n  Struct[{\n    string => String[1],\n    Optional[format] => Variant[String[2],Array[String[2], 1]]\n  }] $hash\n)\n```\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n```\n%[Flags][Width]Conversion\n```\n\n##### Flags:\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n\n##### Format directives:\n\n| Format | Meaning |\n| ------ | ------- |\n| D | Number of Days |\n| H | Hour of the day, 24-hour clock |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..59) |\n| L | Millisecond of the second (000..999) |\n| N | Fractional seconds digits |\n\nThe format directive that represents the highest magnitude in the format will be allowed to\noverflow. I.e. if no \"%D\" is used but a \"%H\" is present, then the hours may be more than 23.\n\nThe default array contains the following patterns:\n\n```\n['%D-%H:%M:%S', '%D-%H:%M', '%H:%M:%S', '%H:%M']\n```\n\nExamples - Converting to Timespan\n\n```puppet\n$duration = Timespan(13.5)       # 13 seconds and 500 milliseconds\n$duration = Timespan({days=>4})  # 4 days\n$duration = Timespan(4, 0, 0, 2) # 4 days and 2 seconds\n$duration = Timespan('13:20')    # 13 hours and 20 minutes (using default pattern)\n$duration = Timespan('10:03.5', '%M:%S.%L') # 10 minutes, 3 seconds, and 5 milli-seconds\n$duration = Timespan('10:03.5', '%M:%S.%N') # 10 minutes, 3 seconds, and 5 nano-seconds\n```\n\n### Conversion to Timestamp\n\nA new `Timestamp` can be created from `Integer`, `Float`, `String`, and `Hash` values. Several variants of the constructor are provided.\n\n**Timestamp from seconds since epoch (1970-01-01 00:00:00 UTC)**\n\nWhen a Float is used, the decimal part represents fractions of a second.\n\n```puppet\nfunction Timestamp.new(\n  Variant[Float, Integer] $value\n)\n```\n\n**Timestamp from String and patterns consisting of format directives**\n\nThe first argument is parsed using the format optionally passed as a string or array of strings. When an array is used, an attempt\nwill be made to parse the string using the first entry and then with each entry in succession until parsing succeeds. If the second\nargument is omitted, an array of default formats will be used.\n\nA third optional timezone argument can be provided. The first argument will then be parsed as if it represents a local time in that\ntimezone. The timezone can be any timezone that is recognized when using the '%z' or '%Z' formats, or the word 'current', in which\ncase the current timezone of the evaluating process will be used. The timezone argument is case insensitive.\n\nThe default timezone, when no argument is provided, or when using the keyword `default`, is 'UTC'.\n\nIt is illegal to provide a timezone argument other than `default` in combination with a format that contains '%z' or '%Z' since that\nwould introduce an ambiguity as to which timezone to use. The one extracted from the string, or the one provided as an argument.\n\nAn exception is raised when no format was able to parse the given string.\n\n```puppet\nfunction Timestamp.new(\n  String $string,\n  Variant[String[2],Array[String[2], 1]] $format = <default format>,\n  String $timezone = default)\n)\n```\n\nthe arguments may also be passed as a `Hash`:\n\n```puppet\nfunction Timestamp.new(\n  Struct[{\n    string => String[1],\n    Optional[format] => Variant[String[2],Array[String[2], 1]],\n    Optional[timezone] => String[1]\n  }] $hash\n)\n```\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n```\n%[Flags][Width]Conversion\n```\n\n##### Flags:\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n| #     | Change names to upper-case or change case of am/pm\n| ^     | Use uppercase\n| :     | Use colons for %z\n\n##### Format directives (names and padding can be altered using flags):\n\n**Date (Year, Month, Day):**\n\n| Format | Meaning |\n| ------ | ------- |\n| Y | Year with century, zero-padded to at least 4 digits |\n| C | year / 100 (rounded down such as 20 in 2009) |\n| y | year % 100 (00..99) |\n| m | Month of the year, zero-padded (01..12) |\n| B | The full month name (\"January\") |\n| b | The abbreviated month name (\"Jan\") |\n| h | Equivalent to %b |\n| d | Day of the month, zero-padded (01..31) |\n| e | Day of the month, blank-padded ( 1..31) |\n| j | Day of the year (001..366) |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| H | Hour of the day, 24-hour clock, zero-padded (00..23) |\n| k | Hour of the day, 24-hour clock, blank-padded ( 0..23) |\n| I | Hour of the day, 12-hour clock, zero-padded (01..12) |\n| l | Hour of the day, 12-hour clock, blank-padded ( 1..12) |\n| P | Meridian indicator, lowercase (\"am\" or \"pm\") |\n| p | Meridian indicator, uppercase (\"AM\" or \"PM\") |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..60) |\n| L | Millisecond of the second (000..999). Digits under millisecond are truncated to not produce 1000 |\n| N | Fractional seconds digits, default is 9 digits (nanosecond). Digits under a specified width are truncated to avoid carry up |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| z   | Time zone as hour and minute offset from UTC (e.g. +0900) |\n| :z  | hour and minute offset from UTC with a colon (e.g. +09:00) |\n| ::z | hour, minute and second offset from UTC (e.g. +09:00:00) |\n| Z   | Abbreviated time zone name or similar information.  (OS dependent) |\n\n**Weekday:**\n\n| Format | Meaning |\n| ------ | ------- |\n| A | The full weekday name (\"Sunday\") |\n| a | The abbreviated name (\"Sun\") |\n| u | Day of the week (Monday is 1, 1..7) |\n| w | Day of the week (Sunday is 0, 0..6) |\n\n**ISO 8601 week-based year and week number:**\n\nThe first week of YYYY starts with a Monday and includes YYYY-01-04.\nThe days in the year before the first week are in the last week of\nthe previous year.\n\n| Format | Meaning |\n| ------ | ------- |\n| G | The week-based year |\n| g | The last 2 digits of the week-based year (00..99) |\n| V | Week number of the week-based year (01..53) |\n\n**Week number:**\n\nThe first week of YYYY that starts with a Sunday or Monday (according to %U\nor %W). The days in the year before the first week are in week 0.\n\n| Format | Meaning |\n| ------ | ------- |\n| U | Week number of the year. The week starts with Sunday. (00..53) |\n| W | Week number of the year. The week starts with Monday. (00..53) |\n\n**Seconds since the Epoch:**\n\n| Format | Meaning |\n| s | Number of seconds since 1970-01-01 00:00:00 UTC. |\n\n**Literal string:**\n\n| Format | Meaning |\n| ------ | ------- |\n| n | Newline character (\\n) |\n| t | Tab character (\\t) |\n| % | Literal \"%\" character |\n\n**Combination:**\n\n| Format | Meaning |\n| ------ | ------- |\n| c | date and time (%a %b %e %T %Y) |\n| D | Date (%m/%d/%y) |\n| F | The ISO 8601 date format (%Y-%m-%d) |\n| v | VMS date (%e-%^b-%4Y) |\n| x | Same as %D |\n| X | Same as %T |\n| r | 12-hour time (%I:%M:%S %p) |\n| R | 24-hour time (%H:%M) |\n| T | 24-hour time (%H:%M:%S) |\n\nThe default array contains the following patterns:\n\nWhen a timezone argument (other than `default`) is explicitly provided:\n\n```\n['%FT%T.L', '%FT%T', '%F']\n```\n\notherwise:\n\n```\n['%FT%T.%L %Z', '%FT%T %Z', '%F %Z', '%FT%T.L', '%FT%T', '%F']\n```\n\nExamples - Converting to Timestamp\n\n```puppet\n$ts = Timestamp(1473150899)                              # 2016-09-06 08:34:59 UTC\n$ts = Timestamp({string=>'2015', format=>'%Y'})          # 2015-01-01 00:00:00.000 UTC\n$ts = Timestamp('Wed Aug 24 12:13:14 2016', '%c')        # 2016-08-24 12:13:14 UTC\n$ts = Timestamp('Wed Aug 24 12:13:14 2016 PDT', '%c %Z') # 2016-08-24 19:13:14.000 UTC\n$ts = Timestamp('2016-08-24 12:13:14', '%F %T', 'PST')   # 2016-08-24 20:13:14.000 UTC\n$ts = Timestamp('2016-08-24T12:13:14', default, 'PST')   # 2016-08-24 20:13:14.000 UTC\n\n```\n\n### Conversion to Type\n\nA new `Type` can be created from its `String` representation.\n\n```puppet\n$t = Type.new('Integer[10]')\n```\n\n### Conversion to String\n\nConversion to `String` is the most comprehensive conversion as there are many\nuse cases where a string representation is wanted. The defaults for the many options\nhave been chosen with care to be the most basic \"value in textual form\" representation.\nThe more advanced forms of formatting are intended to enable writing special purposes formatting\nfunctions in the Puppet language.\n\nA new string can be created from all other data types. The process is performed in\nseveral steps - first the data type of the given value is inferred, then the resulting data type\nis used to find the most significant format specified for that data type. And finally,\nthe found format is used to convert the given value.\n\nThe mapping from data type to format is referred to as the *format map*. This map\nallows different formatting depending on type.\n\n```puppet\n$format_map = {\n  Integer[default, 0] => \"%d\",\n  Integer[1, default] => \"%#x\"\n}\nString(\"-1\", $format_map)  # produces '-1'\nString(\"10\", $format_map)  # produces '0xa'\n```\n\nA format is specified on the form:\n\n```\n%[Flags][Width][.Precision]Format\n```\n\n`Width` is the number of characters into which the value should be fitted. This allocated space is\npadded if value is shorter. By default it is space padded, and the flag `0` will cause padding with `0`\nfor numerical formats.\n\n`Precision` is the number of fractional digits to show for floating point, and the maximum characters\nincluded in a string format.\n\nNote that all data type supports the formats `s` and `p` with the meaning \"default string representation\" and\n\"default programmatic string representation\" (which for example means that a String is quoted in 'p' format).\n\n**Signatures of String conversion**\n\n```puppet\ntype Format = Pattern[/^%([\\s\\+\\-#0\\[\\{<\\(\\|]*)([1-9][0-9]*)?(?:\\.([0-9]+))?([a-zA-Z])/]\ntype ContainerFormat = Struct[{\n  format         => Optional[String],\n  separator      => Optional[String],\n  separator2     => Optional[String],\n  string_formats => Hash[Type, Format]\n  }]\ntype TypeMap = Hash[Type, Variant[Format, ContainerFormat]]\ntype Formats = Variant[Default, String[1], TypeMap]\n\nfunction String.new(\n  Any $value,\n  Formats $string_formats\n)\n```\n\nWhere:\n\n* `separator` is the string used to separate entries in an array, or hash (extra space should not be included at\n  the end), defaults to `\",\"`\n* `separator2` is the separator between key and value in a hash entry (space padding should be included as\n  wanted), defaults to `\" => \"`.\n* `string_formats` is a data type to format map for values contained in arrays and hashes - defaults to `{Any => \"%p\"}`. Note that\n  these nested formats are not applicable to data types that are containers; they are always formatted as per the top level\n  format specification.\n\n```puppet\n$str = String(10)      # produces '10'\n$str = String([10])    # produces '[\"10\"]'\n```\n\n```puppet\n$str = String(10, \"%#x\")    # produces '0x10'\n$str = String([10], \"%(a\")  # produces '(\"10\")'\n```\n\n```puppet\n$formats = {\n  Array => {\n    format => '%(a',\n    string_formats => { Integer => '%#x' }\n  }\n}\n$str = String([1,2,3], $formats) # produces '(0x1, 0x2, 0x3)'\n```\n\nThe given formats are merged with the default formats, and matching of values to convert against format is based on\nthe specificity of the mapped type; for example, different formats can be used for short and long arrays.\n\n**Integer to String**\n\n| Format  | Integer Formats\n| ------  | ---------------\n| d       | Decimal, negative values produces leading '-'.\n| x X     | Hexadecimal in lower or upper case. Uses ..f/..F for negative values unless + is also used. A `#` adds prefix 0x/0X.\n| o       | Octal. Uses ..0 for negative values unless `+` is also used. A `#` adds prefix 0.\n| b B     | Binary with prefix 'b' or 'B'. Uses ..1/..1 for negative values unless `+` is also used.\n| c       | Numeric value representing a Unicode value, result is a one unicode character string, quoted if alternative flag # is used\n| s       | Same as d, or d in quotes if alternative flag # is used.\n| p       | Same as d.\n| eEfgGaA | Converts integer to float and formats using the floating point rules.\n\nDefaults to `d`.\n\n**Float to String**\n\n| Format  | Float formats\n| ------  | -------------\n| f       | Floating point in non exponential notation.\n| e E     | Exponential notation with 'e' or 'E'.\n| g G     | Conditional exponential with 'e' or 'E' if exponent < -4 or >= the precision.\n| a A     | Hexadecimal exponential form, using 'x'/'X' as prefix and 'p'/'P' before exponent.\n| s       | Converted to string using format p, then applying string formatting rule, alternate form # quotes result.\n| p       | Same as f format with minimum significant number of fractional digits, prec has no effect.\n| dxXobBc | Converts float to integer and formats using the integer rules.\n\nDefaults to `p`.\n\n**String to String**\n\n| Format | String\n| ------ | ------\n| s      | Unquoted string, verbatim output of control chars.\n| p      | Programmatic representation - strings are quoted, interior quotes and control chars are escaped. Selects single or double quotes based on content, or uses double quotes if alternative flag `#` is used.\n| C      | Each `::` name segment capitalized, quoted if alternative flag `#` is used.\n| c      | Capitalized string, quoted if alternative flag `#` is used.\n| d      | Downcased string, quoted if alternative flag `#` is used.\n| u      | Upcased string, quoted if alternative flag `#` is used.\n| t      | Trims leading and trailing whitespace from the string, quoted if alternative flag `#` is used.\n\nDefaults to `s` at top level and `p` inside array or hash.\n\n**Boolean to String**\n\n| Format    | Boolean Formats\n| ----      | -------------------\n| t T       | String 'true'/'false' or 'True'/'False', first char if alternate form is used (i.e. 't'/'f' or 'T'/'F').\n| y Y       | String 'yes'/'no', 'Yes'/'No', 'y'/'n' or 'Y'/'N' if alternative flag `#` is used.\n| dxXobB    | Numeric value 0/1 in accordance with the given format which must be valid integer format.\n| eEfgGaA   | Numeric value 0.0/1.0 in accordance with the given float format and flags.\n| s         | String 'true' / 'false'.\n| p         | String 'true' / 'false'.\n\n**Regexp to String**\n\n| Format    | Regexp Formats\n| ----      | --------------\n| s         | No delimiters, quoted if alternative flag `#` is used.\n| p         | Delimiters `/ /`.\n\n**Undef to String**\n\n| Format    | Undef formats\n| ------    | -------------\n| s         | Empty string, or quoted empty string if alternative flag `#` is used.\n| p         | String 'undef', or quoted '\"undef\"' if alternative flag `#` is used.\n| n         | String 'nil', or 'null' if alternative flag `#` is used.\n| dxXobB    | String 'NaN'.\n| eEfgGaA   | String 'NaN'.\n| v         | String 'n/a'.\n| V         | String 'N/A'.\n| u         | String 'undef', or 'undefined' if alternative `#` flag is used.\n\n**Default value to String**\n\n| Format    | Default formats\n| ------    | ---------------\n| d D       | String 'default' or 'Default', alternative form `#` causes value to be quoted.\n| s         | Same as d.\n| p         | Same as d.\n\n**Binary value to String**\n\n| Format    | Default formats\n| ------    | ---------------\n| s         | binary as unquoted UTF-8 characters (errors if byte sequence is invalid UTF-8). Alternate form escapes non ascii bytes.\n| p         | 'Binary(\"<base64strict>\")'\n| b         | '<base64>' - base64 string with newlines inserted\n| B         | '<base64strict>' - base64 strict string (without newlines inserted)\n| u         | '<base64urlsafe>' - base64 urlsafe string\n| t         | 'Binary' - outputs the name of the type only\n| T         | 'BINARY' - output the name of the type in all caps only\n\n* The alternate form flag `#` will quote the binary or base64 text output.\n* The format `%#s` allows invalid UTF-8 characters and outputs all non ascii bytes\n  as hex escaped characters on the form `\\\\xHH` where `H` is a hex digit.\n* The width and precision values are applied to the text part only in `%p` format.\n\n**Array & Tuple to String**\n\n| Format    | Array/Tuple Formats\n| ------    | -------------\n| a         | Formats with `[ ]` delimiters and `,`, alternate form `#` indents nested arrays/hashes.\n| s         | Same as a.\n| p         | Same as a.\n\nSee \"Flags\" `<[({\\|` for formatting of delimiters, and \"Additional parameters for containers; Array and Hash\" for\nmore information about options.\n\nThe alternate form flag `#` will cause indentation of nested array or hash containers. If width is also set\nit is taken as the maximum allowed length of a sequence of elements (not including delimiters). If this max length\nis exceeded, each element will be indented.\n\n**Hash & Struct to String**\n\n| Format    | Hash/Struct Formats\n| ------    | -------------\n| h         | Formats with `{ }` delimiters, `,` element separator and ` => ` inner element separator unless overridden by flags.\n| s         | Same as h.\n| p         | Same as h.\n| a         | Converts the hash to an array of [k,v] tuples and formats it using array rule(s).\n\nSee \"Flags\" `<[({\\|` for formatting of delimiters, and \"Additional parameters for containers; Array and Hash\" for\nmore information about options.\n\nThe alternate form flag `#` will format each hash key/value entry indented on a separate line.\n\n**Type to String**\n\n| Format    | Array/Tuple Formats\n| ------    | -------------\n| s         | The same as `p`, quoted if alternative flag `#` is used.\n| p         | Outputs the type in string form as specified by the Puppet Language.\n\n**Flags**\n\n| Flag     | Effect\n| ------   | ------\n| (space)  | A space instead of `+` for numeric output (`-` is shown), for containers skips delimiters.\n| #        | Alternate format; prefix 0x/0x, 0 (octal) and 0b/0B for binary, Floats force decimal '.'. For g/G keep trailing 0.\n| +        | Show sign +/- depending on value's sign, changes x, X, o, b, B format to not use 2's complement form.\n| -        | Left justify the value in the given width.\n| 0        | Pad with 0 instead of space for widths larger than value.\n| <[({\\|   | Defines an enclosing pair <> [] () {} or \\| \\| when used with a container type.\n\n### Conversion to Boolean\n\nAccepts a single value as argument:\n\n* Float 0.0 is `false`, all other float values are `true`\n* Integer 0 is `false`, all other integer values are `true`\n* Strings\n  * `true` if 'true', 'yes', 'y' (case independent compare)\n  * `false` if 'false', 'no', 'n' (case independent compare)\n* Boolean is already boolean and is simply returned\n\n### Conversion to Array and Tuple\n\nWhen given a single value as argument:\n\n* A non empty `Hash` is converted to an array matching `Array[Tuple[Any,Any], 1]`.\n* An empty `Hash` becomes an empty array.\n* An `Array` is simply returned.\n* An `Iterable[T]` is turned into an array of `T` instances.\n* A `Binary` is converted to an `Array[Integer[0,255]]` of byte values\n\nWhen given a second Boolean argument:\n\n* if `true`, a value that is not already an array is returned as a one element array.\n* if `false`, (the default), converts the first argument as shown above.\n\n```puppet\n$arr = Array($value, true)\n```\n\nConversion to a `Tuple` works exactly as conversion to an `Array`, only that the constructed array is\nasserted against the given tuple type.\n\n### Conversion to Hash and Struct\n\nAccepts a single value as argument:\n\n* An empty `Array` becomes an empty `Hash`\n* An `Array` matching `Array[Tuple[Any,Any], 1]` is converted to a hash where each tuple describes a key/value entry\n* An `Array` with an even number of entries is interpreted as `[key1, val1, key2, val2, ...]`\n* An `Iterable` is turned into an `Array` and then converted to hash as per the array rules\n* A `Hash` is simply returned\n\nAlternatively, a tree can be constructed by giving two values; an array of tuples on the form `[path, value]`\n(where the `path` is the path from the root of a tree, and `value` the value at that position in the tree), and\neither the option `'tree'` (do not convert arrays to hashes except the top level), or\n`'hash_tree'` (convert all arrays to hashes).\n\nThe tree/hash_tree forms of Hash creation are suited for transforming the result of an iteration\nusing `tree_each` and subsequent filtering or mapping.\n\nMapping an arbitrary structure in a way that keeps the structure, but where some values are replaced\ncan be done by using the `tree_each` function, mapping, and then constructing a new Hash from the result:\n\n```puppet\n# A hash tree with 'water' at different locations\n$h = { a => { b => { x => 'water'}}, b => { y => 'water'} }\n# a helper function that turns water into wine\nfunction make_wine($x) { if $x == 'water' { 'wine' } else { $x } }\n# create a flattened tree with water turned into wine\n$flat_tree = $h.tree_each.map |$entry| { [$entry[0], make_wine($entry[1])] }\n# create a new Hash and log it\nnotice Hash($flat_tree, 'hash_tree')\n```\n\nWould notice the hash `{a => {b => {x => wine}}, b => {y => wine}}`\n\nConversion to a `Struct` works exactly as conversion to a `Hash`, only that the constructed hash is\nasserted against the given struct type.\n\n### Conversion to a Regexp\n\nA `String` can be converted into a `Regexp`\n\n**Example**: Converting a String into a Regexp\n```puppet\n$s = '[a-z]+\\.com'\n$r = Regexp($s)\nif('foo.com' =~ $r) {\n  ...\n}\n```\n\n### Creating a SemVer\n\nA SemVer object represents a single [Semantic Version](http://semver.org/).\nIt can be created from a String, individual values for its parts, or a hash specifying the value per part.\nSee the specification at [semver.org](http://semver.org/) for the meaning of the SemVer's parts.\n\nThe signatures are:\n\n```puppet\ntype PositiveInteger = Integer[0,default]\ntype SemVerQualifier = Pattern[/\\A(?<part>[0-9A-Za-z-]+)(?:\\.\\g<part>)*\\Z/]\ntype SemVerString = String[1]\ntype SemVerHash =Struct[{\n  major                => PositiveInteger,\n  minor                => PositiveInteger,\n  patch                => PositiveInteger,\n  Optional[prerelease] => SemVerQualifier,\n  Optional[build]      => SemVerQualifier\n}]\n\nfunction SemVer.new(SemVerString $str)\n\nfunction SemVer.new(\n        PositiveInteger           $major\n        PositiveInteger           $minor\n        PositiveInteger           $patch\n        Optional[SemVerQualifier] $prerelease = undef\n        Optional[SemVerQualifier] $build = undef\n        )\n\nfunction SemVer.new(SemVerHash $hash_args)\n```\n\n```puppet\n# As a type, SemVer can describe disjunct ranges which versions can be\n# matched against - here the type is constructed with two\n# SemVerRange objects.\n#\n$t = SemVer[\n  SemVerRange('>=1.0.0 <2.0.0'),\n  SemVerRange('>=3.0.0 <4.0.0')\n]\nnotice(SemVer('1.2.3') =~ $t) # true\nnotice(SemVer('2.3.4') =~ $t) # false\nnotice(SemVer('3.4.5') =~ $t) # true\n```\n\n### Creating a SemVerRange\n\nA `SemVerRange` object represents a range of `SemVer`. It can be created from\na `String`, or from two `SemVer` instances, where either end can be given as\na literal `default` to indicate infinity. The string format of a `SemVerRange` is specified by\nthe [Semantic Version Range Grammar](https://github.com/npm/node-semver#ranges).\n\n> Use of the comparator sets described in the grammar (joining with `||`) is not supported.\n\nThe signatures are:\n\n```puppet\ntype SemVerRangeString = String[1]\ntype SemVerRangeHash = Struct[{\n  min                   => Variant[Default, SemVer],\n  Optional[max]         => Variant[Default, SemVer],\n  Optional[exclude_max] => Boolean\n}]\n\nfunction SemVerRange.new(\n  SemVerRangeString $semver_range_string\n)\n\nfunction SemVerRange.new(\n  Variant[Default,SemVer] $min\n  Variant[Default,SemVer] $max\n  Optional[Boolean]       $exclude_max = undef\n)\n\nfunction SemVerRange.new(\n  SemVerRangeHash $semver_range_hash\n)\n```\n\nFor examples of `SemVerRange` use see \"Creating a SemVer\"\n\n### Creating a Binary\n\nA `Binary` object represents a sequence of bytes and it can be created from a String in Base64 format,\nan Array containing byte values. A Binary can also be created from a Hash containing the value to convert to\na `Binary`.\n\nThe signatures are:\n\n```puppet\ntype ByteInteger = Integer[0,255]\ntype Base64Format = Enum[\"%b\", \"%u\", \"%B\", \"%s\"]\ntype StringHash = Struct[{value => String, \"format\" => Optional[Base64Format]}]\ntype ArrayHash = Struct[{value => Array[ByteInteger]}]\ntype BinaryArgsHash = Variant[StringHash, ArrayHash]\n\nfunction Binary.new(\n  String $base64_str,\n  Optional[Base64Format] $format\n)\n\n\nfunction Binary.new(\n  Array[ByteInteger] $byte_array\n}\n\n# Same as for String, or for Array, but where arguments are given in a Hash.\nfunction Binary.new(BinaryArgsHash $hash_args)\n```\n\nThe formats have the following meaning:\n\n| format | explanation |\n| ----   | ----        |\n| B | The data is in base64 strict encoding\n| u | The data is in URL safe base64 encoding\n| b | The data is in base64 encoding, padding as required by base64 strict, is added by default\n| s | The data is a puppet string. The string must be valid UTF-8, or convertible to UTF-8 or an error is raised.\n| r | (Ruby Raw) the byte sequence in the given string is used verbatim irrespective of possible encoding errors\n\n* The default format is `%B`.\n* Note that the format `%r` should be used sparingly, or not at all. It exists for backwards compatibility reasons when someone receiving\n  a string from some function and that string should be treated as Binary. Such code should be changed to return a Binary instead of a String.\n\n```puppet\n# create the binary content \"abc\"\n$a = Binary('YWJj')\n\n# create the binary content from content in a module's file\n$b = binary_file('mymodule/mypicture.jpg')\n```\n\n* Since 4.5.0\n* Binary type since 4.8.0\n\n### Creating an instance of a `Type` using the `Init` type\n\nThe type `Init[T]` describes a value that can be used when instantiating a type. When used as the first argument in a call to `new`, it\nwill dispatch the call to its contained type and optionally augment the parameter list with additional arguments.\n\n```puppet\n# The following declaration\n$x = Init[Integer].new('128')\n# is exactly the same as\n$x = Integer.new('128')\n```\n\nor, with base 16 and using implicit new\n\n```puppet\n# The following declaration\n$x = Init[Integer,16]('80')\n# is exactly the same as\n$x = Integer('80', 16)\n```\n\n```puppet\n$fmt = Init[String,'%#x']\nnotice($fmt(256)) # will notice '0x100'\n```",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"`new` and calling type directly are equivalent"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"arguments by position or by name"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"data type constraints are checked"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Converting to Integer in multiple ways"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Converting to Numeric in different ways"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Creating a type from a string"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Positive Integers in Hexadecimal prefixed with '0x', negative in Decimal"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Simple Conversion to String (using defaults)"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Simple Conversion to String specifying the format for the given value directly"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Specifying type for values contained in an array"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Ensuring value is an array"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Mapping a hash tree"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"SemVer and SemVerRange usage"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Creating a Binary"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Creating an instance of Integer using Init[Integer]"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Creating an instance of String using a predefined format"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Type"
                ],
                "name"=>"type"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"*args"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Creates a new instance/object of a given data type.\n\nThis function makes it possible to create new instances of\nconcrete data types. If a block is given it is called with the\njust created instance as an argument.\n\nCalling this function is equivalent to directly\ncalling the data type:\n\n```puppet\n$a = Integer.new(\"42\")\n$b = Integer(\"42\")\n```\n\nThese would both convert the string `\"42\"` to the decimal value `42`.\n\n```puppet\n$a = Integer.new(\"42\", 8)\n$b = Integer({from => \"42\", radix => 8})\n```\n\nThis would convert the octal (radix 8) number `\"42\"` in string form\nto the decimal value `34`.\n\nThe new function supports two ways of giving the arguments:\n\n* by name (using a hash with property to value mapping)\n* by position (as regular arguments)\n\nNote that it is not possible to create new instances of\nsome abstract data types (for example `Variant`). The data type `Optional[T]` is an\nexception as it will create an instance of `T` or `undef` if the\nvalue to convert is `undef`.\n\nThe arguments that can be given is determined by the data type.\n\n> An assertion is always made that the produced value complies with the given type constraints.\n\n```puppet\nInteger[0].new(\"-100\")\n```\n\nWould fail with an assertion error (since value is less than 0).\n\nThe following sections show the arguments and conversion rules\nper data type built into the Puppet Type System.\n\n### Conversion to Optional[T] and NotUndef[T]\n\nConversion to these data types is the same as a conversion to the type argument `T`.\nIn the case of `Optional[T]` it is accepted that the argument to convert may be `undef`.\nIt is however not acceptable to give other arguments (than `undef`) that cannot be\nconverted to `T`.\n\n### Conversion to Integer\n\nA new `Integer` can be created from `Integer`, `Float`, `Boolean`, and `String` values.\nFor conversion from `String` it is possible to specify the radix (base).\n\n```puppet\ntype Radix = Variant[Default, Integer[2,2], Integer[8,8], Integer[10,10], Integer[16,16]]\n\nfunction Integer.new(\n  String $value,\n  Radix $radix = 10,\n  Boolean $abs = false\n)\n\nfunction Integer.new(\n  Variant[Numeric, Boolean] $value,\n  Boolean $abs = false\n)\n```\n\n* When converting from `String` the default radix is 10.\n* If radix is not specified an attempt is made to detect the radix from the start of the string:\n  * `0b` or `0B` is taken as radix 2.\n  * `0x` or `0X` is taken as radix 16.\n  * `0` as radix 8.\n  * All others are decimal.\n* Conversion from `String` accepts an optional sign in the string.\n* For hexadecimal (radix 16) conversion an optional leading \"0x\", or \"0X\" is accepted.\n* For octal (radix 8) an optional leading \"0\" is accepted.\n* For binary (radix 2) an optional leading \"0b\" or \"0B\" is accepted.\n* When `radix` is set to `default`, the conversion is based on the leading.\n  characters in the string. A leading \"0\" for radix 8, a leading \"0x\", or \"0X\" for\n  radix 16, and leading \"0b\" or \"0B\" for binary.\n* Conversion from `Boolean` results in 0 for `false` and 1 for `true`.\n* Conversion from `Integer`, `Float`, and `Boolean` ignores the radix.\n* `Float` value fractions are truncated (no rounding).\n* When `abs` is set to `true`, the result will be an absolute integer.\n\n```puppet\n$a_number = Integer(\"0xFF\", 16)    # results in 255\n$a_number = Integer(\"010\")         # results in 8\n$a_number = Integer(\"010\", 10)     # results in 10\n$a_number = Integer(true)          # results in 1\n$a_number = Integer(-38, 10, true) # results in 38\n```\n\n### Conversion to Float\n\nA new `Float` can be created from `Integer`, `Float`, `Boolean`, and `String` values.\nFor conversion from `String` both float and integer formats are supported.\n\n```puppet\nfunction Float.new(\n  Variant[Numeric, Boolean, String] $value,\n  Boolean $abs = true\n)\n```\n\n* For an integer, the floating point fraction of `.0` is added to the value.\n* A `Boolean` `true` is converted to 1.0, and a `false` to 0.0\n* In `String` format, integer prefixes for hex and binary are understood (but not octal since\n  floating point in string format may start with a '0').\n* When `abs` is set to `true`, the result will be an absolute floating point value.\n\n### Conversion to Numeric\n\nA new `Integer` or `Float` can be created from `Integer`, `Float`, `Boolean` and\n`String` values.\n\n```puppet\nfunction Numeric.new(\n  Variant[Numeric, Boolean, String] $value,\n  Boolean $abs = true\n)\n```\n\n* If the value has a decimal period, or if given in scientific notation\n  (e/E), the result is a `Float`, otherwise the value is an `Integer`. The\n  conversion from `String` always uses a radix based on the prefix of the string.\n* Conversion from `Boolean` results in 0 for `false` and 1 for `true`.\n* When `abs` is set to `true`, the result will be an absolute `Float`or `Integer` value.\n\n```puppet\n$a_number = Numeric(true)        # results in 1\n$a_number = Numeric(\"0xFF\")      # results in 255\n$a_number = Numeric(\"010\")       # results in 8\n$a_number = Numeric(\"3.14\")      # results in 3.14 (a float)\n$a_number = Numeric(-42.3, true) # results in 42.3\n$a_number = Numeric(-42, true)   # results in 42\n```\n\n### Conversion to Timespan\n\nA new `Timespan` can be created from `Integer`, `Float`, `String`, and `Hash` values. Several variants of the constructor are provided.\n\n**Timespan from seconds**\n\nWhen a Float is used, the decimal part represents fractions of a second.\n\n```puppet\nfunction Timespan.new(\n  Variant[Float, Integer] $value\n)\n```\n\n**Timespan from days, hours, minutes, seconds, and fractions of a second**\n\nThe arguments can be passed separately in which case the first four, days, hours, minutes, and seconds are mandatory and the rest are optional.\nAll values may overflow and/or be negative. The internal 128-bit nano-second integer is calculated as:\n\n```\n(((((days * 24 + hours) * 60 + minutes) * 60 + seconds) * 1000 + milliseconds) * 1000 + microseconds) * 1000 + nanoseconds\n```\n\n```puppet\nfunction Timespan.new(\n  Integer $days, Integer $hours, Integer $minutes, Integer $seconds,\n  Integer $milliseconds = 0, Integer $microseconds = 0, Integer $nanoseconds = 0\n)\n```\n\nor, all arguments can be passed as a `Hash`, in which case all entries are optional:\n\n```puppet\nfunction Timespan.new(\n  Struct[{\n    Optional[negative] => Boolean,\n    Optional[days] => Integer,\n    Optional[hours] => Integer,\n    Optional[minutes] => Integer,\n    Optional[seconds] => Integer,\n    Optional[milliseconds] => Integer,\n    Optional[microseconds] => Integer,\n    Optional[nanoseconds] => Integer\n  }] $hash\n)\n```\n\n**Timespan from String and format directive patterns**\n\nThe first argument is parsed using the format optionally passed as a string or array of strings. When an array is used, an attempt\nwill be made to parse the string using the first entry and then with each entry in succession until parsing succeeds. If the second\nargument is omitted, an array of default formats will be used.\n\nAn exception is raised when no format was able to parse the given string.\n\n```puppet\nfunction Timespan.new(\n  String $string, Variant[String[2],Array[String[2], 1]] $format = <default format>)\n)\n```\n\nthe arguments may also be passed as a `Hash`:\n\n```puppet\nfunction Timespan.new(\n  Struct[{\n    string => String[1],\n    Optional[format] => Variant[String[2],Array[String[2], 1]]\n  }] $hash\n)\n```\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n```\n%[Flags][Width]Conversion\n```\n\n##### Flags:\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n\n##### Format directives:\n\n| Format | Meaning |\n| ------ | ------- |\n| D | Number of Days |\n| H | Hour of the day, 24-hour clock |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..59) |\n| L | Millisecond of the second (000..999) |\n| N | Fractional seconds digits |\n\nThe format directive that represents the highest magnitude in the format will be allowed to\noverflow. I.e. if no \"%D\" is used but a \"%H\" is present, then the hours may be more than 23.\n\nThe default array contains the following patterns:\n\n```\n['%D-%H:%M:%S', '%D-%H:%M', '%H:%M:%S', '%H:%M']\n```\n\nExamples - Converting to Timespan\n\n```puppet\n$duration = Timespan(13.5)       # 13 seconds and 500 milliseconds\n$duration = Timespan({days=>4})  # 4 days\n$duration = Timespan(4, 0, 0, 2) # 4 days and 2 seconds\n$duration = Timespan('13:20')    # 13 hours and 20 minutes (using default pattern)\n$duration = Timespan('10:03.5', '%M:%S.%L') # 10 minutes, 3 seconds, and 5 milli-seconds\n$duration = Timespan('10:03.5', '%M:%S.%N') # 10 minutes, 3 seconds, and 5 nano-seconds\n```\n\n### Conversion to Timestamp\n\nA new `Timestamp` can be created from `Integer`, `Float`, `String`, and `Hash` values. Several variants of the constructor are provided.\n\n**Timestamp from seconds since epoch (1970-01-01 00:00:00 UTC)**\n\nWhen a Float is used, the decimal part represents fractions of a second.\n\n```puppet\nfunction Timestamp.new(\n  Variant[Float, Integer] $value\n)\n```\n\n**Timestamp from String and patterns consisting of format directives**\n\nThe first argument is parsed using the format optionally passed as a string or array of strings. When an array is used, an attempt\nwill be made to parse the string using the first entry and then with each entry in succession until parsing succeeds. If the second\nargument is omitted, an array of default formats will be used.\n\nA third optional timezone argument can be provided. The first argument will then be parsed as if it represents a local time in that\ntimezone. The timezone can be any timezone that is recognized when using the '%z' or '%Z' formats, or the word 'current', in which\ncase the current timezone of the evaluating process will be used. The timezone argument is case insensitive.\n\nThe default timezone, when no argument is provided, or when using the keyword `default`, is 'UTC'.\n\nIt is illegal to provide a timezone argument other than `default` in combination with a format that contains '%z' or '%Z' since that\nwould introduce an ambiguity as to which timezone to use. The one extracted from the string, or the one provided as an argument.\n\nAn exception is raised when no format was able to parse the given string.\n\n```puppet\nfunction Timestamp.new(\n  String $string,\n  Variant[String[2],Array[String[2], 1]] $format = <default format>,\n  String $timezone = default)\n)\n```\n\nthe arguments may also be passed as a `Hash`:\n\n```puppet\nfunction Timestamp.new(\n  Struct[{\n    string => String[1],\n    Optional[format] => Variant[String[2],Array[String[2], 1]],\n    Optional[timezone] => String[1]\n  }] $hash\n)\n```\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n```\n%[Flags][Width]Conversion\n```\n\n##### Flags:\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n| #     | Change names to upper-case or change case of am/pm\n| ^     | Use uppercase\n| :     | Use colons for %z\n\n##### Format directives (names and padding can be altered using flags):\n\n**Date (Year, Month, Day):**\n\n| Format | Meaning |\n| ------ | ------- |\n| Y | Year with century, zero-padded to at least 4 digits |\n| C | year / 100 (rounded down such as 20 in 2009) |\n| y | year % 100 (00..99) |\n| m | Month of the year, zero-padded (01..12) |\n| B | The full month name (\"January\") |\n| b | The abbreviated month name (\"Jan\") |\n| h | Equivalent to %b |\n| d | Day of the month, zero-padded (01..31) |\n| e | Day of the month, blank-padded ( 1..31) |\n| j | Day of the year (001..366) |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| H | Hour of the day, 24-hour clock, zero-padded (00..23) |\n| k | Hour of the day, 24-hour clock, blank-padded ( 0..23) |\n| I | Hour of the day, 12-hour clock, zero-padded (01..12) |\n| l | Hour of the day, 12-hour clock, blank-padded ( 1..12) |\n| P | Meridian indicator, lowercase (\"am\" or \"pm\") |\n| p | Meridian indicator, uppercase (\"AM\" or \"PM\") |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..60) |\n| L | Millisecond of the second (000..999). Digits under millisecond are truncated to not produce 1000 |\n| N | Fractional seconds digits, default is 9 digits (nanosecond). Digits under a specified width are truncated to avoid carry up |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| z   | Time zone as hour and minute offset from UTC (e.g. +0900) |\n| :z  | hour and minute offset from UTC with a colon (e.g. +09:00) |\n| ::z | hour, minute and second offset from UTC (e.g. +09:00:00) |\n| Z   | Abbreviated time zone name or similar information.  (OS dependent) |\n\n**Weekday:**\n\n| Format | Meaning |\n| ------ | ------- |\n| A | The full weekday name (\"Sunday\") |\n| a | The abbreviated name (\"Sun\") |\n| u | Day of the week (Monday is 1, 1..7) |\n| w | Day of the week (Sunday is 0, 0..6) |\n\n**ISO 8601 week-based year and week number:**\n\nThe first week of YYYY starts with a Monday and includes YYYY-01-04.\nThe days in the year before the first week are in the last week of\nthe previous year.\n\n| Format | Meaning |\n| ------ | ------- |\n| G | The week-based year |\n| g | The last 2 digits of the week-based year (00..99) |\n| V | Week number of the week-based year (01..53) |\n\n**Week number:**\n\nThe first week of YYYY that starts with a Sunday or Monday (according to %U\nor %W). The days in the year before the first week are in week 0.\n\n| Format | Meaning |\n| ------ | ------- |\n| U | Week number of the year. The week starts with Sunday. (00..53) |\n| W | Week number of the year. The week starts with Monday. (00..53) |\n\n**Seconds since the Epoch:**\n\n| Format | Meaning |\n| s | Number of seconds since 1970-01-01 00:00:00 UTC. |\n\n**Literal string:**\n\n| Format | Meaning |\n| ------ | ------- |\n| n | Newline character (\\n) |\n| t | Tab character (\\t) |\n| % | Literal \"%\" character |\n\n**Combination:**\n\n| Format | Meaning |\n| ------ | ------- |\n| c | date and time (%a %b %e %T %Y) |\n| D | Date (%m/%d/%y) |\n| F | The ISO 8601 date format (%Y-%m-%d) |\n| v | VMS date (%e-%^b-%4Y) |\n| x | Same as %D |\n| X | Same as %T |\n| r | 12-hour time (%I:%M:%S %p) |\n| R | 24-hour time (%H:%M) |\n| T | 24-hour time (%H:%M:%S) |\n\nThe default array contains the following patterns:\n\nWhen a timezone argument (other than `default`) is explicitly provided:\n\n```\n['%FT%T.L', '%FT%T', '%F']\n```\n\notherwise:\n\n```\n['%FT%T.%L %Z', '%FT%T %Z', '%F %Z', '%FT%T.L', '%FT%T', '%F']\n```\n\nExamples - Converting to Timestamp\n\n```puppet\n$ts = Timestamp(1473150899)                              # 2016-09-06 08:34:59 UTC\n$ts = Timestamp({string=>'2015', format=>'%Y'})          # 2015-01-01 00:00:00.000 UTC\n$ts = Timestamp('Wed Aug 24 12:13:14 2016', '%c')        # 2016-08-24 12:13:14 UTC\n$ts = Timestamp('Wed Aug 24 12:13:14 2016 PDT', '%c %Z') # 2016-08-24 19:13:14.000 UTC\n$ts = Timestamp('2016-08-24 12:13:14', '%F %T', 'PST')   # 2016-08-24 20:13:14.000 UTC\n$ts = Timestamp('2016-08-24T12:13:14', default, 'PST')   # 2016-08-24 20:13:14.000 UTC\n\n```\n\n### Conversion to Type\n\nA new `Type` can be created from its `String` representation.\n\n```puppet\n$t = Type.new('Integer[10]')\n```\n\n### Conversion to String\n\nConversion to `String` is the most comprehensive conversion as there are many\nuse cases where a string representation is wanted. The defaults for the many options\nhave been chosen with care to be the most basic \"value in textual form\" representation.\nThe more advanced forms of formatting are intended to enable writing special purposes formatting\nfunctions in the Puppet language.\n\nA new string can be created from all other data types. The process is performed in\nseveral steps - first the data type of the given value is inferred, then the resulting data type\nis used to find the most significant format specified for that data type. And finally,\nthe found format is used to convert the given value.\n\nThe mapping from data type to format is referred to as the *format map*. This map\nallows different formatting depending on type.\n\n```puppet\n$format_map = {\n  Integer[default, 0] => \"%d\",\n  Integer[1, default] => \"%#x\"\n}\nString(\"-1\", $format_map)  # produces '-1'\nString(\"10\", $format_map)  # produces '0xa'\n```\n\nA format is specified on the form:\n\n```\n%[Flags][Width][.Precision]Format\n```\n\n`Width` is the number of characters into which the value should be fitted. This allocated space is\npadded if value is shorter. By default it is space padded, and the flag `0` will cause padding with `0`\nfor numerical formats.\n\n`Precision` is the number of fractional digits to show for floating point, and the maximum characters\nincluded in a string format.\n\nNote that all data type supports the formats `s` and `p` with the meaning \"default string representation\" and\n\"default programmatic string representation\" (which for example means that a String is quoted in 'p' format).\n\n**Signatures of String conversion**\n\n```puppet\ntype Format = Pattern[/^%([\\s\\+\\-#0\\[\\{<\\(\\|]*)([1-9][0-9]*)?(?:\\.([0-9]+))?([a-zA-Z])/]\ntype ContainerFormat = Struct[{\n  format         => Optional[String],\n  separator      => Optional[String],\n  separator2     => Optional[String],\n  string_formats => Hash[Type, Format]\n  }]\ntype TypeMap = Hash[Type, Variant[Format, ContainerFormat]]\ntype Formats = Variant[Default, String[1], TypeMap]\n\nfunction String.new(\n  Any $value,\n  Formats $string_formats\n)\n```\n\nWhere:\n\n* `separator` is the string used to separate entries in an array, or hash (extra space should not be included at\n  the end), defaults to `\",\"`\n* `separator2` is the separator between key and value in a hash entry (space padding should be included as\n  wanted), defaults to `\" => \"`.\n* `string_formats` is a data type to format map for values contained in arrays and hashes - defaults to `{Any => \"%p\"}`. Note that\n  these nested formats are not applicable to data types that are containers; they are always formatted as per the top level\n  format specification.\n\n```puppet\n$str = String(10)      # produces '10'\n$str = String([10])    # produces '[\"10\"]'\n```\n\n```puppet\n$str = String(10, \"%#x\")    # produces '0x10'\n$str = String([10], \"%(a\")  # produces '(\"10\")'\n```\n\n```puppet\n$formats = {\n  Array => {\n    format => '%(a',\n    string_formats => { Integer => '%#x' }\n  }\n}\n$str = String([1,2,3], $formats) # produces '(0x1, 0x2, 0x3)'\n```\n\nThe given formats are merged with the default formats, and matching of values to convert against format is based on\nthe specificity of the mapped type; for example, different formats can be used for short and long arrays.\n\n**Integer to String**\n\n| Format  | Integer Formats\n| ------  | ---------------\n| d       | Decimal, negative values produces leading '-'.\n| x X     | Hexadecimal in lower or upper case. Uses ..f/..F for negative values unless + is also used. A `#` adds prefix 0x/0X.\n| o       | Octal. Uses ..0 for negative values unless `+` is also used. A `#` adds prefix 0.\n| b B     | Binary with prefix 'b' or 'B'. Uses ..1/..1 for negative values unless `+` is also used.\n| c       | Numeric value representing a Unicode value, result is a one unicode character string, quoted if alternative flag # is used\n| s       | Same as d, or d in quotes if alternative flag # is used.\n| p       | Same as d.\n| eEfgGaA | Converts integer to float and formats using the floating point rules.\n\nDefaults to `d`.\n\n**Float to String**\n\n| Format  | Float formats\n| ------  | -------------\n| f       | Floating point in non exponential notation.\n| e E     | Exponential notation with 'e' or 'E'.\n| g G     | Conditional exponential with 'e' or 'E' if exponent < -4 or >= the precision.\n| a A     | Hexadecimal exponential form, using 'x'/'X' as prefix and 'p'/'P' before exponent.\n| s       | Converted to string using format p, then applying string formatting rule, alternate form # quotes result.\n| p       | Same as f format with minimum significant number of fractional digits, prec has no effect.\n| dxXobBc | Converts float to integer and formats using the integer rules.\n\nDefaults to `p`.\n\n**String to String**\n\n| Format | String\n| ------ | ------\n| s      | Unquoted string, verbatim output of control chars.\n| p      | Programmatic representation - strings are quoted, interior quotes and control chars are escaped. Selects single or double quotes based on content, or uses double quotes if alternative flag `#` is used.\n| C      | Each `::` name segment capitalized, quoted if alternative flag `#` is used.\n| c      | Capitalized string, quoted if alternative flag `#` is used.\n| d      | Downcased string, quoted if alternative flag `#` is used.\n| u      | Upcased string, quoted if alternative flag `#` is used.\n| t      | Trims leading and trailing whitespace from the string, quoted if alternative flag `#` is used.\n\nDefaults to `s` at top level and `p` inside array or hash.\n\n**Boolean to String**\n\n| Format    | Boolean Formats\n| ----      | -------------------\n| t T       | String 'true'/'false' or 'True'/'False', first char if alternate form is used (i.e. 't'/'f' or 'T'/'F').\n| y Y       | String 'yes'/'no', 'Yes'/'No', 'y'/'n' or 'Y'/'N' if alternative flag `#` is used.\n| dxXobB    | Numeric value 0/1 in accordance with the given format which must be valid integer format.\n| eEfgGaA   | Numeric value 0.0/1.0 in accordance with the given float format and flags.\n| s         | String 'true' / 'false'.\n| p         | String 'true' / 'false'.\n\n**Regexp to String**\n\n| Format    | Regexp Formats\n| ----      | --------------\n| s         | No delimiters, quoted if alternative flag `#` is used.\n| p         | Delimiters `/ /`.\n\n**Undef to String**\n\n| Format    | Undef formats\n| ------    | -------------\n| s         | Empty string, or quoted empty string if alternative flag `#` is used.\n| p         | String 'undef', or quoted '\"undef\"' if alternative flag `#` is used.\n| n         | String 'nil', or 'null' if alternative flag `#` is used.\n| dxXobB    | String 'NaN'.\n| eEfgGaA   | String 'NaN'.\n| v         | String 'n/a'.\n| V         | String 'N/A'.\n| u         | String 'undef', or 'undefined' if alternative `#` flag is used.\n\n**Default value to String**\n\n| Format    | Default formats\n| ------    | ---------------\n| d D       | String 'default' or 'Default', alternative form `#` causes value to be quoted.\n| s         | Same as d.\n| p         | Same as d.\n\n**Binary value to String**\n\n| Format    | Default formats\n| ------    | ---------------\n| s         | binary as unquoted UTF-8 characters (errors if byte sequence is invalid UTF-8). Alternate form escapes non ascii bytes.\n| p         | 'Binary(\"<base64strict>\")'\n| b         | '<base64>' - base64 string with newlines inserted\n| B         | '<base64strict>' - base64 strict string (without newlines inserted)\n| u         | '<base64urlsafe>' - base64 urlsafe string\n| t         | 'Binary' - outputs the name of the type only\n| T         | 'BINARY' - output the name of the type in all caps only\n\n* The alternate form flag `#` will quote the binary or base64 text output.\n* The format `%#s` allows invalid UTF-8 characters and outputs all non ascii bytes\n  as hex escaped characters on the form `\\\\xHH` where `H` is a hex digit.\n* The width and precision values are applied to the text part only in `%p` format.\n\n**Array & Tuple to String**\n\n| Format    | Array/Tuple Formats\n| ------    | -------------\n| a         | Formats with `[ ]` delimiters and `,`, alternate form `#` indents nested arrays/hashes.\n| s         | Same as a.\n| p         | Same as a.\n\nSee \"Flags\" `<[({\\|` for formatting of delimiters, and \"Additional parameters for containers; Array and Hash\" for\nmore information about options.\n\nThe alternate form flag `#` will cause indentation of nested array or hash containers. If width is also set\nit is taken as the maximum allowed length of a sequence of elements (not including delimiters). If this max length\nis exceeded, each element will be indented.\n\n**Hash & Struct to String**\n\n| Format    | Hash/Struct Formats\n| ------    | -------------\n| h         | Formats with `{ }` delimiters, `,` element separator and ` => ` inner element separator unless overridden by flags.\n| s         | Same as h.\n| p         | Same as h.\n| a         | Converts the hash to an array of [k,v] tuples and formats it using array rule(s).\n\nSee \"Flags\" `<[({\\|` for formatting of delimiters, and \"Additional parameters for containers; Array and Hash\" for\nmore information about options.\n\nThe alternate form flag `#` will format each hash key/value entry indented on a separate line.\n\n**Type to String**\n\n| Format    | Array/Tuple Formats\n| ------    | -------------\n| s         | The same as `p`, quoted if alternative flag `#` is used.\n| p         | Outputs the type in string form as specified by the Puppet Language.\n\n**Flags**\n\n| Flag     | Effect\n| ------   | ------\n| (space)  | A space instead of `+` for numeric output (`-` is shown), for containers skips delimiters.\n| #        | Alternate format; prefix 0x/0x, 0 (octal) and 0b/0B for binary, Floats force decimal '.'. For g/G keep trailing 0.\n| +        | Show sign +/- depending on value's sign, changes x, X, o, b, B format to not use 2's complement form.\n| -        | Left justify the value in the given width.\n| 0        | Pad with 0 instead of space for widths larger than value.\n| <[({\\|   | Defines an enclosing pair <> [] () {} or \\| \\| when used with a container type.\n\n### Conversion to Boolean\n\nAccepts a single value as argument:\n\n* Float 0.0 is `false`, all other float values are `true`\n* Integer 0 is `false`, all other integer values are `true`\n* Strings\n  * `true` if 'true', 'yes', 'y' (case independent compare)\n  * `false` if 'false', 'no', 'n' (case independent compare)\n* Boolean is already boolean and is simply returned\n\n### Conversion to Array and Tuple\n\nWhen given a single value as argument:\n\n* A non empty `Hash` is converted to an array matching `Array[Tuple[Any,Any], 1]`.\n* An empty `Hash` becomes an empty array.\n* An `Array` is simply returned.\n* An `Iterable[T]` is turned into an array of `T` instances.\n* A `Binary` is converted to an `Array[Integer[0,255]]` of byte values\n\nWhen given a second Boolean argument:\n\n* if `true`, a value that is not already an array is returned as a one element array.\n* if `false`, (the default), converts the first argument as shown above.\n\n```puppet\n$arr = Array($value, true)\n```\n\nConversion to a `Tuple` works exactly as conversion to an `Array`, only that the constructed array is\nasserted against the given tuple type.\n\n### Conversion to Hash and Struct\n\nAccepts a single value as argument:\n\n* An empty `Array` becomes an empty `Hash`\n* An `Array` matching `Array[Tuple[Any,Any], 1]` is converted to a hash where each tuple describes a key/value entry\n* An `Array` with an even number of entries is interpreted as `[key1, val1, key2, val2, ...]`\n* An `Iterable` is turned into an `Array` and then converted to hash as per the array rules\n* A `Hash` is simply returned\n\nAlternatively, a tree can be constructed by giving two values; an array of tuples on the form `[path, value]`\n(where the `path` is the path from the root of a tree, and `value` the value at that position in the tree), and\neither the option `'tree'` (do not convert arrays to hashes except the top level), or\n`'hash_tree'` (convert all arrays to hashes).\n\nThe tree/hash_tree forms of Hash creation are suited for transforming the result of an iteration\nusing `tree_each` and subsequent filtering or mapping.\n\nMapping an arbitrary structure in a way that keeps the structure, but where some values are replaced\ncan be done by using the `tree_each` function, mapping, and then constructing a new Hash from the result:\n\n```puppet\n# A hash tree with 'water' at different locations\n$h = { a => { b => { x => 'water'}}, b => { y => 'water'} }\n# a helper function that turns water into wine\nfunction make_wine($x) { if $x == 'water' { 'wine' } else { $x } }\n# create a flattened tree with water turned into wine\n$flat_tree = $h.tree_each.map |$entry| { [$entry[0], make_wine($entry[1])] }\n# create a new Hash and log it\nnotice Hash($flat_tree, 'hash_tree')\n```\n\nWould notice the hash `{a => {b => {x => wine}}, b => {y => wine}}`\n\nConversion to a `Struct` works exactly as conversion to a `Hash`, only that the constructed hash is\nasserted against the given struct type.\n\n### Conversion to a Regexp\n\nA `String` can be converted into a `Regexp`\n\n**Example**: Converting a String into a Regexp\n```puppet\n$s = '[a-z]+\\.com'\n$r = Regexp($s)\nif('foo.com' =~ $r) {\n  ...\n}\n```\n\n### Creating a SemVer\n\nA SemVer object represents a single [Semantic Version](http://semver.org/).\nIt can be created from a String, individual values for its parts, or a hash specifying the value per part.\nSee the specification at [semver.org](http://semver.org/) for the meaning of the SemVer's parts.\n\nThe signatures are:\n\n```puppet\ntype PositiveInteger = Integer[0,default]\ntype SemVerQualifier = Pattern[/\\A(?<part>[0-9A-Za-z-]+)(?:\\.\\g<part>)*\\Z/]\ntype SemVerString = String[1]\ntype SemVerHash =Struct[{\n  major                => PositiveInteger,\n  minor                => PositiveInteger,\n  patch                => PositiveInteger,\n  Optional[prerelease] => SemVerQualifier,\n  Optional[build]      => SemVerQualifier\n}]\n\nfunction SemVer.new(SemVerString $str)\n\nfunction SemVer.new(\n        PositiveInteger           $major\n        PositiveInteger           $minor\n        PositiveInteger           $patch\n        Optional[SemVerQualifier] $prerelease = undef\n        Optional[SemVerQualifier] $build = undef\n        )\n\nfunction SemVer.new(SemVerHash $hash_args)\n```\n\n```puppet\n# As a type, SemVer can describe disjunct ranges which versions can be\n# matched against - here the type is constructed with two\n# SemVerRange objects.\n#\n$t = SemVer[\n  SemVerRange('>=1.0.0 <2.0.0'),\n  SemVerRange('>=3.0.0 <4.0.0')\n]\nnotice(SemVer('1.2.3') =~ $t) # true\nnotice(SemVer('2.3.4') =~ $t) # false\nnotice(SemVer('3.4.5') =~ $t) # true\n```\n\n### Creating a SemVerRange\n\nA `SemVerRange` object represents a range of `SemVer`. It can be created from\na `String`, or from two `SemVer` instances, where either end can be given as\na literal `default` to indicate infinity. The string format of a `SemVerRange` is specified by\nthe [Semantic Version Range Grammar](https://github.com/npm/node-semver#ranges).\n\n> Use of the comparator sets described in the grammar (joining with `||`) is not supported.\n\nThe signatures are:\n\n```puppet\ntype SemVerRangeString = String[1]\ntype SemVerRangeHash = Struct[{\n  min                   => Variant[Default, SemVer],\n  Optional[max]         => Variant[Default, SemVer],\n  Optional[exclude_max] => Boolean\n}]\n\nfunction SemVerRange.new(\n  SemVerRangeString $semver_range_string\n)\n\nfunction SemVerRange.new(\n  Variant[Default,SemVer] $min\n  Variant[Default,SemVer] $max\n  Optional[Boolean]       $exclude_max = undef\n)\n\nfunction SemVerRange.new(\n  SemVerRangeHash $semver_range_hash\n)\n```\n\nFor examples of `SemVerRange` use see \"Creating a SemVer\"\n\n### Creating a Binary\n\nA `Binary` object represents a sequence of bytes and it can be created from a String in Base64 format,\nan Array containing byte values. A Binary can also be created from a Hash containing the value to convert to\na `Binary`.\n\nThe signatures are:\n\n```puppet\ntype ByteInteger = Integer[0,255]\ntype Base64Format = Enum[\"%b\", \"%u\", \"%B\", \"%s\"]\ntype StringHash = Struct[{value => String, \"format\" => Optional[Base64Format]}]\ntype ArrayHash = Struct[{value => Array[ByteInteger]}]\ntype BinaryArgsHash = Variant[StringHash, ArrayHash]\n\nfunction Binary.new(\n  String $base64_str,\n  Optional[Base64Format] $format\n)\n\n\nfunction Binary.new(\n  Array[ByteInteger] $byte_array\n}\n\n# Same as for String, or for Array, but where arguments are given in a Hash.\nfunction Binary.new(BinaryArgsHash $hash_args)\n```\n\nThe formats have the following meaning:\n\n| format | explanation |\n| ----   | ----        |\n| B | The data is in base64 strict encoding\n| u | The data is in URL safe base64 encoding\n| b | The data is in base64 encoding, padding as required by base64 strict, is added by default\n| s | The data is a puppet string. The string must be valid UTF-8, or convertible to UTF-8 or an error is raised.\n| r | (Ruby Raw) the byte sequence in the given string is used verbatim irrespective of possible encoding errors\n\n* The default format is `%B`.\n* Note that the format `%r` should be used sparingly, or not at all. It exists for backwards compatibility reasons when someone receiving\n  a string from some function and that string should be treated as Binary. Such code should be changed to return a Binary instead of a String.\n\n```puppet\n# create the binary content \"abc\"\n$a = Binary('YWJj')\n\n# create the binary content from content in a module's file\n$b = binary_file('mymodule/mypicture.jpg')\n```\n\n* Since 4.5.0\n* Binary type since 4.8.0\n\n### Creating an instance of a `Type` using the `Init` type\n\nThe type `Init[T]` describes a value that can be used when instantiating a type. When used as the first argument in a call to `new`, it\nwill dispatch the call to its contained type and optionally augment the parameter list with additional arguments.\n\n```puppet\n# The following declaration\n$x = Init[Integer].new('128')\n# is exactly the same as\n$x = Integer.new('128')\n```\n\nor, with base 16 and using implicit new\n\n```puppet\n# The following declaration\n$x = Init[Integer,16]('80')\n# is exactly the same as\n$x = Integer('80', 16)\n```\n\n```puppet\n$fmt = Init[String,'%#x']\nnotice($fmt(256)) # will notice '0x100'\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"`new` and calling type directly are equivalent"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"arguments by position or by name"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"data type constraints are checked"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Converting to Integer in multiple ways"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Converting to Numeric in different ways"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Creating a type from a string"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Positive Integers in Hexadecimal prefixed with '0x', negative in Decimal"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Simple Conversion to String (using defaults)"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Simple Conversion to String specifying the format for the given value directly"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Specifying type for values contained in an array"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Ensuring value is an array"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Mapping a hash tree"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"SemVer and SemVerRange usage"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Creating a Binary"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Creating an instance of Integer using Init[Integer]"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Creating an instance of String using a predefined format"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Type"
            ],
            "name"=>"type"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Any"
            ],
            "name"=>"*args"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Callable]"
            ],
            "name"=>"&block"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.5.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:new, Puppet::Functions::InternalFunction) do\n\n  dispatch :new_instance do\n    scope_param\n    param          'Type', :type\n    repeated_param 'Any',  :args\n    optional_block_param\n  end\n\n  def new_instance(scope, t, *args)\n    return args[0] if args.size == 1 && !t.is_a?(Puppet::Pops::Types::PInitType) && t.instance?(args[0])\n    result = assert_type(t, new_function_for_type(t).call(scope, *args))\n    return block_given? ? yield(result) : result\n  end\n\n  def new_function_for_type(t)\n    @new_function_cache ||= {}\n\n    unless @new_function_cache.key?(t)\n      @new_function_cache[t] = t.new_function.new(nil, loader)\n    end\n\n    @new_function_cache[t]\n  end\n\n  def assert_type(type, value)\n    Puppet::Pops::Types::TypeAsserter.assert_instance_of(['Converted value from %s.new()', type], type, value)\n  end\nend"
    },
    {
      "name"=>"new",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/new.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"new()",
          "docstring"=>{
            "text"=>"Creates a new instance/object of a given data type.\n\nThis function makes it possible to create new instances of\nconcrete data types. If a block is given it is called with the\njust created instance as an argument.\n\nCalling this function is equivalent to directly\ncalling the data type:\n\n**Example:** `new` and calling type directly are equivalent\n\n```puppet\n$a = Integer.new(\"42\")\n$b = Integer(\"42\")\n```\n\nThese would both convert the string `\"42\"` to the decimal value `42`.\n\n**Example:** arguments by position or by name\n\n```puppet\n$a = Integer.new(\"42\", 8)\n$b = Integer({from => \"42\", radix => 8})\n```\n\nThis would convert the octal (radix 8) number `\"42\"` in string form\nto the decimal value `34`.\n\nThe new function supports two ways of giving the arguments:\n\n* by name (using a hash with property to value mapping)\n* by position (as regular arguments)\n\nNote that it is not possible to create new instances of\nsome abstract data types (for example `Variant`). The data type `Optional[T]` is an\nexception as it will create an instance of `T` or `undef` if the\nvalue to convert is `undef`.\n\nThe arguments that can be given is determined by the data type.\n\n> An assertion is always made that the produced value complies with the given type constraints.\n\n**Example:** data type constraints are checked\n\n```puppet\nInteger[0].new(\"-100\")\n```\n\nWould fail with an assertion error (since value is less than 0).\n\nThe following sections show the arguments and conversion rules\nper data type built into the Puppet Type System.\n\n### Conversion to Optional[T] and NotUndef[T]\n\nConversion to these data types is the same as a conversion to the type argument `T`.\nIn the case of `Optional[T]` it is accepted that the argument to convert may be `undef`.\nIt is however not acceptable to give other arguments (than `undef`) that cannot be\nconverted to `T`.\n\n### Conversion to Integer\n\nA new `Integer` can be created from `Integer`, `Float`, `Boolean`, and `String` values.\nFor conversion from `String` it is possible to specify the radix (base).\n\n```puppet\ntype Radix = Variant[Default, Integer[2,2], Integer[8,8], Integer[10,10], Integer[16,16]]\n\nfunction Integer.new(\n  String $value,\n  Radix $radix = 10,\n  Boolean $abs = false\n)\n\nfunction Integer.new(\n  Variant[Numeric, Boolean] $value,\n  Boolean $abs = false\n)\n```\n\n* When converting from `String` the default radix is 10.\n* If radix is not specified an attempt is made to detect the radix from the start of the string:\n  * `0b` or `0B` is taken as radix 2.\n  * `0x` or `0X` is taken as radix 16.\n  * `0` as radix 8.\n  * All others are decimal.\n* Conversion from `String` accepts an optional sign in the string.\n* For hexadecimal (radix 16) conversion an optional leading \"0x\", or \"0X\" is accepted.\n* For octal (radix 8) an optional leading \"0\" is accepted.\n* For binary (radix 2) an optional leading \"0b\" or \"0B\" is accepted.\n* When `radix` is set to `default`, the conversion is based on the leading.\n  characters in the string. A leading \"0\" for radix 8, a leading \"0x\", or \"0X\" for\n  radix 16, and leading \"0b\" or \"0B\" for binary.\n* Conversion from `Boolean` results in 0 for `false` and 1 for `true`.\n* Conversion from `Integer`, `Float`, and `Boolean` ignores the radix.\n* `Float` value fractions are truncated (no rounding).\n* When `abs` is set to `true`, the result will be an absolute integer.\n\nExamples - Converting to Integer:\n\n```puppet\n$a_number = Integer(\"0xFF\", 16)    # results in 255\n$a_number = Integer(\"010\")         # results in 8\n$a_number = Integer(\"010\", 10)     # results in 10\n$a_number = Integer(true)          # results in 1\n$a_number = Integer(-38, 10, true) # results in 38\n```\n\n### Conversion to Float\n\nA new `Float` can be created from `Integer`, `Float`, `Boolean`, and `String` values.\nFor conversion from `String` both float and integer formats are supported.\n\n```puppet\nfunction Float.new(\n  Variant[Numeric, Boolean, String] $value,\n  Boolean $abs = true\n)\n```\n\n* For an integer, the floating point fraction of `.0` is added to the value.\n* A `Boolean` `true` is converted to 1.0, and a `false` to 0.0\n* In `String` format, integer prefixes for hex and binary are understood (but not octal since\n  floating point in string format may start with a '0').\n* When `abs` is set to `true`, the result will be an absolute floating point value.\n\n### Conversion to Numeric\n\nA new `Integer` or `Float` can be created from `Integer`, `Float`, `Boolean` and\n`String` values.\n\n```puppet\nfunction Numeric.new(\n  Variant[Numeric, Boolean, String] $value,\n  Boolean $abs = true\n)\n```\n\n* If the value has a decimal period, or if given in scientific notation\n  (e/E), the result is a `Float`, otherwise the value is an `Integer`. The\n  conversion from `String` always uses a radix based on the prefix of the string.\n* Conversion from `Boolean` results in 0 for `false` and 1 for `true`.\n* When `abs` is set to `true`, the result will be an absolute `Float`or `Integer` value.\n\nExamples - Converting to Numeric\n\n```puppet\n$a_number = Numeric(true)        # results in 1\n$a_number = Numeric(\"0xFF\")      # results in 255\n$a_number = Numeric(\"010\")       # results in 8\n$a_number = Numeric(\"3.14\")      # results in 3.14 (a float)\n$a_number = Numeric(-42.3, true) # results in 42.3\n$a_number = Numeric(-42, true)   # results in 42\n```\n\n### Conversion to Timespan\n\nA new `Timespan` can be created from `Integer`, `Float`, `String`, and `Hash` values. Several variants of the constructor are provided.\n\n#### Timespan from seconds\n\nWhen a Float is used, the decimal part represents fractions of a second.\n\n```puppet\nfunction Timespan.new(\n  Variant[Float, Integer] $value\n)\n```\n\n#### Timespan from days, hours, minutes, seconds, and fractions of a second\n\nThe arguments can be passed separately in which case the first four, days, hours, minutes, and seconds are mandatory and the rest are optional.\nAll values may overflow and/or be negative. The internal 128-bit nano-second integer is calculated as:\n\n```\n(((((days * 24 + hours) * 60 + minutes) * 60 + seconds) * 1000 + milliseconds) * 1000 + microseconds) * 1000 + nanoseconds\n```\n\n```puppet\nfunction Timespan.new(\n  Integer $days, Integer $hours, Integer $minutes, Integer $seconds,\n  Integer $milliseconds = 0, Integer $microseconds = 0, Integer $nanoseconds = 0\n)\n```\n\nor, all arguments can be passed as a `Hash`, in which case all entries are optional:\n\n```puppet\nfunction Timespan.new(\n  Struct[{\n    Optional[negative] => Boolean,\n    Optional[days] => Integer,\n    Optional[hours] => Integer,\n    Optional[minutes] => Integer,\n    Optional[seconds] => Integer,\n    Optional[milliseconds] => Integer,\n    Optional[microseconds] => Integer,\n    Optional[nanoseconds] => Integer\n  }] $hash\n)\n```\n\n#### Timespan from String and format directive patterns\n\nThe first argument is parsed using the format optionally passed as a string or array of strings. When an array is used, an attempt\nwill be made to parse the string using the first entry and then with each entry in succession until parsing succeeds. If the second\nargument is omitted, an array of default formats will be used.\n\nAn exception is raised when no format was able to parse the given string.\n\n```puppet\nfunction Timespan.new(\n  String $string, Variant[String[2],Array[String[2], 1]] $format = <default format>)\n)\n```\n\nthe arguments may also be passed as a `Hash`:\n\n```puppet\nfunction Timespan.new(\n  Struct[{\n    string => String[1],\n    Optional[format] => Variant[String[2],Array[String[2], 1]]\n  }] $hash\n)\n```\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n```\n%[Flags][Width]Conversion\n```\n\n##### Flags:\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n\n##### Format directives:\n\n| Format | Meaning |\n| ------ | ------- |\n| D | Number of Days |\n| H | Hour of the day, 24-hour clock |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..59) |\n| L | Millisecond of the second (000..999) |\n| N | Fractional seconds digits |\n\nThe format directive that represents the highest magnitude in the format will be allowed to\noverflow. I.e. if no \"%D\" is used but a \"%H\" is present, then the hours may be more than 23.\n\nThe default array contains the following patterns:\n\n```\n['%D-%H:%M:%S', '%D-%H:%M', '%H:%M:%S', '%H:%M']\n```\n\nExamples - Converting to Timespan\n\n```puppet\n$duration = Timespan(13.5)       # 13 seconds and 500 milliseconds\n$duration = Timespan({days=>4})  # 4 days\n$duration = Timespan(4, 0, 0, 2) # 4 days and 2 seconds\n$duration = Timespan('13:20')    # 13 hours and 20 minutes (using default pattern)\n$duration = Timespan('10:03.5', '%M:%S.%L') # 10 minutes, 3 seconds, and 5 milli-seconds\n$duration = Timespan('10:03.5', '%M:%S.%N') # 10 minutes, 3 seconds, and 5 nano-seconds\n```\n\n### Conversion to Timestamp\n\nA new `Timestamp` can be created from `Integer`, `Float`, `String`, and `Hash` values. Several variants of the constructor are provided.\n\n#### Timestamp from seconds since epoch (1970-01-01 00:00:00 UTC)\n\nWhen a Float is used, the decimal part represents fractions of a second.\n\n```puppet\nfunction Timestamp.new(\n  Variant[Float, Integer] $value\n)\n```\n\n#### Timestamp from String and patterns consisting of format directives\n\nThe first argument is parsed using the format optionally passed as a string or array of strings. When an array is used, an attempt\nwill be made to parse the string using the first entry and then with each entry in succession until parsing succeeds. If the second\nargument is omitted, an array of default formats will be used.\n\nA third optional timezone argument can be provided. The first argument will then be parsed as if it represents a local time in that\ntimezone. The timezone can be any timezone that is recognized when using the '%z' or '%Z' formats, or the word 'current', in which\ncase the current timezone of the evaluating process will be used. The timezone argument is case insensitive.\n\nThe default timezone, when no argument is provided, or when using the keyword `default`, is 'UTC'.\n\nIt is illegal to provide a timezone argument other than `default` in combination with a format that contains '%z' or '%Z' since that\nwould introduce an ambiguity as to which timezone to use. The one extracted from the string, or the one provided as an argument.\n\nAn exception is raised when no format was able to parse the given string.\n\n```puppet\nfunction Timestamp.new(\n  String $string,\n  Variant[String[2],Array[String[2], 1]] $format = <default format>,\n  String $timezone = default)\n)\n```\n\nthe arguments may also be passed as a `Hash`:\n\n```puppet\nfunction Timestamp.new(\n  Struct[{\n    string => String[1],\n    Optional[format] => Variant[String[2],Array[String[2], 1]],\n    Optional[timezone] => String[1]\n  }] $hash\n)\n```\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n```\n%[Flags][Width]Conversion\n```\n\n##### Flags:\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n| #     | Change names to upper-case or change case of am/pm\n| ^     | Use uppercase\n| :     | Use colons for %z\n\n##### Format directives (names and padding can be altered using flags):\n\n**Date (Year, Month, Day):**\n\n| Format | Meaning |\n| ------ | ------- |\n| Y | Year with century, zero-padded to at least 4 digits |\n| C | year / 100 (rounded down such as 20 in 2009) |\n| y | year % 100 (00..99) |\n| m | Month of the year, zero-padded (01..12) |\n| B | The full month name (\"January\") |\n| b | The abbreviated month name (\"Jan\") |\n| h | Equivalent to %b |\n| d | Day of the month, zero-padded (01..31) |\n| e | Day of the month, blank-padded ( 1..31) |\n| j | Day of the year (001..366) |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| H | Hour of the day, 24-hour clock, zero-padded (00..23) |\n| k | Hour of the day, 24-hour clock, blank-padded ( 0..23) |\n| I | Hour of the day, 12-hour clock, zero-padded (01..12) |\n| l | Hour of the day, 12-hour clock, blank-padded ( 1..12) |\n| P | Meridian indicator, lowercase (\"am\" or \"pm\") |\n| p | Meridian indicator, uppercase (\"AM\" or \"PM\") |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..60) |\n| L | Millisecond of the second (000..999). Digits under millisecond are truncated to not produce 1000 |\n| N | Fractional seconds digits, default is 9 digits (nanosecond). Digits under a specified width are truncated to avoid carry up |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| z   | Time zone as hour and minute offset from UTC (e.g. +0900) |\n| :z  | hour and minute offset from UTC with a colon (e.g. +09:00) |\n| ::z | hour, minute and second offset from UTC (e.g. +09:00:00) |\n| Z   | Abbreviated time zone name or similar information.  (OS dependent) |\n\n**Weekday:**\n\n| Format | Meaning |\n| ------ | ------- |\n| A | The full weekday name (\"Sunday\") |\n| a | The abbreviated name (\"Sun\") |\n| u | Day of the week (Monday is 1, 1..7) |\n| w | Day of the week (Sunday is 0, 0..6) |\n\n**ISO 8601 week-based year and week number:**\n\nThe first week of YYYY starts with a Monday and includes YYYY-01-04.\nThe days in the year before the first week are in the last week of\nthe previous year.\n\n| Format | Meaning |\n| ------ | ------- |\n| G | The week-based year |\n| g | The last 2 digits of the week-based year (00..99) |\n| V | Week number of the week-based year (01..53) |\n\n**Week number:**\n\nThe first week of YYYY that starts with a Sunday or Monday (according to %U\nor %W). The days in the year before the first week are in week 0.\n\n| Format | Meaning |\n| ------ | ------- |\n| U | Week number of the year. The week starts with Sunday. (00..53) |\n| W | Week number of the year. The week starts with Monday. (00..53) |\n\n**Seconds since the Epoch:**\n\n| Format | Meaning |\n| s | Number of seconds since 1970-01-01 00:00:00 UTC. |\n\n**Literal string:**\n\n| Format | Meaning |\n| ------ | ------- |\n| n | Newline character (\\n) |\n| t | Tab character (\\t) |\n| % | Literal \"%\" character |\n\n**Combination:**\n\n| Format | Meaning |\n| ------ | ------- |\n| c | date and time (%a %b %e %T %Y) |\n| D | Date (%m/%d/%y) |\n| F | The ISO 8601 date format (%Y-%m-%d) |\n| v | VMS date (%e-%^b-%4Y) |\n| x | Same as %D |\n| X | Same as %T |\n| r | 12-hour time (%I:%M:%S %p) |\n| R | 24-hour time (%H:%M) |\n| T | 24-hour time (%H:%M:%S) |\n\nThe default array contains the following patterns:\n\nWhen a timezone argument (other than `default`) is explicitly provided:\n\n```\n['%FT%T.L', '%FT%T', '%F']\n```\n\notherwise:\n\n```\n['%FT%T.%L %Z', '%FT%T %Z', '%F %Z', '%FT%T.L', '%FT%T', '%F']\n```\n\nExamples - Converting to Timestamp\n\n```puppet\n$ts = Timestamp(1473150899)                              # 2016-09-06 08:34:59 UTC\n$ts = Timestamp({string=>'2015', format=>'%Y'})          # 2015-01-01 00:00:00.000 UTC\n$ts = Timestamp('Wed Aug 24 12:13:14 2016', '%c')        # 2016-08-24 12:13:14 UTC\n$ts = Timestamp('Wed Aug 24 12:13:14 2016 PDT', '%c %Z') # 2016-08-24 19:13:14.000 UTC\n$ts = Timestamp('2016-08-24 12:13:14', '%F %T', 'PST')   # 2016-08-24 20:13:14.000 UTC\n$ts = Timestamp('2016-08-24T12:13:14', default, 'PST')   # 2016-08-24 20:13:14.000 UTC\n\n```\n\n### Conversion to Type\n\nA new `Type` can be create from its `String` representation.\n\n**Example:** Creating a type from a string\n\n```puppet\n$t = Type.new('Integer[10]')\n```\n\n### Conversion to String\n\nConversion to `String` is the most comprehensive conversion as there are many\nuse cases where a string representation is wanted. The defaults for the many options\nhave been chosen with care to be the most basic \"value in textual form\" representation.\nThe more advanced forms of formatting are intended to enable writing special purposes formatting\nfunctions in the Puppet language.\n\nA new string can be created from all other data types. The process is performed in\nseveral steps - first the data type of the given value is inferred, then the resulting data type\nis used to find the most significant format specified for that data type. And finally,\nthe found format is used to convert the given value.\n\nThe mapping from data type to format is referred to as the *format map*. This map\nallows different formatting depending on type.\n\n**Example:** Positive Integers in Hexadecimal prefixed with '0x', negative in Decimal\n\n```puppet\n$format_map = {\n  Integer[default, 0] => \"%d\",\n  Integer[1, default] => \"%#x\"\n}\nString(\"-1\", $format_map)  # produces '-1'\nString(\"10\", $format_map)  # produces '0xa'\n```\n\nA format is specified on the form:\n\n```\n%[Flags][Width][.Precision]Format\n```\n\n`Width` is the number of characters into which the value should be fitted. This allocated space is\npadded if value is shorter. By default it is space padded, and the flag `0` will cause padding with `0`\nfor numerical formats.\n\n`Precision` is the number of fractional digits to show for floating point, and the maximum characters\nincluded in a string format.\n\nNote that all data type supports the formats `s` and `p` with the meaning \"default string representation\" and\n\"default programmatic string representation\" (which for example means that a String is quoted in 'p' format).\n\n#### Signatures of String conversion\n\n```puppet\ntype Format = Pattern[/^%([\\s\\+\\-#0\\[\\{<\\(\\|]*)([1-9][0-9]*)?(?:\\.([0-9]+))?([a-zA-Z])/]\ntype ContainerFormat = Struct[{\n  format         => Optional[String],\n  separator      => Optional[String],\n  separator2     => Optional[String],\n  string_formats => Hash[Type, Format]\n  }]\ntype TypeMap = Hash[Type, Variant[Format, ContainerFormat]]\ntype Formats = Variant[Default, String[1], TypeMap]\n\nfunction String.new(\n  Any $value,\n  Formats $string_formats\n)\n```\n\nWhere:\n\n* `separator` is the string used to separate entries in an array, or hash (extra space should not be included at\n  the end), defaults to `\",\"`\n* `separator2` is the separator between key and value in a hash entry (space padding should be included as\n  wanted), defaults to `\" => \"`.\n* `string_formats` is a data type to format map for values contained in arrays and hashes - defaults to `{Any => \"%p\"}`. Note that\n  these nested formats are not applicable to data types that are containers; they are always formatted as per the top level\n  format specification.\n\n**Example:** Simple Conversion to String (using defaults)\n\n```puppet\n$str = String(10)      # produces '10'\n$str = String([10])    # produces '[\"10\"]'\n```\n\n**Example:** Simple Conversion to String specifying the format for the given value directly\n\n```puppet\n$str = String(10, \"%#x\")    # produces '0x10'\n$str = String([10], \"%(a\")  # produces '(\"10\")'\n```\n\n**Example:** Specifying type for values contained in an array\n\n```puppet\n$formats = {\n  Array => {\n    format => '%(a',\n    string_formats => { Integer => '%#x' }\n  }\n}\n$str = String([1,2,3], $formats) # produces '(0x1, 0x2, 0x3)'\n```\n\nThe given formats are merged with the default formats, and matching of values to convert against format is based on\nthe specificity of the mapped type; for example, different formats can be used for short and long arrays.\n\n#### Integer to String\n\n| Format  | Integer Formats\n| ------  | ---------------\n| d       | Decimal, negative values produces leading '-'.\n| x X     | Hexadecimal in lower or upper case. Uses ..f/..F for negative values unless + is also used. A `#` adds prefix 0x/0X.\n| o       | Octal. Uses ..0 for negative values unless `+` is also used. A `#` adds prefix 0.\n| b B     | Binary with prefix 'b' or 'B'. Uses ..1/..1 for negative values unless `+` is also used.\n| c       | Numeric value representing a Unicode value, result is a one unicode character string, quoted if alternative flag # is used\n| s       | Same as d, or d in quotes if alternative flag # is used.\n| p       | Same as d.\n| eEfgGaA | Converts integer to float and formats using the floating point rules.\n\nDefaults to `d`.\n\n#### Float to String\n\n| Format  | Float formats\n| ------  | -------------\n| f       | Floating point in non exponential notation.\n| e E     | Exponential notation with 'e' or 'E'.\n| g G     | Conditional exponential with 'e' or 'E' if exponent < -4 or >= the precision.\n| a A     | Hexadecimal exponential form, using 'x'/'X' as prefix and 'p'/'P' before exponent.\n| s       | Converted to string using format p, then applying string formatting rule, alternate form # quotes result.\n| p       | Same as f format with minimum significant number of fractional digits, prec has no effect.\n| dxXobBc | Converts float to integer and formats using the integer rules.\n\nDefaults to `p`.\n\n#### String to String\n\n| Format | String\n| ------ | ------\n| s      | Unquoted string, verbatim output of control chars.\n| p      | Programmatic representation - strings are quoted, interior quotes and control chars are escaped.\n| C      | Each `::` name segment capitalized, quoted if alternative flag `#` is used.\n| c      | Capitalized string, quoted if alternative flag `#` is used.\n| d      | Downcased string, quoted if alternative flag `#` is used.\n| u      | Upcased string, quoted if alternative flag `#` is used.\n| t      | Trims leading and trailing whitespace from the string, quoted if alternative flag `#` is used.\n\nDefaults to `s` at top level and `p` inside array or hash.\n\n#### Boolean to String\n\n| Format    | Boolean Formats\n| ----      | -------------------\n| t T       | String 'true'/'false' or 'True'/'False', first char if alternate form is used (i.e. 't'/'f' or 'T'/'F').\n| y Y       | String 'yes'/'no', 'Yes'/'No', 'y'/'n' or 'Y'/'N' if alternative flag `#` is used.\n| dxXobB    | Numeric value 0/1 in accordance with the given format which must be valid integer format.\n| eEfgGaA   | Numeric value 0.0/1.0 in accordance with the given float format and flags.\n| s         | String 'true' / 'false'.\n| p         | String 'true' / 'false'.\n\n#### Regexp to String\n\n| Format    | Regexp Formats\n| ----      | --------------\n| s         | No delimiters, quoted if alternative flag `#` is used.\n| p         | Delimiters `/ /`.\n\n#### Undef to String\n\n| Format    | Undef formats\n| ------    | -------------\n| s         | Empty string, or quoted empty string if alternative flag `#` is used.\n| p         | String 'undef', or quoted '\"undef\"' if alternative flag `#` is used.\n| n         | String 'nil', or 'null' if alternative flag `#` is used.\n| dxXobB    | String 'NaN'.\n| eEfgGaA   | String 'NaN'.\n| v         | String 'n/a'.\n| V         | String 'N/A'.\n| u         | String 'undef', or 'undefined' if alternative `#` flag is used.\n\n#### Default value to String\n\n| Format    | Default formats\n| ------    | ---------------\n| d D       | String 'default' or 'Default', alternative form `#` causes value to be quoted.\n| s         | Same as d.\n| p         | Same as d.\n\n#### Binary value to String\n\n| Format    | Default formats\n| ------    | ---------------\n| s         | binary as unquoted UTF-8 characters (errors if byte sequence is invalid UTF-8). Alternate form escapes non ascii bytes.\n| p         | 'Binary(\"<base64strict>\")'\n| b         | '<base64>' - base64 string with newlines inserted\n| B         | '<base64strict>' - base64 strict string (without newlines inserted)\n| u         | '<base64urlsafe>' - base64 urlsafe string\n| t         | 'Binary' - outputs the name of the type only\n| T         | 'BINARY' - output the name of the type in all caps only\n\n* The alternate form flag `#` will quote the binary or base64 text output.\n* The format `%#s` allows invalid UTF-8 characters and outputs all non ascii bytes\n  as hex escaped characters on the form `\\\\xHH` where `H` is a hex digit.\n* The width and precision values are applied to the text part only in `%p` format.\n\n#### Array & Tuple to String\n\n| Format    | Array/Tuple Formats\n| ------    | -------------\n| a         | Formats with `[ ]` delimiters and `,`, alternate form `#` indents nested arrays/hashes.\n| s         | Same as a.\n| p         | Same as a.\n\nSee \"Flags\" `<[({\\|` for formatting of delimiters, and \"Additional parameters for containers; Array and Hash\" for\nmore information about options.\n\nThe alternate form flag `#` will cause indentation of nested array or hash containers. If width is also set\nit is taken as the maximum allowed length of a sequence of elements (not including delimiters). If this max length\nis exceeded, each element will be indented.\n\n#### Hash & Struct to String\n\n| Format    | Hash/Struct Formats\n| ------    | -------------\n| h         | Formats with `{ }` delimiters, `,` element separator and ` => ` inner element separator unless overridden by flags.\n| s         | Same as h.\n| p         | Same as h.\n| a         | Converts the hash to an array of [k,v] tuples and formats it using array rule(s).\n\nSee \"Flags\" `<[({\\|` for formatting of delimiters, and \"Additional parameters for containers; Array and Hash\" for\nmore information about options.\n\nThe alternate form flag `#` will format each hash key/value entry indented on a separate line.\n\n#### Type to String\n\n| Format    | Array/Tuple Formats\n| ------    | -------------\n| s         | The same as `p`, quoted if alternative flag `#` is used.\n| p         | Outputs the type in string form as specified by the Puppet Language.\n\n#### Flags\n\n| Flag     | Effect\n| ------   | ------\n| (space)  | A space instead of `+` for numeric output (`-` is shown), for containers skips delimiters.\n| #        | Alternate format; prefix 0x/0x, 0 (octal) and 0b/0B for binary, Floats force decimal '.'. For g/G keep trailing 0.\n| +        | Show sign +/- depending on value's sign, changes x, X, o, b, B format to not use 2's complement form.\n| -        | Left justify the value in the given width.\n| 0        | Pad with 0 instead of space for widths larger than value.\n| <[({\\|   | Defines an enclosing pair <> [] () {} or \\| \\| when used with a container type.\n\n### Conversion to Boolean\n\nAccepts a single value as argument:\n\n* Float 0.0 is `false`, all other float values are `true`\n* Integer 0 is `false`, all other integer values are `true`\n* Strings\n  * `true` if 'true', 'yes', 'y' (case independent compare)\n  * `false` if 'false', 'no', 'n' (case independent compare)\n* Boolean is already boolean and is simply returned\n\n### Conversion to Array and Tuple\n\nWhen given a single value as argument:\n\n* A non empty `Hash` is converted to an array matching `Array[Tuple[Any,Any], 1]`.\n* An empty `Hash` becomes an empty array.\n* An `Array` is simply returned.\n* An `Iterable[T]` is turned into an array of `T` instances.\n* A `Binary` is converted to an `Array[Integer[0,255]]` of byte values\n\n\nWhen given a second Boolean argument:\n\n* if `true`, a value that is not already an array is returned as a one element array.\n* if `false`, (the default), converts the first argument as shown above.\n\n**Example:** Ensuring value is an array\n\n```puppet\n$arr = Array($value, true)\n```\n\nConversion to a `Tuple` works exactly as conversion to an `Array`, only that the constructed array is\nasserted against the given tuple type.\n\n### Conversion to Hash and Struct\n\nAccepts a single value as argument:\n\n* An empty `Array` becomes an empty `Hash`\n* An `Array` matching `Array[Tuple[Any,Any], 1]` is converted to a hash where each tuple describes a key/value entry\n* An `Array` with an even number of entries is interpreted as `[key1, val1, key2, val2, ...]`\n* An `Iterable` is turned into an `Array` and then converted to hash as per the array rules\n* A `Hash` is simply returned\n\nAlternatively, a tree can be constructed by giving two values; an array of tuples on the form `[path, value]`\n(where the `path` is the path from the root of a tree, and `value` the value at that position in the tree), and\neither the option `'tree'` (do not convert arrays to hashes except the top level), or\n`'hash_tree'` (convert all arrays to hashes).\n\nThe tree/hash_tree forms of Hash creation are suited for transforming the result of an iteration\nusing `tree_each` and subsequent filtering or mapping.\n\n**Example:** Mapping a hash tree\n\nMapping an arbitrary structure in a way that keeps the structure, but where some values are replaced\ncan be done by using the `tree_each` function, mapping, and then constructing a new Hash from the result:\n\n```puppet\n# A hash tree with 'water' at different locations\n$h = { a => { b => { x => 'water'}}, b => { y => 'water'} }\n# a helper function that turns water into wine\nfunction make_wine($x) { if $x == 'water' { 'wine' } else { $x } }\n# create a flattened tree with water turned into wine\n$flat_tree = $h.tree_each.map |$entry| { [$entry[0], make_wine($entry[1])] }\n# create a new Hash and log it\nnotice Hash($flat_tree, 'hash_tree')\n```\n\nWould notice the hash `{a => {b => {x => wine}}, b => {y => wine}}`\n\nConversion to a `Struct` works exactly as conversion to a `Hash`, only that the constructed hash is\nasserted against the given struct type.\n\n### Conversion to a Regexp\n\nA `String` can be converted into a `Regexp`\n\n**Example**: Converting a String into a Regexp\n```puppet\n$s = '[a-z]+\\.com'\n$r = Regexp($s)\nif('foo.com' =~ $r) {\n  ...\n}\n```\n\n### Creating a SemVer\n\nA SemVer object represents a single [Semantic Version](http://semver.org/).\nIt can be created from a String, individual values for its parts, or a hash specifying the value per part.\nSee the specification at [semver.org](http://semver.org/) for the meaning of the SemVer's parts.\n\nThe signatures are:\n\n```puppet\ntype PositiveInteger = Integer[0,default]\ntype SemVerQualifier = Pattern[/\\A(?<part>[0-9A-Za-z-]+)(?:\\.\\g<part>)*\\Z/]\ntype SemVerString = String[1]\ntype SemVerHash =Struct[{\n  major                => PositiveInteger,\n  minor                => PositiveInteger,\n  patch                => PositiveInteger,\n  Optional[prerelease] => SemVerQualifier,\n  Optional[build]      => SemVerQualifier\n}]\n\nfunction SemVer.new(SemVerString $str)\n\nfunction SemVer.new(\n        PositiveInteger           $major\n        PositiveInteger           $minor\n        PositiveInteger           $patch\n        Optional[SemVerQualifier] $prerelease = undef\n        Optional[SemVerQualifier] $build = undef\n        )\n\nfunction SemVer.new(SemVerHash $hash_args)\n```\n\n**Examples:** SemVer and SemVerRange usage\n\n```puppet\n# As a type, SemVer can describe disjunct ranges which versions can be\n# matched against - here the type is constructed with two\n# SemVerRange objects.\n#\n$t = SemVer[\n  SemVerRange('>=1.0.0 <2.0.0'),\n  SemVerRange('>=3.0.0 <4.0.0')\n]\nnotice(SemVer('1.2.3') =~ $t) # true\nnotice(SemVer('2.3.4') =~ $t) # false\nnotice(SemVer('3.4.5') =~ $t) # true\n```\n\n### Creating a SemVerRange\n\nA `SemVerRange` object represents a range of `SemVer`. It can be created from\na `String`, or from two `SemVer` instances, where either end can be given as\na literal `default` to indicate infinity. The string format of a `SemVerRange` is specified by\nthe [Semantic Version Range Grammar](https://github.com/npm/node-semver#ranges).\n\n> Use of the comparator sets described in the grammar (joining with `||`) is not supported.\n\nThe signatures are:\n\n```puppet\ntype SemVerRangeString = String[1]\ntype SemVerRangeHash = Struct[{\n  min                   => Variant[Default, SemVer],\n  Optional[max]         => Variant[Default, SemVer],\n  Optional[exclude_max] => Boolean\n}]\n\nfunction SemVerRange.new(\n  SemVerRangeString $semver_range_string\n)\n\nfunction SemVerRange.new(\n  Variant[Default,SemVer] $min\n  Variant[Default,SemVer] $max\n  Optional[Boolean]       $exclude_max = undef\n)\n\nfunction SemVerRange.new(\n  SemVerRangeHash $semver_range_hash\n)\n```\n\nFor examples of `SemVerRange` use, see \"Creating a SemVer\".\n\n### Creating a Binary\n\nA `Binary` object represents a sequence of bytes and it can be created from a String in Base64 format,\nan Array containing byte values. A Binary can also be created from a Hash containing the value to convert to\na `Binary`.\n\nThe signatures are:\n\n```puppet\ntype ByteInteger = Integer[0,255]\ntype Base64Format = Enum[\"%b\", \"%u\", \"%B\", \"%s\"]\ntype StringHash = Struct[{value => String, \"format\" => Optional[Base64Format]}]\ntype ArrayHash = Struct[{value => Array[ByteInteger]}]\ntype BinaryArgsHash = Variant[StringHash, ArrayHash]\n\nfunction Binary.new(\n  String $base64_str,\n  Optional[Base64Format] $format\n)\n\nfunction Binary.new(\n  Array[ByteInteger] $byte_array\n}\n\n# Same as for String, or for Array, but where arguments are given in a Hash.\nfunction Binary.new(BinaryArgsHash $hash_args)\n```\n\nThe formats have the following meaning:\n\n| format | explanation |\n| ----   | ----        |\n| B | The data is in base64 strict encoding\n| u | The data is in URL safe base64 encoding\n| b | The data is in base64 encoding, padding as required by base64 strict, is added by default\n| s | The data is a puppet string. The string must be valid UTF-8, or convertible to UTF-8 or an error is raised.\n| r | (Ruby Raw) the byte sequence in the given string is used verbatim irrespective of possible encoding errors\n\n* The default format is `%B`.\n* Note that the format `%r` should be used sparingly, or not at all. It exists for backwards compatibility reasons when someone receiving\n  a string from some function and that string should be treated as Binary. Such code should be changed to return a Binary instead of a String.\n\n**Examples:** Creating a Binary\n\n```puppet\n# create the binary content \"abc\"\n$a = Binary('YWJj')\n\n# create the binary content from content in a module's file\n$b = binary_file('mymodule/mypicture.jpg')\n```\n\n* Since 4.5.0\n* Binary type since 4.8.0\n\nCreating an instance of a `Type` using the `Init` type.\n-------\n\nThe type `Init[T]` describes a value that can be used when instantiating a type. When used as the first argument in a call to `new`, it\nwill dispatch the call to its contained type and optionally augment the parameter list with additional arguments.\n\n**Example:** Creating an instance of Integer using Init[Integer]\n\n```puppet\n# The following declaration\n$x = Init[Integer].new('128')\n# is exactly the same as\n$x = Integer.new('128')\n```\n\nor, with base 16 and using implicit new\n\n```puppet\n# The following declaration\n$x = Init[Integer,16]('80')\n# is exactly the same as\n$x = Integer('80', 16)\n```\n\n**Example:** Creating an instance of String using a predefined format\n\n```puppet\n$fmt = Init[String,'%#x']\nnotice($fmt(256)) # will notice '0x100'\n```",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Creates a new instance/object of a given data type.\n\nThis function makes it possible to create new instances of\nconcrete data types. If a block is given it is called with the\njust created instance as an argument.\n\nCalling this function is equivalent to directly\ncalling the data type:\n\n**Example:** `new` and calling type directly are equivalent\n\n```puppet\n$a = Integer.new(\"42\")\n$b = Integer(\"42\")\n```\n\nThese would both convert the string `\"42\"` to the decimal value `42`.\n\n**Example:** arguments by position or by name\n\n```puppet\n$a = Integer.new(\"42\", 8)\n$b = Integer({from => \"42\", radix => 8})\n```\n\nThis would convert the octal (radix 8) number `\"42\"` in string form\nto the decimal value `34`.\n\nThe new function supports two ways of giving the arguments:\n\n* by name (using a hash with property to value mapping)\n* by position (as regular arguments)\n\nNote that it is not possible to create new instances of\nsome abstract data types (for example `Variant`). The data type `Optional[T]` is an\nexception as it will create an instance of `T` or `undef` if the\nvalue to convert is `undef`.\n\nThe arguments that can be given is determined by the data type.\n\n> An assertion is always made that the produced value complies with the given type constraints.\n\n**Example:** data type constraints are checked\n\n```puppet\nInteger[0].new(\"-100\")\n```\n\nWould fail with an assertion error (since value is less than 0).\n\nThe following sections show the arguments and conversion rules\nper data type built into the Puppet Type System.\n\n### Conversion to Optional[T] and NotUndef[T]\n\nConversion to these data types is the same as a conversion to the type argument `T`.\nIn the case of `Optional[T]` it is accepted that the argument to convert may be `undef`.\nIt is however not acceptable to give other arguments (than `undef`) that cannot be\nconverted to `T`.\n\n### Conversion to Integer\n\nA new `Integer` can be created from `Integer`, `Float`, `Boolean`, and `String` values.\nFor conversion from `String` it is possible to specify the radix (base).\n\n```puppet\ntype Radix = Variant[Default, Integer[2,2], Integer[8,8], Integer[10,10], Integer[16,16]]\n\nfunction Integer.new(\n  String $value,\n  Radix $radix = 10,\n  Boolean $abs = false\n)\n\nfunction Integer.new(\n  Variant[Numeric, Boolean] $value,\n  Boolean $abs = false\n)\n```\n\n* When converting from `String` the default radix is 10.\n* If radix is not specified an attempt is made to detect the radix from the start of the string:\n  * `0b` or `0B` is taken as radix 2.\n  * `0x` or `0X` is taken as radix 16.\n  * `0` as radix 8.\n  * All others are decimal.\n* Conversion from `String` accepts an optional sign in the string.\n* For hexadecimal (radix 16) conversion an optional leading \"0x\", or \"0X\" is accepted.\n* For octal (radix 8) an optional leading \"0\" is accepted.\n* For binary (radix 2) an optional leading \"0b\" or \"0B\" is accepted.\n* When `radix` is set to `default`, the conversion is based on the leading.\n  characters in the string. A leading \"0\" for radix 8, a leading \"0x\", or \"0X\" for\n  radix 16, and leading \"0b\" or \"0B\" for binary.\n* Conversion from `Boolean` results in 0 for `false` and 1 for `true`.\n* Conversion from `Integer`, `Float`, and `Boolean` ignores the radix.\n* `Float` value fractions are truncated (no rounding).\n* When `abs` is set to `true`, the result will be an absolute integer.\n\nExamples - Converting to Integer:\n\n```puppet\n$a_number = Integer(\"0xFF\", 16)    # results in 255\n$a_number = Integer(\"010\")         # results in 8\n$a_number = Integer(\"010\", 10)     # results in 10\n$a_number = Integer(true)          # results in 1\n$a_number = Integer(-38, 10, true) # results in 38\n```\n\n### Conversion to Float\n\nA new `Float` can be created from `Integer`, `Float`, `Boolean`, and `String` values.\nFor conversion from `String` both float and integer formats are supported.\n\n```puppet\nfunction Float.new(\n  Variant[Numeric, Boolean, String] $value,\n  Boolean $abs = true\n)\n```\n\n* For an integer, the floating point fraction of `.0` is added to the value.\n* A `Boolean` `true` is converted to 1.0, and a `false` to 0.0\n* In `String` format, integer prefixes for hex and binary are understood (but not octal since\n  floating point in string format may start with a '0').\n* When `abs` is set to `true`, the result will be an absolute floating point value.\n\n### Conversion to Numeric\n\nA new `Integer` or `Float` can be created from `Integer`, `Float`, `Boolean` and\n`String` values.\n\n```puppet\nfunction Numeric.new(\n  Variant[Numeric, Boolean, String] $value,\n  Boolean $abs = true\n)\n```\n\n* If the value has a decimal period, or if given in scientific notation\n  (e/E), the result is a `Float`, otherwise the value is an `Integer`. The\n  conversion from `String` always uses a radix based on the prefix of the string.\n* Conversion from `Boolean` results in 0 for `false` and 1 for `true`.\n* When `abs` is set to `true`, the result will be an absolute `Float`or `Integer` value.\n\nExamples - Converting to Numeric\n\n```puppet\n$a_number = Numeric(true)        # results in 1\n$a_number = Numeric(\"0xFF\")      # results in 255\n$a_number = Numeric(\"010\")       # results in 8\n$a_number = Numeric(\"3.14\")      # results in 3.14 (a float)\n$a_number = Numeric(-42.3, true) # results in 42.3\n$a_number = Numeric(-42, true)   # results in 42\n```\n\n### Conversion to Timespan\n\nA new `Timespan` can be created from `Integer`, `Float`, `String`, and `Hash` values. Several variants of the constructor are provided.\n\n#### Timespan from seconds\n\nWhen a Float is used, the decimal part represents fractions of a second.\n\n```puppet\nfunction Timespan.new(\n  Variant[Float, Integer] $value\n)\n```\n\n#### Timespan from days, hours, minutes, seconds, and fractions of a second\n\nThe arguments can be passed separately in which case the first four, days, hours, minutes, and seconds are mandatory and the rest are optional.\nAll values may overflow and/or be negative. The internal 128-bit nano-second integer is calculated as:\n\n```\n(((((days * 24 + hours) * 60 + minutes) * 60 + seconds) * 1000 + milliseconds) * 1000 + microseconds) * 1000 + nanoseconds\n```\n\n```puppet\nfunction Timespan.new(\n  Integer $days, Integer $hours, Integer $minutes, Integer $seconds,\n  Integer $milliseconds = 0, Integer $microseconds = 0, Integer $nanoseconds = 0\n)\n```\n\nor, all arguments can be passed as a `Hash`, in which case all entries are optional:\n\n```puppet\nfunction Timespan.new(\n  Struct[{\n    Optional[negative] => Boolean,\n    Optional[days] => Integer,\n    Optional[hours] => Integer,\n    Optional[minutes] => Integer,\n    Optional[seconds] => Integer,\n    Optional[milliseconds] => Integer,\n    Optional[microseconds] => Integer,\n    Optional[nanoseconds] => Integer\n  }] $hash\n)\n```\n\n#### Timespan from String and format directive patterns\n\nThe first argument is parsed using the format optionally passed as a string or array of strings. When an array is used, an attempt\nwill be made to parse the string using the first entry and then with each entry in succession until parsing succeeds. If the second\nargument is omitted, an array of default formats will be used.\n\nAn exception is raised when no format was able to parse the given string.\n\n```puppet\nfunction Timespan.new(\n  String $string, Variant[String[2],Array[String[2], 1]] $format = <default format>)\n)\n```\n\nthe arguments may also be passed as a `Hash`:\n\n```puppet\nfunction Timespan.new(\n  Struct[{\n    string => String[1],\n    Optional[format] => Variant[String[2],Array[String[2], 1]]\n  }] $hash\n)\n```\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n```\n%[Flags][Width]Conversion\n```\n\n##### Flags:\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n\n##### Format directives:\n\n| Format | Meaning |\n| ------ | ------- |\n| D | Number of Days |\n| H | Hour of the day, 24-hour clock |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..59) |\n| L | Millisecond of the second (000..999) |\n| N | Fractional seconds digits |\n\nThe format directive that represents the highest magnitude in the format will be allowed to\noverflow. I.e. if no \"%D\" is used but a \"%H\" is present, then the hours may be more than 23.\n\nThe default array contains the following patterns:\n\n```\n['%D-%H:%M:%S', '%D-%H:%M', '%H:%M:%S', '%H:%M']\n```\n\nExamples - Converting to Timespan\n\n```puppet\n$duration = Timespan(13.5)       # 13 seconds and 500 milliseconds\n$duration = Timespan({days=>4})  # 4 days\n$duration = Timespan(4, 0, 0, 2) # 4 days and 2 seconds\n$duration = Timespan('13:20')    # 13 hours and 20 minutes (using default pattern)\n$duration = Timespan('10:03.5', '%M:%S.%L') # 10 minutes, 3 seconds, and 5 milli-seconds\n$duration = Timespan('10:03.5', '%M:%S.%N') # 10 minutes, 3 seconds, and 5 nano-seconds\n```\n\n### Conversion to Timestamp\n\nA new `Timestamp` can be created from `Integer`, `Float`, `String`, and `Hash` values. Several variants of the constructor are provided.\n\n#### Timestamp from seconds since epoch (1970-01-01 00:00:00 UTC)\n\nWhen a Float is used, the decimal part represents fractions of a second.\n\n```puppet\nfunction Timestamp.new(\n  Variant[Float, Integer] $value\n)\n```\n\n#### Timestamp from String and patterns consisting of format directives\n\nThe first argument is parsed using the format optionally passed as a string or array of strings. When an array is used, an attempt\nwill be made to parse the string using the first entry and then with each entry in succession until parsing succeeds. If the second\nargument is omitted, an array of default formats will be used.\n\nA third optional timezone argument can be provided. The first argument will then be parsed as if it represents a local time in that\ntimezone. The timezone can be any timezone that is recognized when using the '%z' or '%Z' formats, or the word 'current', in which\ncase the current timezone of the evaluating process will be used. The timezone argument is case insensitive.\n\nThe default timezone, when no argument is provided, or when using the keyword `default`, is 'UTC'.\n\nIt is illegal to provide a timezone argument other than `default` in combination with a format that contains '%z' or '%Z' since that\nwould introduce an ambiguity as to which timezone to use. The one extracted from the string, or the one provided as an argument.\n\nAn exception is raised when no format was able to parse the given string.\n\n```puppet\nfunction Timestamp.new(\n  String $string,\n  Variant[String[2],Array[String[2], 1]] $format = <default format>,\n  String $timezone = default)\n)\n```\n\nthe arguments may also be passed as a `Hash`:\n\n```puppet\nfunction Timestamp.new(\n  Struct[{\n    string => String[1],\n    Optional[format] => Variant[String[2],Array[String[2], 1]],\n    Optional[timezone] => String[1]\n  }] $hash\n)\n```\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n```\n%[Flags][Width]Conversion\n```\n\n##### Flags:\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n| #     | Change names to upper-case or change case of am/pm\n| ^     | Use uppercase\n| :     | Use colons for %z\n\n##### Format directives (names and padding can be altered using flags):\n\n**Date (Year, Month, Day):**\n\n| Format | Meaning |\n| ------ | ------- |\n| Y | Year with century, zero-padded to at least 4 digits |\n| C | year / 100 (rounded down such as 20 in 2009) |\n| y | year % 100 (00..99) |\n| m | Month of the year, zero-padded (01..12) |\n| B | The full month name (\"January\") |\n| b | The abbreviated month name (\"Jan\") |\n| h | Equivalent to %b |\n| d | Day of the month, zero-padded (01..31) |\n| e | Day of the month, blank-padded ( 1..31) |\n| j | Day of the year (001..366) |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| H | Hour of the day, 24-hour clock, zero-padded (00..23) |\n| k | Hour of the day, 24-hour clock, blank-padded ( 0..23) |\n| I | Hour of the day, 12-hour clock, zero-padded (01..12) |\n| l | Hour of the day, 12-hour clock, blank-padded ( 1..12) |\n| P | Meridian indicator, lowercase (\"am\" or \"pm\") |\n| p | Meridian indicator, uppercase (\"AM\" or \"PM\") |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..60) |\n| L | Millisecond of the second (000..999). Digits under millisecond are truncated to not produce 1000 |\n| N | Fractional seconds digits, default is 9 digits (nanosecond). Digits under a specified width are truncated to avoid carry up |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| z   | Time zone as hour and minute offset from UTC (e.g. +0900) |\n| :z  | hour and minute offset from UTC with a colon (e.g. +09:00) |\n| ::z | hour, minute and second offset from UTC (e.g. +09:00:00) |\n| Z   | Abbreviated time zone name or similar information.  (OS dependent) |\n\n**Weekday:**\n\n| Format | Meaning |\n| ------ | ------- |\n| A | The full weekday name (\"Sunday\") |\n| a | The abbreviated name (\"Sun\") |\n| u | Day of the week (Monday is 1, 1..7) |\n| w | Day of the week (Sunday is 0, 0..6) |\n\n**ISO 8601 week-based year and week number:**\n\nThe first week of YYYY starts with a Monday and includes YYYY-01-04.\nThe days in the year before the first week are in the last week of\nthe previous year.\n\n| Format | Meaning |\n| ------ | ------- |\n| G | The week-based year |\n| g | The last 2 digits of the week-based year (00..99) |\n| V | Week number of the week-based year (01..53) |\n\n**Week number:**\n\nThe first week of YYYY that starts with a Sunday or Monday (according to %U\nor %W). The days in the year before the first week are in week 0.\n\n| Format | Meaning |\n| ------ | ------- |\n| U | Week number of the year. The week starts with Sunday. (00..53) |\n| W | Week number of the year. The week starts with Monday. (00..53) |\n\n**Seconds since the Epoch:**\n\n| Format | Meaning |\n| s | Number of seconds since 1970-01-01 00:00:00 UTC. |\n\n**Literal string:**\n\n| Format | Meaning |\n| ------ | ------- |\n| n | Newline character (\\n) |\n| t | Tab character (\\t) |\n| % | Literal \"%\" character |\n\n**Combination:**\n\n| Format | Meaning |\n| ------ | ------- |\n| c | date and time (%a %b %e %T %Y) |\n| D | Date (%m/%d/%y) |\n| F | The ISO 8601 date format (%Y-%m-%d) |\n| v | VMS date (%e-%^b-%4Y) |\n| x | Same as %D |\n| X | Same as %T |\n| r | 12-hour time (%I:%M:%S %p) |\n| R | 24-hour time (%H:%M) |\n| T | 24-hour time (%H:%M:%S) |\n\nThe default array contains the following patterns:\n\nWhen a timezone argument (other than `default`) is explicitly provided:\n\n```\n['%FT%T.L', '%FT%T', '%F']\n```\n\notherwise:\n\n```\n['%FT%T.%L %Z', '%FT%T %Z', '%F %Z', '%FT%T.L', '%FT%T', '%F']\n```\n\nExamples - Converting to Timestamp\n\n```puppet\n$ts = Timestamp(1473150899)                              # 2016-09-06 08:34:59 UTC\n$ts = Timestamp({string=>'2015', format=>'%Y'})          # 2015-01-01 00:00:00.000 UTC\n$ts = Timestamp('Wed Aug 24 12:13:14 2016', '%c')        # 2016-08-24 12:13:14 UTC\n$ts = Timestamp('Wed Aug 24 12:13:14 2016 PDT', '%c %Z') # 2016-08-24 19:13:14.000 UTC\n$ts = Timestamp('2016-08-24 12:13:14', '%F %T', 'PST')   # 2016-08-24 20:13:14.000 UTC\n$ts = Timestamp('2016-08-24T12:13:14', default, 'PST')   # 2016-08-24 20:13:14.000 UTC\n\n```\n\n### Conversion to Type\n\nA new `Type` can be create from its `String` representation.\n\n**Example:** Creating a type from a string\n\n```puppet\n$t = Type.new('Integer[10]')\n```\n\n### Conversion to String\n\nConversion to `String` is the most comprehensive conversion as there are many\nuse cases where a string representation is wanted. The defaults for the many options\nhave been chosen with care to be the most basic \"value in textual form\" representation.\nThe more advanced forms of formatting are intended to enable writing special purposes formatting\nfunctions in the Puppet language.\n\nA new string can be created from all other data types. The process is performed in\nseveral steps - first the data type of the given value is inferred, then the resulting data type\nis used to find the most significant format specified for that data type. And finally,\nthe found format is used to convert the given value.\n\nThe mapping from data type to format is referred to as the *format map*. This map\nallows different formatting depending on type.\n\n**Example:** Positive Integers in Hexadecimal prefixed with '0x', negative in Decimal\n\n```puppet\n$format_map = {\n  Integer[default, 0] => \"%d\",\n  Integer[1, default] => \"%#x\"\n}\nString(\"-1\", $format_map)  # produces '-1'\nString(\"10\", $format_map)  # produces '0xa'\n```\n\nA format is specified on the form:\n\n```\n%[Flags][Width][.Precision]Format\n```\n\n`Width` is the number of characters into which the value should be fitted. This allocated space is\npadded if value is shorter. By default it is space padded, and the flag `0` will cause padding with `0`\nfor numerical formats.\n\n`Precision` is the number of fractional digits to show for floating point, and the maximum characters\nincluded in a string format.\n\nNote that all data type supports the formats `s` and `p` with the meaning \"default string representation\" and\n\"default programmatic string representation\" (which for example means that a String is quoted in 'p' format).\n\n#### Signatures of String conversion\n\n```puppet\ntype Format = Pattern[/^%([\\s\\+\\-#0\\[\\{<\\(\\|]*)([1-9][0-9]*)?(?:\\.([0-9]+))?([a-zA-Z])/]\ntype ContainerFormat = Struct[{\n  format         => Optional[String],\n  separator      => Optional[String],\n  separator2     => Optional[String],\n  string_formats => Hash[Type, Format]\n  }]\ntype TypeMap = Hash[Type, Variant[Format, ContainerFormat]]\ntype Formats = Variant[Default, String[1], TypeMap]\n\nfunction String.new(\n  Any $value,\n  Formats $string_formats\n)\n```\n\nWhere:\n\n* `separator` is the string used to separate entries in an array, or hash (extra space should not be included at\n  the end), defaults to `\",\"`\n* `separator2` is the separator between key and value in a hash entry (space padding should be included as\n  wanted), defaults to `\" => \"`.\n* `string_formats` is a data type to format map for values contained in arrays and hashes - defaults to `{Any => \"%p\"}`. Note that\n  these nested formats are not applicable to data types that are containers; they are always formatted as per the top level\n  format specification.\n\n**Example:** Simple Conversion to String (using defaults)\n\n```puppet\n$str = String(10)      # produces '10'\n$str = String([10])    # produces '[\"10\"]'\n```\n\n**Example:** Simple Conversion to String specifying the format for the given value directly\n\n```puppet\n$str = String(10, \"%#x\")    # produces '0x10'\n$str = String([10], \"%(a\")  # produces '(\"10\")'\n```\n\n**Example:** Specifying type for values contained in an array\n\n```puppet\n$formats = {\n  Array => {\n    format => '%(a',\n    string_formats => { Integer => '%#x' }\n  }\n}\n$str = String([1,2,3], $formats) # produces '(0x1, 0x2, 0x3)'\n```\n\nThe given formats are merged with the default formats, and matching of values to convert against format is based on\nthe specificity of the mapped type; for example, different formats can be used for short and long arrays.\n\n#### Integer to String\n\n| Format  | Integer Formats\n| ------  | ---------------\n| d       | Decimal, negative values produces leading '-'.\n| x X     | Hexadecimal in lower or upper case. Uses ..f/..F for negative values unless + is also used. A `#` adds prefix 0x/0X.\n| o       | Octal. Uses ..0 for negative values unless `+` is also used. A `#` adds prefix 0.\n| b B     | Binary with prefix 'b' or 'B'. Uses ..1/..1 for negative values unless `+` is also used.\n| c       | Numeric value representing a Unicode value, result is a one unicode character string, quoted if alternative flag # is used\n| s       | Same as d, or d in quotes if alternative flag # is used.\n| p       | Same as d.\n| eEfgGaA | Converts integer to float and formats using the floating point rules.\n\nDefaults to `d`.\n\n#### Float to String\n\n| Format  | Float formats\n| ------  | -------------\n| f       | Floating point in non exponential notation.\n| e E     | Exponential notation with 'e' or 'E'.\n| g G     | Conditional exponential with 'e' or 'E' if exponent < -4 or >= the precision.\n| a A     | Hexadecimal exponential form, using 'x'/'X' as prefix and 'p'/'P' before exponent.\n| s       | Converted to string using format p, then applying string formatting rule, alternate form # quotes result.\n| p       | Same as f format with minimum significant number of fractional digits, prec has no effect.\n| dxXobBc | Converts float to integer and formats using the integer rules.\n\nDefaults to `p`.\n\n#### String to String\n\n| Format | String\n| ------ | ------\n| s      | Unquoted string, verbatim output of control chars.\n| p      | Programmatic representation - strings are quoted, interior quotes and control chars are escaped.\n| C      | Each `::` name segment capitalized, quoted if alternative flag `#` is used.\n| c      | Capitalized string, quoted if alternative flag `#` is used.\n| d      | Downcased string, quoted if alternative flag `#` is used.\n| u      | Upcased string, quoted if alternative flag `#` is used.\n| t      | Trims leading and trailing whitespace from the string, quoted if alternative flag `#` is used.\n\nDefaults to `s` at top level and `p` inside array or hash.\n\n#### Boolean to String\n\n| Format    | Boolean Formats\n| ----      | -------------------\n| t T       | String 'true'/'false' or 'True'/'False', first char if alternate form is used (i.e. 't'/'f' or 'T'/'F').\n| y Y       | String 'yes'/'no', 'Yes'/'No', 'y'/'n' or 'Y'/'N' if alternative flag `#` is used.\n| dxXobB    | Numeric value 0/1 in accordance with the given format which must be valid integer format.\n| eEfgGaA   | Numeric value 0.0/1.0 in accordance with the given float format and flags.\n| s         | String 'true' / 'false'.\n| p         | String 'true' / 'false'.\n\n#### Regexp to String\n\n| Format    | Regexp Formats\n| ----      | --------------\n| s         | No delimiters, quoted if alternative flag `#` is used.\n| p         | Delimiters `/ /`.\n\n#### Undef to String\n\n| Format    | Undef formats\n| ------    | -------------\n| s         | Empty string, or quoted empty string if alternative flag `#` is used.\n| p         | String 'undef', or quoted '\"undef\"' if alternative flag `#` is used.\n| n         | String 'nil', or 'null' if alternative flag `#` is used.\n| dxXobB    | String 'NaN'.\n| eEfgGaA   | String 'NaN'.\n| v         | String 'n/a'.\n| V         | String 'N/A'.\n| u         | String 'undef', or 'undefined' if alternative `#` flag is used.\n\n#### Default value to String\n\n| Format    | Default formats\n| ------    | ---------------\n| d D       | String 'default' or 'Default', alternative form `#` causes value to be quoted.\n| s         | Same as d.\n| p         | Same as d.\n\n#### Binary value to String\n\n| Format    | Default formats\n| ------    | ---------------\n| s         | binary as unquoted UTF-8 characters (errors if byte sequence is invalid UTF-8). Alternate form escapes non ascii bytes.\n| p         | 'Binary(\"<base64strict>\")'\n| b         | '<base64>' - base64 string with newlines inserted\n| B         | '<base64strict>' - base64 strict string (without newlines inserted)\n| u         | '<base64urlsafe>' - base64 urlsafe string\n| t         | 'Binary' - outputs the name of the type only\n| T         | 'BINARY' - output the name of the type in all caps only\n\n* The alternate form flag `#` will quote the binary or base64 text output.\n* The format `%#s` allows invalid UTF-8 characters and outputs all non ascii bytes\n  as hex escaped characters on the form `\\\\xHH` where `H` is a hex digit.\n* The width and precision values are applied to the text part only in `%p` format.\n\n#### Array & Tuple to String\n\n| Format    | Array/Tuple Formats\n| ------    | -------------\n| a         | Formats with `[ ]` delimiters and `,`, alternate form `#` indents nested arrays/hashes.\n| s         | Same as a.\n| p         | Same as a.\n\nSee \"Flags\" `<[({\\|` for formatting of delimiters, and \"Additional parameters for containers; Array and Hash\" for\nmore information about options.\n\nThe alternate form flag `#` will cause indentation of nested array or hash containers. If width is also set\nit is taken as the maximum allowed length of a sequence of elements (not including delimiters). If this max length\nis exceeded, each element will be indented.\n\n#### Hash & Struct to String\n\n| Format    | Hash/Struct Formats\n| ------    | -------------\n| h         | Formats with `{ }` delimiters, `,` element separator and ` => ` inner element separator unless overridden by flags.\n| s         | Same as h.\n| p         | Same as h.\n| a         | Converts the hash to an array of [k,v] tuples and formats it using array rule(s).\n\nSee \"Flags\" `<[({\\|` for formatting of delimiters, and \"Additional parameters for containers; Array and Hash\" for\nmore information about options.\n\nThe alternate form flag `#` will format each hash key/value entry indented on a separate line.\n\n#### Type to String\n\n| Format    | Array/Tuple Formats\n| ------    | -------------\n| s         | The same as `p`, quoted if alternative flag `#` is used.\n| p         | Outputs the type in string form as specified by the Puppet Language.\n\n#### Flags\n\n| Flag     | Effect\n| ------   | ------\n| (space)  | A space instead of `+` for numeric output (`-` is shown), for containers skips delimiters.\n| #        | Alternate format; prefix 0x/0x, 0 (octal) and 0b/0B for binary, Floats force decimal '.'. For g/G keep trailing 0.\n| +        | Show sign +/- depending on value's sign, changes x, X, o, b, B format to not use 2's complement form.\n| -        | Left justify the value in the given width.\n| 0        | Pad with 0 instead of space for widths larger than value.\n| <[({\\|   | Defines an enclosing pair <> [] () {} or \\| \\| when used with a container type.\n\n### Conversion to Boolean\n\nAccepts a single value as argument:\n\n* Float 0.0 is `false`, all other float values are `true`\n* Integer 0 is `false`, all other integer values are `true`\n* Strings\n  * `true` if 'true', 'yes', 'y' (case independent compare)\n  * `false` if 'false', 'no', 'n' (case independent compare)\n* Boolean is already boolean and is simply returned\n\n### Conversion to Array and Tuple\n\nWhen given a single value as argument:\n\n* A non empty `Hash` is converted to an array matching `Array[Tuple[Any,Any], 1]`.\n* An empty `Hash` becomes an empty array.\n* An `Array` is simply returned.\n* An `Iterable[T]` is turned into an array of `T` instances.\n* A `Binary` is converted to an `Array[Integer[0,255]]` of byte values\n\n\nWhen given a second Boolean argument:\n\n* if `true`, a value that is not already an array is returned as a one element array.\n* if `false`, (the default), converts the first argument as shown above.\n\n**Example:** Ensuring value is an array\n\n```puppet\n$arr = Array($value, true)\n```\n\nConversion to a `Tuple` works exactly as conversion to an `Array`, only that the constructed array is\nasserted against the given tuple type.\n\n### Conversion to Hash and Struct\n\nAccepts a single value as argument:\n\n* An empty `Array` becomes an empty `Hash`\n* An `Array` matching `Array[Tuple[Any,Any], 1]` is converted to a hash where each tuple describes a key/value entry\n* An `Array` with an even number of entries is interpreted as `[key1, val1, key2, val2, ...]`\n* An `Iterable` is turned into an `Array` and then converted to hash as per the array rules\n* A `Hash` is simply returned\n\nAlternatively, a tree can be constructed by giving two values; an array of tuples on the form `[path, value]`\n(where the `path` is the path from the root of a tree, and `value` the value at that position in the tree), and\neither the option `'tree'` (do not convert arrays to hashes except the top level), or\n`'hash_tree'` (convert all arrays to hashes).\n\nThe tree/hash_tree forms of Hash creation are suited for transforming the result of an iteration\nusing `tree_each` and subsequent filtering or mapping.\n\n**Example:** Mapping a hash tree\n\nMapping an arbitrary structure in a way that keeps the structure, but where some values are replaced\ncan be done by using the `tree_each` function, mapping, and then constructing a new Hash from the result:\n\n```puppet\n# A hash tree with 'water' at different locations\n$h = { a => { b => { x => 'water'}}, b => { y => 'water'} }\n# a helper function that turns water into wine\nfunction make_wine($x) { if $x == 'water' { 'wine' } else { $x } }\n# create a flattened tree with water turned into wine\n$flat_tree = $h.tree_each.map |$entry| { [$entry[0], make_wine($entry[1])] }\n# create a new Hash and log it\nnotice Hash($flat_tree, 'hash_tree')\n```\n\nWould notice the hash `{a => {b => {x => wine}}, b => {y => wine}}`\n\nConversion to a `Struct` works exactly as conversion to a `Hash`, only that the constructed hash is\nasserted against the given struct type.\n\n### Conversion to a Regexp\n\nA `String` can be converted into a `Regexp`\n\n**Example**: Converting a String into a Regexp\n```puppet\n$s = '[a-z]+\\.com'\n$r = Regexp($s)\nif('foo.com' =~ $r) {\n  ...\n}\n```\n\n### Creating a SemVer\n\nA SemVer object represents a single [Semantic Version](http://semver.org/).\nIt can be created from a String, individual values for its parts, or a hash specifying the value per part.\nSee the specification at [semver.org](http://semver.org/) for the meaning of the SemVer's parts.\n\nThe signatures are:\n\n```puppet\ntype PositiveInteger = Integer[0,default]\ntype SemVerQualifier = Pattern[/\\A(?<part>[0-9A-Za-z-]+)(?:\\.\\g<part>)*\\Z/]\ntype SemVerString = String[1]\ntype SemVerHash =Struct[{\n  major                => PositiveInteger,\n  minor                => PositiveInteger,\n  patch                => PositiveInteger,\n  Optional[prerelease] => SemVerQualifier,\n  Optional[build]      => SemVerQualifier\n}]\n\nfunction SemVer.new(SemVerString $str)\n\nfunction SemVer.new(\n        PositiveInteger           $major\n        PositiveInteger           $minor\n        PositiveInteger           $patch\n        Optional[SemVerQualifier] $prerelease = undef\n        Optional[SemVerQualifier] $build = undef\n        )\n\nfunction SemVer.new(SemVerHash $hash_args)\n```\n\n**Examples:** SemVer and SemVerRange usage\n\n```puppet\n# As a type, SemVer can describe disjunct ranges which versions can be\n# matched against - here the type is constructed with two\n# SemVerRange objects.\n#\n$t = SemVer[\n  SemVerRange('>=1.0.0 <2.0.0'),\n  SemVerRange('>=3.0.0 <4.0.0')\n]\nnotice(SemVer('1.2.3') =~ $t) # true\nnotice(SemVer('2.3.4') =~ $t) # false\nnotice(SemVer('3.4.5') =~ $t) # true\n```\n\n### Creating a SemVerRange\n\nA `SemVerRange` object represents a range of `SemVer`. It can be created from\na `String`, or from two `SemVer` instances, where either end can be given as\na literal `default` to indicate infinity. The string format of a `SemVerRange` is specified by\nthe [Semantic Version Range Grammar](https://github.com/npm/node-semver#ranges).\n\n> Use of the comparator sets described in the grammar (joining with `||`) is not supported.\n\nThe signatures are:\n\n```puppet\ntype SemVerRangeString = String[1]\ntype SemVerRangeHash = Struct[{\n  min                   => Variant[Default, SemVer],\n  Optional[max]         => Variant[Default, SemVer],\n  Optional[exclude_max] => Boolean\n}]\n\nfunction SemVerRange.new(\n  SemVerRangeString $semver_range_string\n)\n\nfunction SemVerRange.new(\n  Variant[Default,SemVer] $min\n  Variant[Default,SemVer] $max\n  Optional[Boolean]       $exclude_max = undef\n)\n\nfunction SemVerRange.new(\n  SemVerRangeHash $semver_range_hash\n)\n```\n\nFor examples of `SemVerRange` use, see \"Creating a SemVer\".\n\n### Creating a Binary\n\nA `Binary` object represents a sequence of bytes and it can be created from a String in Base64 format,\nan Array containing byte values. A Binary can also be created from a Hash containing the value to convert to\na `Binary`.\n\nThe signatures are:\n\n```puppet\ntype ByteInteger = Integer[0,255]\ntype Base64Format = Enum[\"%b\", \"%u\", \"%B\", \"%s\"]\ntype StringHash = Struct[{value => String, \"format\" => Optional[Base64Format]}]\ntype ArrayHash = Struct[{value => Array[ByteInteger]}]\ntype BinaryArgsHash = Variant[StringHash, ArrayHash]\n\nfunction Binary.new(\n  String $base64_str,\n  Optional[Base64Format] $format\n)\n\nfunction Binary.new(\n  Array[ByteInteger] $byte_array\n}\n\n# Same as for String, or for Array, but where arguments are given in a Hash.\nfunction Binary.new(BinaryArgsHash $hash_args)\n```\n\nThe formats have the following meaning:\n\n| format | explanation |\n| ----   | ----        |\n| B | The data is in base64 strict encoding\n| u | The data is in URL safe base64 encoding\n| b | The data is in base64 encoding, padding as required by base64 strict, is added by default\n| s | The data is a puppet string. The string must be valid UTF-8, or convertible to UTF-8 or an error is raised.\n| r | (Ruby Raw) the byte sequence in the given string is used verbatim irrespective of possible encoding errors\n\n* The default format is `%B`.\n* Note that the format `%r` should be used sparingly, or not at all. It exists for backwards compatibility reasons when someone receiving\n  a string from some function and that string should be treated as Binary. Such code should be changed to return a Binary instead of a String.\n\n**Examples:** Creating a Binary\n\n```puppet\n# create the binary content \"abc\"\n$a = Binary('YWJj')\n\n# create the binary content from content in a module's file\n$b = binary_file('mymodule/mypicture.jpg')\n```\n\n* Since 4.5.0\n* Binary type since 4.8.0\n\nCreating an instance of a `Type` using the `Init` type.\n-------\n\nThe type `Init[T]` describes a value that can be used when instantiating a type. When used as the first argument in a call to `new`, it\nwill dispatch the call to its contained type and optionally augment the parameter list with additional arguments.\n\n**Example:** Creating an instance of Integer using Init[Integer]\n\n```puppet\n# The following declaration\n$x = Init[Integer].new('128')\n# is exactly the same as\n$x = Integer.new('128')\n```\n\nor, with base 16 and using implicit new\n\n```puppet\n# The following declaration\n$x = Init[Integer,16]('80')\n# is exactly the same as\n$x = Integer('80', 16)\n```\n\n**Example:** Creating an instance of String using a predefined format\n\n```puppet\n$fmt = Init[String,'%#x']\nnotice($fmt(256)) # will notice '0x100'\n```",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :new,\n  :type => :rvalue,\n  :arity => -1,\n  :doc => <<-DOC\nCreates a new instance/object of a given data type.\n\nThis function makes it possible to create new instances of\nconcrete data types. If a block is given it is called with the\njust created instance as an argument.\n\nCalling this function is equivalent to directly\ncalling the data type:\n\n**Example:** `new` and calling type directly are equivalent\n\n```puppet\n$a = Integer.new(\"42\")\n$b = Integer(\"42\")\n```\n\nThese would both convert the string `\"42\"` to the decimal value `42`.\n\n**Example:** arguments by position or by name\n\n```puppet\n$a = Integer.new(\"42\", 8)\n$b = Integer({from => \"42\", radix => 8})\n```\n\nThis would convert the octal (radix 8) number `\"42\"` in string form\nto the decimal value `34`.\n\nThe new function supports two ways of giving the arguments:\n\n* by name (using a hash with property to value mapping)\n* by position (as regular arguments)\n\nNote that it is not possible to create new instances of\nsome abstract data types (for example `Variant`). The data type `Optional[T]` is an\nexception as it will create an instance of `T` or `undef` if the\nvalue to convert is `undef`.\n\nThe arguments that can be given is determined by the data type.\n\n> An assertion is always made that the produced value complies with the given type constraints.\n\n**Example:** data type constraints are checked\n\n```puppet\nInteger[0].new(\"-100\")\n```\n\nWould fail with an assertion error (since value is less than 0).\n\nThe following sections show the arguments and conversion rules\nper data type built into the Puppet Type System.\n\n### Conversion to Optional[T] and NotUndef[T]\n\nConversion to these data types is the same as a conversion to the type argument `T`.\nIn the case of `Optional[T]` it is accepted that the argument to convert may be `undef`.\nIt is however not acceptable to give other arguments (than `undef`) that cannot be\nconverted to `T`.\n\n### Conversion to Integer\n\nA new `Integer` can be created from `Integer`, `Float`, `Boolean`, and `String` values.\nFor conversion from `String` it is possible to specify the radix (base).\n\n```puppet\ntype Radix = Variant[Default, Integer[2,2], Integer[8,8], Integer[10,10], Integer[16,16]]\n\nfunction Integer.new(\n  String $value,\n  Radix $radix = 10,\n  Boolean $abs = false\n)\n\nfunction Integer.new(\n  Variant[Numeric, Boolean] $value,\n  Boolean $abs = false\n)\n```\n\n* When converting from `String` the default radix is 10.\n* If radix is not specified an attempt is made to detect the radix from the start of the string:\n  * `0b` or `0B` is taken as radix 2.\n  * `0x` or `0X` is taken as radix 16.\n  * `0` as radix 8.\n  * All others are decimal.\n* Conversion from `String` accepts an optional sign in the string.\n* For hexadecimal (radix 16) conversion an optional leading \"0x\", or \"0X\" is accepted.\n* For octal (radix 8) an optional leading \"0\" is accepted.\n* For binary (radix 2) an optional leading \"0b\" or \"0B\" is accepted.\n* When `radix` is set to `default`, the conversion is based on the leading.\n  characters in the string. A leading \"0\" for radix 8, a leading \"0x\", or \"0X\" for\n  radix 16, and leading \"0b\" or \"0B\" for binary.\n* Conversion from `Boolean` results in 0 for `false` and 1 for `true`.\n* Conversion from `Integer`, `Float`, and `Boolean` ignores the radix.\n* `Float` value fractions are truncated (no rounding).\n* When `abs` is set to `true`, the result will be an absolute integer.\n\nExamples - Converting to Integer:\n\n```puppet\n$a_number = Integer(\"0xFF\", 16)    # results in 255\n$a_number = Integer(\"010\")         # results in 8\n$a_number = Integer(\"010\", 10)     # results in 10\n$a_number = Integer(true)          # results in 1\n$a_number = Integer(-38, 10, true) # results in 38\n```\n\n### Conversion to Float\n\nA new `Float` can be created from `Integer`, `Float`, `Boolean`, and `String` values.\nFor conversion from `String` both float and integer formats are supported.\n\n```puppet\nfunction Float.new(\n  Variant[Numeric, Boolean, String] $value,\n  Boolean $abs = true\n)\n```\n\n* For an integer, the floating point fraction of `.0` is added to the value.\n* A `Boolean` `true` is converted to 1.0, and a `false` to 0.0\n* In `String` format, integer prefixes for hex and binary are understood (but not octal since\n  floating point in string format may start with a '0').\n* When `abs` is set to `true`, the result will be an absolute floating point value.\n\n### Conversion to Numeric\n\nA new `Integer` or `Float` can be created from `Integer`, `Float`, `Boolean` and\n`String` values.\n\n```puppet\nfunction Numeric.new(\n  Variant[Numeric, Boolean, String] $value,\n  Boolean $abs = true\n)\n```\n\n* If the value has a decimal period, or if given in scientific notation\n  (e/E), the result is a `Float`, otherwise the value is an `Integer`. The\n  conversion from `String` always uses a radix based on the prefix of the string.\n* Conversion from `Boolean` results in 0 for `false` and 1 for `true`.\n* When `abs` is set to `true`, the result will be an absolute `Float`or `Integer` value.\n\nExamples - Converting to Numeric\n\n```puppet\n$a_number = Numeric(true)        # results in 1\n$a_number = Numeric(\"0xFF\")      # results in 255\n$a_number = Numeric(\"010\")       # results in 8\n$a_number = Numeric(\"3.14\")      # results in 3.14 (a float)\n$a_number = Numeric(-42.3, true) # results in 42.3\n$a_number = Numeric(-42, true)   # results in 42\n```\n\n### Conversion to Timespan\n\nA new `Timespan` can be created from `Integer`, `Float`, `String`, and `Hash` values. Several variants of the constructor are provided.\n\n#### Timespan from seconds\n\nWhen a Float is used, the decimal part represents fractions of a second.\n\n```puppet\nfunction Timespan.new(\n  Variant[Float, Integer] $value\n)\n```\n\n#### Timespan from days, hours, minutes, seconds, and fractions of a second\n\nThe arguments can be passed separately in which case the first four, days, hours, minutes, and seconds are mandatory and the rest are optional.\nAll values may overflow and/or be negative. The internal 128-bit nano-second integer is calculated as:\n\n```\n(((((days * 24 + hours) * 60 + minutes) * 60 + seconds) * 1000 + milliseconds) * 1000 + microseconds) * 1000 + nanoseconds\n```\n\n```puppet\nfunction Timespan.new(\n  Integer $days, Integer $hours, Integer $minutes, Integer $seconds,\n  Integer $milliseconds = 0, Integer $microseconds = 0, Integer $nanoseconds = 0\n)\n```\n\nor, all arguments can be passed as a `Hash`, in which case all entries are optional:\n\n```puppet\nfunction Timespan.new(\n  Struct[{\n    Optional[negative] => Boolean,\n    Optional[days] => Integer,\n    Optional[hours] => Integer,\n    Optional[minutes] => Integer,\n    Optional[seconds] => Integer,\n    Optional[milliseconds] => Integer,\n    Optional[microseconds] => Integer,\n    Optional[nanoseconds] => Integer\n  }] $hash\n)\n```\n\n#### Timespan from String and format directive patterns\n\nThe first argument is parsed using the format optionally passed as a string or array of strings. When an array is used, an attempt\nwill be made to parse the string using the first entry and then with each entry in succession until parsing succeeds. If the second\nargument is omitted, an array of default formats will be used.\n\nAn exception is raised when no format was able to parse the given string.\n\n```puppet\nfunction Timespan.new(\n  String $string, Variant[String[2],Array[String[2], 1]] $format = <default format>)\n)\n```\n\nthe arguments may also be passed as a `Hash`:\n\n```puppet\nfunction Timespan.new(\n  Struct[{\n    string => String[1],\n    Optional[format] => Variant[String[2],Array[String[2], 1]]\n  }] $hash\n)\n```\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n```\n%[Flags][Width]Conversion\n```\n\n##### Flags:\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n\n##### Format directives:\n\n| Format | Meaning |\n| ------ | ------- |\n| D | Number of Days |\n| H | Hour of the day, 24-hour clock |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..59) |\n| L | Millisecond of the second (000..999) |\n| N | Fractional seconds digits |\n\nThe format directive that represents the highest magnitude in the format will be allowed to\noverflow. I.e. if no \"%D\" is used but a \"%H\" is present, then the hours may be more than 23.\n\nThe default array contains the following patterns:\n\n```\n['%D-%H:%M:%S', '%D-%H:%M', '%H:%M:%S', '%H:%M']\n```\n\nExamples - Converting to Timespan\n\n```puppet\n$duration = Timespan(13.5)       # 13 seconds and 500 milliseconds\n$duration = Timespan({days=>4})  # 4 days\n$duration = Timespan(4, 0, 0, 2) # 4 days and 2 seconds\n$duration = Timespan('13:20')    # 13 hours and 20 minutes (using default pattern)\n$duration = Timespan('10:03.5', '%M:%S.%L') # 10 minutes, 3 seconds, and 5 milli-seconds\n$duration = Timespan('10:03.5', '%M:%S.%N') # 10 minutes, 3 seconds, and 5 nano-seconds\n```\n\n### Conversion to Timestamp\n\nA new `Timestamp` can be created from `Integer`, `Float`, `String`, and `Hash` values. Several variants of the constructor are provided.\n\n#### Timestamp from seconds since epoch (1970-01-01 00:00:00 UTC)\n\nWhen a Float is used, the decimal part represents fractions of a second.\n\n```puppet\nfunction Timestamp.new(\n  Variant[Float, Integer] $value\n)\n```\n\n#### Timestamp from String and patterns consisting of format directives\n\nThe first argument is parsed using the format optionally passed as a string or array of strings. When an array is used, an attempt\nwill be made to parse the string using the first entry and then with each entry in succession until parsing succeeds. If the second\nargument is omitted, an array of default formats will be used.\n\nA third optional timezone argument can be provided. The first argument will then be parsed as if it represents a local time in that\ntimezone. The timezone can be any timezone that is recognized when using the '%z' or '%Z' formats, or the word 'current', in which\ncase the current timezone of the evaluating process will be used. The timezone argument is case insensitive.\n\nThe default timezone, when no argument is provided, or when using the keyword `default`, is 'UTC'.\n\nIt is illegal to provide a timezone argument other than `default` in combination with a format that contains '%z' or '%Z' since that\nwould introduce an ambiguity as to which timezone to use. The one extracted from the string, or the one provided as an argument.\n\nAn exception is raised when no format was able to parse the given string.\n\n```puppet\nfunction Timestamp.new(\n  String $string,\n  Variant[String[2],Array[String[2], 1]] $format = <default format>,\n  String $timezone = default)\n)\n```\n\nthe arguments may also be passed as a `Hash`:\n\n```puppet\nfunction Timestamp.new(\n  Struct[{\n    string => String[1],\n    Optional[format] => Variant[String[2],Array[String[2], 1]],\n    Optional[timezone] => String[1]\n  }] $hash\n)\n```\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n```\n%[Flags][Width]Conversion\n```\n\n##### Flags:\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n| #     | Change names to upper-case or change case of am/pm\n| ^     | Use uppercase\n| :     | Use colons for %z\n\n##### Format directives (names and padding can be altered using flags):\n\n**Date (Year, Month, Day):**\n\n| Format | Meaning |\n| ------ | ------- |\n| Y | Year with century, zero-padded to at least 4 digits |\n| C | year / 100 (rounded down such as 20 in 2009) |\n| y | year % 100 (00..99) |\n| m | Month of the year, zero-padded (01..12) |\n| B | The full month name (\"January\") |\n| b | The abbreviated month name (\"Jan\") |\n| h | Equivalent to %b |\n| d | Day of the month, zero-padded (01..31) |\n| e | Day of the month, blank-padded ( 1..31) |\n| j | Day of the year (001..366) |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| H | Hour of the day, 24-hour clock, zero-padded (00..23) |\n| k | Hour of the day, 24-hour clock, blank-padded ( 0..23) |\n| I | Hour of the day, 12-hour clock, zero-padded (01..12) |\n| l | Hour of the day, 12-hour clock, blank-padded ( 1..12) |\n| P | Meridian indicator, lowercase (\"am\" or \"pm\") |\n| p | Meridian indicator, uppercase (\"AM\" or \"PM\") |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..60) |\n| L | Millisecond of the second (000..999). Digits under millisecond are truncated to not produce 1000 |\n| N | Fractional seconds digits, default is 9 digits (nanosecond). Digits under a specified width are truncated to avoid carry up |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| z   | Time zone as hour and minute offset from UTC (e.g. +0900) |\n| :z  | hour and minute offset from UTC with a colon (e.g. +09:00) |\n| ::z | hour, minute and second offset from UTC (e.g. +09:00:00) |\n| Z   | Abbreviated time zone name or similar information.  (OS dependent) |\n\n**Weekday:**\n\n| Format | Meaning |\n| ------ | ------- |\n| A | The full weekday name (\"Sunday\") |\n| a | The abbreviated name (\"Sun\") |\n| u | Day of the week (Monday is 1, 1..7) |\n| w | Day of the week (Sunday is 0, 0..6) |\n\n**ISO 8601 week-based year and week number:**\n\nThe first week of YYYY starts with a Monday and includes YYYY-01-04.\nThe days in the year before the first week are in the last week of\nthe previous year.\n\n| Format | Meaning |\n| ------ | ------- |\n| G | The week-based year |\n| g | The last 2 digits of the week-based year (00..99) |\n| V | Week number of the week-based year (01..53) |\n\n**Week number:**\n\nThe first week of YYYY that starts with a Sunday or Monday (according to %U\nor %W). The days in the year before the first week are in week 0.\n\n| Format | Meaning |\n| ------ | ------- |\n| U | Week number of the year. The week starts with Sunday. (00..53) |\n| W | Week number of the year. The week starts with Monday. (00..53) |\n\n**Seconds since the Epoch:**\n\n| Format | Meaning |\n| s | Number of seconds since 1970-01-01 00:00:00 UTC. |\n\n**Literal string:**\n\n| Format | Meaning |\n| ------ | ------- |\n| n | Newline character (\\n) |\n| t | Tab character (\\t) |\n| % | Literal \"%\" character |\n\n**Combination:**\n\n| Format | Meaning |\n| ------ | ------- |\n| c | date and time (%a %b %e %T %Y) |\n| D | Date (%m/%d/%y) |\n| F | The ISO 8601 date format (%Y-%m-%d) |\n| v | VMS date (%e-%^b-%4Y) |\n| x | Same as %D |\n| X | Same as %T |\n| r | 12-hour time (%I:%M:%S %p) |\n| R | 24-hour time (%H:%M) |\n| T | 24-hour time (%H:%M:%S) |\n\nThe default array contains the following patterns:\n\nWhen a timezone argument (other than `default`) is explicitly provided:\n\n```\n['%FT%T.L', '%FT%T', '%F']\n```\n\notherwise:\n\n```\n['%FT%T.%L %Z', '%FT%T %Z', '%F %Z', '%FT%T.L', '%FT%T', '%F']\n```\n\nExamples - Converting to Timestamp\n\n```puppet\n$ts = Timestamp(1473150899)                              # 2016-09-06 08:34:59 UTC\n$ts = Timestamp({string=>'2015', format=>'%Y'})          # 2015-01-01 00:00:00.000 UTC\n$ts = Timestamp('Wed Aug 24 12:13:14 2016', '%c')        # 2016-08-24 12:13:14 UTC\n$ts = Timestamp('Wed Aug 24 12:13:14 2016 PDT', '%c %Z') # 2016-08-24 19:13:14.000 UTC\n$ts = Timestamp('2016-08-24 12:13:14', '%F %T', 'PST')   # 2016-08-24 20:13:14.000 UTC\n$ts = Timestamp('2016-08-24T12:13:14', default, 'PST')   # 2016-08-24 20:13:14.000 UTC\n\n```\n\n### Conversion to Type\n\nA new `Type` can be create from its `String` representation.\n\n**Example:** Creating a type from a string\n\n```puppet\n$t = Type.new('Integer[10]')\n```\n\n### Conversion to String\n\nConversion to `String` is the most comprehensive conversion as there are many\nuse cases where a string representation is wanted. The defaults for the many options\nhave been chosen with care to be the most basic \"value in textual form\" representation.\nThe more advanced forms of formatting are intended to enable writing special purposes formatting\nfunctions in the Puppet language.\n\nA new string can be created from all other data types. The process is performed in\nseveral steps - first the data type of the given value is inferred, then the resulting data type\nis used to find the most significant format specified for that data type. And finally,\nthe found format is used to convert the given value.\n\nThe mapping from data type to format is referred to as the *format map*. This map\nallows different formatting depending on type.\n\n**Example:** Positive Integers in Hexadecimal prefixed with '0x', negative in Decimal\n\n```puppet\n$format_map = {\n  Integer[default, 0] => \"%d\",\n  Integer[1, default] => \"%#x\"\n}\nString(\"-1\", $format_map)  # produces '-1'\nString(\"10\", $format_map)  # produces '0xa'\n```\n\nA format is specified on the form:\n\n```\n%[Flags][Width][.Precision]Format\n```\n\n`Width` is the number of characters into which the value should be fitted. This allocated space is\npadded if value is shorter. By default it is space padded, and the flag `0` will cause padding with `0`\nfor numerical formats.\n\n`Precision` is the number of fractional digits to show for floating point, and the maximum characters\nincluded in a string format.\n\nNote that all data type supports the formats `s` and `p` with the meaning \"default string representation\" and\n\"default programmatic string representation\" (which for example means that a String is quoted in 'p' format).\n\n#### Signatures of String conversion\n\n```puppet\ntype Format = Pattern[/^%([\\s\\+\\-#0\\[\\{<\\(\\|]*)([1-9][0-9]*)?(?:\\.([0-9]+))?([a-zA-Z])/]\ntype ContainerFormat = Struct[{\n  format         => Optional[String],\n  separator      => Optional[String],\n  separator2     => Optional[String],\n  string_formats => Hash[Type, Format]\n  }]\ntype TypeMap = Hash[Type, Variant[Format, ContainerFormat]]\ntype Formats = Variant[Default, String[1], TypeMap]\n\nfunction String.new(\n  Any $value,\n  Formats $string_formats\n)\n```\n\nWhere:\n\n* `separator` is the string used to separate entries in an array, or hash (extra space should not be included at\n  the end), defaults to `\",\"`\n* `separator2` is the separator between key and value in a hash entry (space padding should be included as\n  wanted), defaults to `\" => \"`.\n* `string_formats` is a data type to format map for values contained in arrays and hashes - defaults to `{Any => \"%p\"}`. Note that\n  these nested formats are not applicable to data types that are containers; they are always formatted as per the top level\n  format specification.\n\n**Example:** Simple Conversion to String (using defaults)\n\n```puppet\n$str = String(10)      # produces '10'\n$str = String([10])    # produces '[\"10\"]'\n```\n\n**Example:** Simple Conversion to String specifying the format for the given value directly\n\n```puppet\n$str = String(10, \"%#x\")    # produces '0x10'\n$str = String([10], \"%(a\")  # produces '(\"10\")'\n```\n\n**Example:** Specifying type for values contained in an array\n\n```puppet\n$formats = {\n  Array => {\n    format => '%(a',\n    string_formats => { Integer => '%#x' }\n  }\n}\n$str = String([1,2,3], $formats) # produces '(0x1, 0x2, 0x3)'\n```\n\nThe given formats are merged with the default formats, and matching of values to convert against format is based on\nthe specificity of the mapped type; for example, different formats can be used for short and long arrays.\n\n#### Integer to String\n\n| Format  | Integer Formats\n| ------  | ---------------\n| d       | Decimal, negative values produces leading '-'.\n| x X     | Hexadecimal in lower or upper case. Uses ..f/..F for negative values unless + is also used. A `#` adds prefix 0x/0X.\n| o       | Octal. Uses ..0 for negative values unless `+` is also used. A `#` adds prefix 0.\n| b B     | Binary with prefix 'b' or 'B'. Uses ..1/..1 for negative values unless `+` is also used.\n| c       | Numeric value representing a Unicode value, result is a one unicode character string, quoted if alternative flag # is used\n| s       | Same as d, or d in quotes if alternative flag # is used.\n| p       | Same as d.\n| eEfgGaA | Converts integer to float and formats using the floating point rules.\n\nDefaults to `d`.\n\n#### Float to String\n\n| Format  | Float formats\n| ------  | -------------\n| f       | Floating point in non exponential notation.\n| e E     | Exponential notation with 'e' or 'E'.\n| g G     | Conditional exponential with 'e' or 'E' if exponent < -4 or >= the precision.\n| a A     | Hexadecimal exponential form, using 'x'/'X' as prefix and 'p'/'P' before exponent.\n| s       | Converted to string using format p, then applying string formatting rule, alternate form # quotes result.\n| p       | Same as f format with minimum significant number of fractional digits, prec has no effect.\n| dxXobBc | Converts float to integer and formats using the integer rules.\n\nDefaults to `p`.\n\n#### String to String\n\n| Format | String\n| ------ | ------\n| s      | Unquoted string, verbatim output of control chars.\n| p      | Programmatic representation - strings are quoted, interior quotes and control chars are escaped.\n| C      | Each `::` name segment capitalized, quoted if alternative flag `#` is used.\n| c      | Capitalized string, quoted if alternative flag `#` is used.\n| d      | Downcased string, quoted if alternative flag `#` is used.\n| u      | Upcased string, quoted if alternative flag `#` is used.\n| t      | Trims leading and trailing whitespace from the string, quoted if alternative flag `#` is used.\n\nDefaults to `s` at top level and `p` inside array or hash.\n\n#### Boolean to String\n\n| Format    | Boolean Formats\n| ----      | -------------------\n| t T       | String 'true'/'false' or 'True'/'False', first char if alternate form is used (i.e. 't'/'f' or 'T'/'F').\n| y Y       | String 'yes'/'no', 'Yes'/'No', 'y'/'n' or 'Y'/'N' if alternative flag `#` is used.\n| dxXobB    | Numeric value 0/1 in accordance with the given format which must be valid integer format.\n| eEfgGaA   | Numeric value 0.0/1.0 in accordance with the given float format and flags.\n| s         | String 'true' / 'false'.\n| p         | String 'true' / 'false'.\n\n#### Regexp to String\n\n| Format    | Regexp Formats\n| ----      | --------------\n| s         | No delimiters, quoted if alternative flag `#` is used.\n| p         | Delimiters `/ /`.\n\n#### Undef to String\n\n| Format    | Undef formats\n| ------    | -------------\n| s         | Empty string, or quoted empty string if alternative flag `#` is used.\n| p         | String 'undef', or quoted '\"undef\"' if alternative flag `#` is used.\n| n         | String 'nil', or 'null' if alternative flag `#` is used.\n| dxXobB    | String 'NaN'.\n| eEfgGaA   | String 'NaN'.\n| v         | String 'n/a'.\n| V         | String 'N/A'.\n| u         | String 'undef', or 'undefined' if alternative `#` flag is used.\n\n#### Default value to String\n\n| Format    | Default formats\n| ------    | ---------------\n| d D       | String 'default' or 'Default', alternative form `#` causes value to be quoted.\n| s         | Same as d.\n| p         | Same as d.\n\n#### Binary value to String\n\n| Format    | Default formats\n| ------    | ---------------\n| s         | binary as unquoted UTF-8 characters (errors if byte sequence is invalid UTF-8). Alternate form escapes non ascii bytes.\n| p         | 'Binary(\"<base64strict>\")'\n| b         | '<base64>' - base64 string with newlines inserted\n| B         | '<base64strict>' - base64 strict string (without newlines inserted)\n| u         | '<base64urlsafe>' - base64 urlsafe string\n| t         | 'Binary' - outputs the name of the type only\n| T         | 'BINARY' - output the name of the type in all caps only\n\n* The alternate form flag `#` will quote the binary or base64 text output.\n* The format `%#s` allows invalid UTF-8 characters and outputs all non ascii bytes\n  as hex escaped characters on the form `\\\\xHH` where `H` is a hex digit.\n* The width and precision values are applied to the text part only in `%p` format.\n\n#### Array & Tuple to String\n\n| Format    | Array/Tuple Formats\n| ------    | -------------\n| a         | Formats with `[ ]` delimiters and `,`, alternate form `#` indents nested arrays/hashes.\n| s         | Same as a.\n| p         | Same as a.\n\nSee \"Flags\" `<[({\\|` for formatting of delimiters, and \"Additional parameters for containers; Array and Hash\" for\nmore information about options.\n\nThe alternate form flag `#` will cause indentation of nested array or hash containers. If width is also set\nit is taken as the maximum allowed length of a sequence of elements (not including delimiters). If this max length\nis exceeded, each element will be indented.\n\n#### Hash & Struct to String\n\n| Format    | Hash/Struct Formats\n| ------    | -------------\n| h         | Formats with `{ }` delimiters, `,` element separator and ` => ` inner element separator unless overridden by flags.\n| s         | Same as h.\n| p         | Same as h.\n| a         | Converts the hash to an array of [k,v] tuples and formats it using array rule(s).\n\nSee \"Flags\" `<[({\\|` for formatting of delimiters, and \"Additional parameters for containers; Array and Hash\" for\nmore information about options.\n\nThe alternate form flag `#` will format each hash key/value entry indented on a separate line.\n\n#### Type to String\n\n| Format    | Array/Tuple Formats\n| ------    | -------------\n| s         | The same as `p`, quoted if alternative flag `#` is used.\n| p         | Outputs the type in string form as specified by the Puppet Language.\n\n#### Flags\n\n| Flag     | Effect\n| ------   | ------\n| (space)  | A space instead of `+` for numeric output (`-` is shown), for containers skips delimiters.\n| #        | Alternate format; prefix 0x/0x, 0 (octal) and 0b/0B for binary, Floats force decimal '.'. For g/G keep trailing 0.\n| +        | Show sign +/- depending on value's sign, changes x, X, o, b, B format to not use 2's complement form.\n| -        | Left justify the value in the given width.\n| 0        | Pad with 0 instead of space for widths larger than value.\n| <[({\\|   | Defines an enclosing pair <> [] () {} or \\| \\| when used with a container type.\n\n### Conversion to Boolean\n\nAccepts a single value as argument:\n\n* Float 0.0 is `false`, all other float values are `true`\n* Integer 0 is `false`, all other integer values are `true`\n* Strings\n  * `true` if 'true', 'yes', 'y' (case independent compare)\n  * `false` if 'false', 'no', 'n' (case independent compare)\n* Boolean is already boolean and is simply returned\n\n### Conversion to Array and Tuple\n\nWhen given a single value as argument:\n\n* A non empty `Hash` is converted to an array matching `Array[Tuple[Any,Any], 1]`.\n* An empty `Hash` becomes an empty array.\n* An `Array` is simply returned.\n* An `Iterable[T]` is turned into an array of `T` instances.\n* A `Binary` is converted to an `Array[Integer[0,255]]` of byte values\n\n\nWhen given a second Boolean argument:\n\n* if `true`, a value that is not already an array is returned as a one element array.\n* if `false`, (the default), converts the first argument as shown above.\n\n**Example:** Ensuring value is an array\n\n```puppet\n$arr = Array($value, true)\n```\n\nConversion to a `Tuple` works exactly as conversion to an `Array`, only that the constructed array is\nasserted against the given tuple type.\n\n### Conversion to Hash and Struct\n\nAccepts a single value as argument:\n\n* An empty `Array` becomes an empty `Hash`\n* An `Array` matching `Array[Tuple[Any,Any], 1]` is converted to a hash where each tuple describes a key/value entry\n* An `Array` with an even number of entries is interpreted as `[key1, val1, key2, val2, ...]`\n* An `Iterable` is turned into an `Array` and then converted to hash as per the array rules\n* A `Hash` is simply returned\n\nAlternatively, a tree can be constructed by giving two values; an array of tuples on the form `[path, value]`\n(where the `path` is the path from the root of a tree, and `value` the value at that position in the tree), and\neither the option `'tree'` (do not convert arrays to hashes except the top level), or\n`'hash_tree'` (convert all arrays to hashes).\n\nThe tree/hash_tree forms of Hash creation are suited for transforming the result of an iteration\nusing `tree_each` and subsequent filtering or mapping.\n\n**Example:** Mapping a hash tree\n\nMapping an arbitrary structure in a way that keeps the structure, but where some values are replaced\ncan be done by using the `tree_each` function, mapping, and then constructing a new Hash from the result:\n\n```puppet\n# A hash tree with 'water' at different locations\n$h = { a => { b => { x => 'water'}}, b => { y => 'water'} }\n# a helper function that turns water into wine\nfunction make_wine($x) { if $x == 'water' { 'wine' } else { $x } }\n# create a flattened tree with water turned into wine\n$flat_tree = $h.tree_each.map |$entry| { [$entry[0], make_wine($entry[1])] }\n# create a new Hash and log it\nnotice Hash($flat_tree, 'hash_tree')\n```\n\nWould notice the hash `{a => {b => {x => wine}}, b => {y => wine}}`\n\nConversion to a `Struct` works exactly as conversion to a `Hash`, only that the constructed hash is\nasserted against the given struct type.\n\n### Conversion to a Regexp\n\nA `String` can be converted into a `Regexp`\n\n**Example**: Converting a String into a Regexp\n```puppet\n$s = '[a-z]+\\.com'\n$r = Regexp($s)\nif('foo.com' =~ $r) {\n  ...\n}\n```\n\n### Creating a SemVer\n\nA SemVer object represents a single [Semantic Version](http://semver.org/).\nIt can be created from a String, individual values for its parts, or a hash specifying the value per part.\nSee the specification at [semver.org](http://semver.org/) for the meaning of the SemVer's parts.\n\nThe signatures are:\n\n```puppet\ntype PositiveInteger = Integer[0,default]\ntype SemVerQualifier = Pattern[/\\A(?<part>[0-9A-Za-z-]+)(?:\\.\\g<part>)*\\Z/]\ntype SemVerString = String[1]\ntype SemVerHash =Struct[{\n  major                => PositiveInteger,\n  minor                => PositiveInteger,\n  patch                => PositiveInteger,\n  Optional[prerelease] => SemVerQualifier,\n  Optional[build]      => SemVerQualifier\n}]\n\nfunction SemVer.new(SemVerString $str)\n\nfunction SemVer.new(\n        PositiveInteger           $major\n        PositiveInteger           $minor\n        PositiveInteger           $patch\n        Optional[SemVerQualifier] $prerelease = undef\n        Optional[SemVerQualifier] $build = undef\n        )\n\nfunction SemVer.new(SemVerHash $hash_args)\n```\n\n**Examples:** SemVer and SemVerRange usage\n\n```puppet\n# As a type, SemVer can describe disjunct ranges which versions can be\n# matched against - here the type is constructed with two\n# SemVerRange objects.\n#\n$t = SemVer[\n  SemVerRange('>=1.0.0 <2.0.0'),\n  SemVerRange('>=3.0.0 <4.0.0')\n]\nnotice(SemVer('1.2.3') =~ $t) # true\nnotice(SemVer('2.3.4') =~ $t) # false\nnotice(SemVer('3.4.5') =~ $t) # true\n```\n\n### Creating a SemVerRange\n\nA `SemVerRange` object represents a range of `SemVer`. It can be created from\na `String`, or from two `SemVer` instances, where either end can be given as\na literal `default` to indicate infinity. The string format of a `SemVerRange` is specified by\nthe [Semantic Version Range Grammar](https://github.com/npm/node-semver#ranges).\n\n> Use of the comparator sets described in the grammar (joining with `||`) is not supported.\n\nThe signatures are:\n\n```puppet\ntype SemVerRangeString = String[1]\ntype SemVerRangeHash = Struct[{\n  min                   => Variant[Default, SemVer],\n  Optional[max]         => Variant[Default, SemVer],\n  Optional[exclude_max] => Boolean\n}]\n\nfunction SemVerRange.new(\n  SemVerRangeString $semver_range_string\n)\n\nfunction SemVerRange.new(\n  Variant[Default,SemVer] $min\n  Variant[Default,SemVer] $max\n  Optional[Boolean]       $exclude_max = undef\n)\n\nfunction SemVerRange.new(\n  SemVerRangeHash $semver_range_hash\n)\n```\n\nFor examples of `SemVerRange` use, see \"Creating a SemVer\".\n\n### Creating a Binary\n\nA `Binary` object represents a sequence of bytes and it can be created from a String in Base64 format,\nan Array containing byte values. A Binary can also be created from a Hash containing the value to convert to\na `Binary`.\n\nThe signatures are:\n\n```puppet\ntype ByteInteger = Integer[0,255]\ntype Base64Format = Enum[\"%b\", \"%u\", \"%B\", \"%s\"]\ntype StringHash = Struct[{value => String, \"format\" => Optional[Base64Format]}]\ntype ArrayHash = Struct[{value => Array[ByteInteger]}]\ntype BinaryArgsHash = Variant[StringHash, ArrayHash]\n\nfunction Binary.new(\n  String $base64_str,\n  Optional[Base64Format] $format\n)\n\nfunction Binary.new(\n  Array[ByteInteger] $byte_array\n}\n\n# Same as for String, or for Array, but where arguments are given in a Hash.\nfunction Binary.new(BinaryArgsHash $hash_args)\n```\n\nThe formats have the following meaning:\n\n| format | explanation |\n| ----   | ----        |\n| B | The data is in base64 strict encoding\n| u | The data is in URL safe base64 encoding\n| b | The data is in base64 encoding, padding as required by base64 strict, is added by default\n| s | The data is a puppet string. The string must be valid UTF-8, or convertible to UTF-8 or an error is raised.\n| r | (Ruby Raw) the byte sequence in the given string is used verbatim irrespective of possible encoding errors\n\n* The default format is `%B`.\n* Note that the format `%r` should be used sparingly, or not at all. It exists for backwards compatibility reasons when someone receiving\n  a string from some function and that string should be treated as Binary. Such code should be changed to return a Binary instead of a String.\n\n**Examples:** Creating a Binary\n\n```puppet\n# create the binary content \"abc\"\n$a = Binary('YWJj')\n\n# create the binary content from content in a module's file\n$b = binary_file('mymodule/mypicture.jpg')\n```\n\n* Since 4.5.0\n* Binary type since 4.8.0\n\nCreating an instance of a `Type` using the `Init` type.\n-------\n\nThe type `Init[T]` describes a value that can be used when instantiating a type. When used as the first argument in a call to `new`, it\nwill dispatch the call to its contained type and optionally augment the parameter list with additional arguments.\n\n**Example:** Creating an instance of Integer using Init[Integer]\n\n```puppet\n# The following declaration\n$x = Init[Integer].new('128')\n# is exactly the same as\n$x = Integer.new('128')\n```\n\nor, with base 16 and using implicit new\n\n```puppet\n# The following declaration\n$x = Init[Integer,16]('80')\n# is exactly the same as\n$x = Integer('80', 16)\n```\n\n**Example:** Creating an instance of String using a predefined format\n\n```puppet\n$fmt = Init[String,'%#x']\nnotice($fmt(256)) # will notice '0x100'\n```\n\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('new')\nend"
    },
    {
      "name"=>"next",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/next.rb",
      "line"=>6,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"next(Optional[Any] $value)",
          "docstring"=>{
            "text"=>"Makes iteration continue with the next value, optionally with a given value for this iteration.\nIf a value is not given it defaults to `undef`",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Any]"
                ],
                "name"=>"value"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Makes iteration continue with the next value, optionally with a given value for this iteration.\nIf a value is not given it defaults to `undef`",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Any]"
            ],
            "name"=>"value"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.7.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:next) do\n  dispatch :next_impl do\n    optional_param 'Any', :value\n  end\n\n  def next_impl(value = nil)\n    file, line = Puppet::Pops::PuppetStack.top_of_stack\n    exc = Puppet::Pops::Evaluator::Next.new(value, file, line)\n    raise exc\n  end\nend"
    },
    {
      "name"=>"next",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/next.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"next()",
          "docstring"=>{
            "text"=>"Immediately returns the given optional value from a block (lambda), function, class body or user defined type body.\nIf a value is not given, an `undef` value is returned. This function does not return to the immediate caller.\n\nThe signal produced to return a value bubbles up through\nthe call stack until reaching a code block (lambda), function, class definition or\ndefinition of a user defined type at which point the value given to the function will\nbe produced as the result of that body of code. An error is raised\nif the signal to return a value reaches the end of the call stack.\n\n**Example:** Using `next` in `each`\n\n```puppet\n$data = [1,2,3]\n$data.each |$x| { if $x == 2 { next() } notice $x }\n```\n\nWould notice the values `1` and `3`\n\n**Example:** Using `next` to produce a value\n\nIf logic consists of deeply nested conditionals it may be complicated to get out of the innermost conditional.\nA call to `next` can then simplify the logic. This example however, only shows the principle.\n```puppet\n$data = [1,2,3]\nnotice $data.map |$x| { if $x == 2 { next($x*100) }; $x*10 }\n```\nWould notice the value `[10, 200, 30]`\n\n* Also see functions `return` and `break`\n* Since 4.8.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Immediately returns the given optional value from a block (lambda), function, class body or user defined type body.\nIf a value is not given, an `undef` value is returned. This function does not return to the immediate caller.\n\nThe signal produced to return a value bubbles up through\nthe call stack until reaching a code block (lambda), function, class definition or\ndefinition of a user defined type at which point the value given to the function will\nbe produced as the result of that body of code. An error is raised\nif the signal to return a value reaches the end of the call stack.\n\n**Example:** Using `next` in `each`\n\n```puppet\n$data = [1,2,3]\n$data.each |$x| { if $x == 2 { next() } notice $x }\n```\n\nWould notice the values `1` and `3`\n\n**Example:** Using `next` to produce a value\n\nIf logic consists of deeply nested conditionals it may be complicated to get out of the innermost conditional.\nA call to `next` can then simplify the logic. This example however, only shows the principle.\n```puppet\n$data = [1,2,3]\nnotice $data.map |$x| { if $x == 2 { next($x*100) }; $x*10 }\n```\nWould notice the value `[10, 200, 30]`\n\n* Also see functions `return` and `break`\n* Since 4.8.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :next,\n  :arity => -2,\n  :doc => <<-DOC\nImmediately returns the given optional value from a block (lambda), function, class body or user defined type body.\nIf a value is not given, an `undef` value is returned. This function does not return to the immediate caller.\n\nThe signal produced to return a value bubbles up through\nthe call stack until reaching a code block (lambda), function, class definition or\ndefinition of a user defined type at which point the value given to the function will\nbe produced as the result of that body of code. An error is raised\nif the signal to return a value reaches the end of the call stack.\n\n**Example:** Using `next` in `each`\n\n```puppet\n$data = [1,2,3]\n$data.each |$x| { if $x == 2 { next() } notice $x }\n```\n\nWould notice the values `1` and `3`\n\n**Example:** Using `next` to produce a value\n\nIf logic consists of deeply nested conditionals it may be complicated to get out of the innermost conditional.\nA call to `next` can then simplify the logic. This example however, only shows the principle.\n```puppet\n$data = [1,2,3]\nnotice $data.map |$x| { if $x == 2 { next($x*100) }; $x*10 }\n```\nWould notice the value `[10, 200, 30]`\n\n* Also see functions `return` and `break`\n* Since 4.8.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('next')\nend"
    },
    {
      "name"=>"notice",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/notice.rb",
      "line"=>2,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"notice(Any *$values)",
          "docstring"=>{
            "text"=>"Logs a message on the server at level `notice`.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"The values to log.",
                "types"=>[
                  "Any"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Undef"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Logs a message on the server at level `notice`.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"The values to log.",
            "types"=>[
              "Any"
            ],
            "name"=>"*values"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Undef"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:notice, Puppet::Functions::InternalFunction) do\n  # @param values The values to log.\n  # @return [Undef]\n  dispatch :notice do\n    scope_param\n    repeated_param 'Any', :values\n    return_type 'Undef'\n  end\n\n  def notice(scope, *values)\n    Puppet::Util::Log.log_func(scope, :notice, values)\n  end\nend"
    },
    {
      "name"=>"partition",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/partition.rb",
      "line"=>5,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"partition(Collection $collection, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"['', b, c].partition |$s| { $s.empty }",
                "name"=>"Partition array of empty strings, results in e.g. [[''], [b, c]]"
              },
              {
                "tag_name"=>"example",
                "text"=>"['', b, ab].partition |$i, $s| { $i == 2 or $s.empty }",
                "name"=>"Partition array of strings using index, results in e.g. [['', 'ab'], ['b']]"
              },
              {
                "tag_name"=>"example",
                "text"=>"{ a => [1, 2], b => [] }.partition |$kv| { $kv[1].empty }",
                "name"=>"Partition hash of strings by key-value pair, results in e.g. [[['b', []]], [['a', [1, 2]]]]"
              },
              {
                "tag_name"=>"example",
                "text"=>"{ a => [1, 2], b => [] }.partition |$k, $v| { $v.empty }",
                "name"=>"Partition hash of strings by key and value, results in e.g. [[['b', []]], [['a', [1, 2]]]]"
              },
              {
                "tag_name"=>"param",
                "text"=>"A collection of things to partition.",
                "types"=>[
                  "Collection"
                ],
                "name"=>"collection"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Tuple[Array, Array]"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"partition(Array $array, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array"
                ],
                "name"=>"array"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Tuple[Array, Array]"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"partition(Collection $collection, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Collection"
                ],
                "name"=>"collection"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Tuple[Array, Array]"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns two arrays, the first containing the elements of enum for which the block evaluates to true,\nthe second containing the rest.",
        "tags"=>[
          {
            "tag_name"=>"overload",
            "signature"=>"partition(Collection $collection, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"example",
                  "text"=>"['', b, c].partition |$s| { $s.empty }",
                  "name"=>"Partition array of empty strings, results in e.g. [[''], [b, c]]"
                },
                {
                  "tag_name"=>"example",
                  "text"=>"['', b, ab].partition |$i, $s| { $i == 2 or $s.empty }",
                  "name"=>"Partition array of strings using index, results in e.g. [['', 'ab'], ['b']]"
                },
                {
                  "tag_name"=>"example",
                  "text"=>"{ a => [1, 2], b => [] }.partition |$kv| { $kv[1].empty }",
                  "name"=>"Partition hash of strings by key-value pair, results in e.g. [[['b', []]], [['a', [1, 2]]]]"
                },
                {
                  "tag_name"=>"example",
                  "text"=>"{ a => [1, 2], b => [] }.partition |$k, $v| { $v.empty }",
                  "name"=>"Partition hash of strings by key and value, results in e.g. [[['b', []]], [['a', [1, 2]]]]"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"A collection of things to partition.",
                  "types"=>[
                    "Collection"
                  ],
                  "name"=>"collection"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Tuple[Array, Array]"
                  ]
                }
              ]
            },
            "name"=>"partition"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"partition(Array $array, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array"
                  ],
                  "name"=>"array"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Tuple[Array, Array]"
                  ]
                }
              ]
            },
            "name"=>"partition"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"partition(Collection $collection, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Collection"
                  ],
                  "name"=>"collection"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Tuple[Array, Array]"
                  ]
                }
              ]
            },
            "name"=>"partition"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:partition) do\n  # @param collection A collection of things to partition.\n  # @example Partition array of empty strings, results in e.g. [[''], [b, c]]\n  #   ['', b, c].partition |$s| { $s.empty }\n  # @example Partition array of strings using index, results in e.g. [['', 'ab'], ['b']]\n  #   ['', b, ab].partition |$i, $s| { $i == 2 or $s.empty }\n  # @example Partition hash of strings by key-value pair, results in e.g. [[['b', []]], [['a', [1, 2]]]]\n  #   { a => [1, 2], b => [] }.partition |$kv| { $kv[1].empty }\n  # @example Partition hash of strings by key and value, results in e.g. [[['b', []]], [['a', [1, 2]]]]\n  #   { a => [1, 2], b => [] }.partition |$k, $v| { $v.empty }\n  dispatch :partition_1 do\n    required_param 'Collection', :collection\n    block_param 'Callable[1,1]', :block\n    return_type 'Tuple[Array, Array]'\n  end\n\n  dispatch :partition_2a do\n    required_param 'Array', :array\n    block_param 'Callable[2,2]', :block\n    return_type 'Tuple[Array, Array]'\n  end\n\n  dispatch :partition_2 do\n    required_param 'Collection', :collection\n    block_param 'Callable[2,2]', :block\n    return_type 'Tuple[Array, Array]'\n  end\n\n  def partition_1(collection)\n    collection.partition do |item|\n      yield(item)\n    end.freeze\n  end\n\n  def partition_2a(array)\n    partitioned = array.size.times.zip(array).partition do |k, v|\n      yield(k, v)\n    end\n\n    partitioned.map do |part|\n      part.map { |item| item[1] }\n    end.freeze\n  end\n\n  def partition_2(collection)\n    collection.partition do |k, v|\n      yield(k, v)\n    end.freeze\n  end\nend"
    },
    {
      "name"=>"realize",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/realize.rb",
      "line"=>4,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"realize()",
          "docstring"=>{
            "text"=>"Make a virtual object real.  This is useful\nwhen you want to know the name of the virtual object and don't want to\nbother with a full collection.  It is slightly faster than a collection,\nand, of course, is a bit shorter.  You must pass the object using a\nreference; e.g.: `realize User[luke]`.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Make a virtual object real.  This is useful\nwhen you want to know the name of the virtual object and don't want to\nbother with a full collection.  It is slightly faster than a collection,\nand, of course, is a bit shorter.  You must pass the object using a\nreference; e.g.: `realize User[luke]`.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:realize, :arity => -2, :doc => \"Make a virtual object real.  This is useful\n    when you want to know the name of the virtual object and don't want to\n    bother with a full collection.  It is slightly faster than a collection,\n    and, of course, is a bit shorter.  You must pass the object using a\n    reference; e.g.: `realize User[luke]`.\" ) do |vals|\n\n    if Puppet[:tasks]\n      raise Puppet::ParseErrorWithIssue.from_issue_and_stack(\n        Puppet::Pops::Issues::CATALOG_OPERATION_NOT_SUPPORTED_WHEN_SCRIPTING,\n        {:operation => 'realize'})\n    end\n\n    vals = [vals] unless vals.is_a?(Array)\n\n    coll = Puppet::Pops::Evaluator::Collectors::FixedSetCollector.new(self, vals.flatten)\n    compiler.add_collection(coll)\nend"
    },
    {
      "name"=>"reduce",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/reduce.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"reduce()",
          "docstring"=>{
            "text"=>"Applies a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nto every value in a data structure from the first argument, carrying over the returned\nvalue of each iteration, and returns the result of the lambda's final iteration. This\nlets you create a new value or data structure by combining values from the first\nargument's data structure.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array or hash the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It takes\ntwo mandatory parameters:\n    1. A memo value that is overwritten after each iteration with the iteration's result.\n    2. A second value that is overwritten after each iteration with the next value in the\n    function's first argument.\n\n**Example**: Using the `reduce` function\n\n`$data.reduce |$memo, $value| { ... }`\n\nor\n\n`reduce($data) |$memo, $value| { ... }`\n\nYou can also pass an optional \"start memo\" value as an argument, such as `start` below:\n\n`$data.reduce(start) |$memo, $value| { ... }`\n\nor\n\n`reduce($data, start) |$memo, $value| { ... }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nof the data structure's values in turn to the lambda's parameters. When the first\nargument is a hash, Puppet converts each of the hash's values to an array in the form\n`[key, value]`.\n\nIf you pass a start memo value, Puppet executes the lambda with the provided memo value\nand the data structure's first value. Otherwise, Puppet passes the structure's first two\nvalues to the lambda.\n\nPuppet calls the lambda for each of the data structure's remaining values. For each\ncall, it passes the result of the previous call as the first parameter ($memo in the\nabove examples) and the next value from the data structure as the second parameter\n($value).\n\nIf the structure has one value, Puppet returns the value and does not call the lambda.\n\n**Example**: Using the `reduce` function\n\n~~~ puppet\n# Reduce the array $data, returning the sum of all values in the array.\n$data = [1, 2, 3]\n$sum = $data.reduce |$memo, $value| { $memo + $value }\n# $sum contains 6\n\n# Reduce the array $data, returning the sum of a start memo value and all values in the\n# array.\n$data = [1, 2, 3]\n$sum = $data.reduce(4) |$memo, $value| { $memo + $value }\n# $sum contains 10\n\n# Reduce the hash $data, returning the sum of all values and concatenated string of all\n# keys.\n$data = {a => 1, b => 2, c => 3}\n$combine = $data.reduce |$memo, $value| {\n  $string = \"${memo[0]}${value[0]}\"\n  $number = $memo[1] + $value[1]\n  [$string, $number]\n}\n# $combine contains [abc, 6]\n~~~\n\n**Example**: Using the `reduce` function with a start memo and two-parameter lambda\n\n~~~ puppet\n# Reduce the array $data, returning the sum of all values in the array and starting\n# with $memo set to an arbitrary value instead of $data's first value.\n$data = [1, 2, 3]\n$sum = $data.reduce(4) |$memo, $value| { $memo + $value }\n# At the start of the lambda's first iteration, $memo contains 4 and $value contains 1.\n# After all iterations, $sum contains 10.\n\n# Reduce the hash $data, returning the sum of all values and concatenated string of\n# all keys, and starting with $memo set to an arbitrary array instead of $data's first\n# key-value pair.\n$data = {a => 1, b => 2, c => 3}\n$combine = $data.reduce( [d, 4] ) |$memo, $value| {\n  $string = \"${memo[0]}${value[0]}\"\n  $number = $memo[1] + $value[1]\n  [$string, $number]\n}\n# At the start of the lambda's first iteration, $memo contains [d, 4] and $value\n# contains [a, 1].\n# $combine contains [dabc, 10]\n~~~\n\n**Example**: Using the `reduce` function to reduce a hash of hashes\n\n~~~ puppet\n# Reduce a hash of hashes $data, merging defaults into the inner hashes.\n$data = {\n  'connection1' => {\n    'username' => 'user1',\n    'password' => 'pass1',\n  },\n  'connection_name2' => {\n    'username' => 'user2',\n    'password' => 'pass2',\n  },\n}\n\n$defaults = {\n  'maxActive' => '20',\n  'maxWait'   => '10000',\n  'username'  => 'defaultuser',\n  'password'  => 'defaultpass',\n}\n\n$merged = $data.reduce( {} ) |$memo, $x| {\n  $memo + { $x[0] => $defaults + $data[$x[0]] }\n}\n# At the start of the lambda's first iteration, $memo is set to {}, and $x is set to\n# the first [key, value] tuple. The key in $data is, therefore, given by $x[0]. In\n# subsequent rounds, $memo retains the value returned by the expression, i.e.\n# $memo + { $x[0] => $defaults + $data[$x[0]] }.\n~~~\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Applies a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nto every value in a data structure from the first argument, carrying over the returned\nvalue of each iteration, and returns the result of the lambda's final iteration. This\nlets you create a new value or data structure by combining values from the first\nargument's data structure.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array or hash the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It takes\ntwo mandatory parameters:\n    1. A memo value that is overwritten after each iteration with the iteration's result.\n    2. A second value that is overwritten after each iteration with the next value in the\n    function's first argument.\n\n**Example**: Using the `reduce` function\n\n`$data.reduce |$memo, $value| { ... }`\n\nor\n\n`reduce($data) |$memo, $value| { ... }`\n\nYou can also pass an optional \"start memo\" value as an argument, such as `start` below:\n\n`$data.reduce(start) |$memo, $value| { ... }`\n\nor\n\n`reduce($data, start) |$memo, $value| { ... }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nof the data structure's values in turn to the lambda's parameters. When the first\nargument is a hash, Puppet converts each of the hash's values to an array in the form\n`[key, value]`.\n\nIf you pass a start memo value, Puppet executes the lambda with the provided memo value\nand the data structure's first value. Otherwise, Puppet passes the structure's first two\nvalues to the lambda.\n\nPuppet calls the lambda for each of the data structure's remaining values. For each\ncall, it passes the result of the previous call as the first parameter ($memo in the\nabove examples) and the next value from the data structure as the second parameter\n($value).\n\nIf the structure has one value, Puppet returns the value and does not call the lambda.\n\n**Example**: Using the `reduce` function\n\n~~~ puppet\n# Reduce the array $data, returning the sum of all values in the array.\n$data = [1, 2, 3]\n$sum = $data.reduce |$memo, $value| { $memo + $value }\n# $sum contains 6\n\n# Reduce the array $data, returning the sum of a start memo value and all values in the\n# array.\n$data = [1, 2, 3]\n$sum = $data.reduce(4) |$memo, $value| { $memo + $value }\n# $sum contains 10\n\n# Reduce the hash $data, returning the sum of all values and concatenated string of all\n# keys.\n$data = {a => 1, b => 2, c => 3}\n$combine = $data.reduce |$memo, $value| {\n  $string = \"${memo[0]}${value[0]}\"\n  $number = $memo[1] + $value[1]\n  [$string, $number]\n}\n# $combine contains [abc, 6]\n~~~\n\n**Example**: Using the `reduce` function with a start memo and two-parameter lambda\n\n~~~ puppet\n# Reduce the array $data, returning the sum of all values in the array and starting\n# with $memo set to an arbitrary value instead of $data's first value.\n$data = [1, 2, 3]\n$sum = $data.reduce(4) |$memo, $value| { $memo + $value }\n# At the start of the lambda's first iteration, $memo contains 4 and $value contains 1.\n# After all iterations, $sum contains 10.\n\n# Reduce the hash $data, returning the sum of all values and concatenated string of\n# all keys, and starting with $memo set to an arbitrary array instead of $data's first\n# key-value pair.\n$data = {a => 1, b => 2, c => 3}\n$combine = $data.reduce( [d, 4] ) |$memo, $value| {\n  $string = \"${memo[0]}${value[0]}\"\n  $number = $memo[1] + $value[1]\n  [$string, $number]\n}\n# At the start of the lambda's first iteration, $memo contains [d, 4] and $value\n# contains [a, 1].\n# $combine contains [dabc, 10]\n~~~\n\n**Example**: Using the `reduce` function to reduce a hash of hashes\n\n~~~ puppet\n# Reduce a hash of hashes $data, merging defaults into the inner hashes.\n$data = {\n  'connection1' => {\n    'username' => 'user1',\n    'password' => 'pass1',\n  },\n  'connection_name2' => {\n    'username' => 'user2',\n    'password' => 'pass2',\n  },\n}\n\n$defaults = {\n  'maxActive' => '20',\n  'maxWait'   => '10000',\n  'username'  => 'defaultuser',\n  'password'  => 'defaultpass',\n}\n\n$merged = $data.reduce( {} ) |$memo, $x| {\n  $memo + { $x[0] => $defaults + $data[$x[0]] }\n}\n# At the start of the lambda's first iteration, $memo is set to {}, and $x is set to\n# the first [key, value] tuple. The key in $data is, therefore, given by $x[0]. In\n# subsequent rounds, $memo retains the value returned by the expression, i.e.\n# $memo + { $x[0] => $defaults + $data[$x[0]] }.\n~~~\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :reduce,\n  :type => :rvalue,\n  :arity => -3,\n  :doc => <<-DOC\nApplies a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nto every value in a data structure from the first argument, carrying over the returned\nvalue of each iteration, and returns the result of the lambda's final iteration. This\nlets you create a new value or data structure by combining values from the first\nargument's data structure.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array or hash the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It takes\ntwo mandatory parameters:\n    1. A memo value that is overwritten after each iteration with the iteration's result.\n    2. A second value that is overwritten after each iteration with the next value in the\n    function's first argument.\n\n**Example**: Using the `reduce` function\n\n`$data.reduce |$memo, $value| { ... }`\n\nor\n\n`reduce($data) |$memo, $value| { ... }`\n\nYou can also pass an optional \"start memo\" value as an argument, such as `start` below:\n\n`$data.reduce(start) |$memo, $value| { ... }`\n\nor\n\n`reduce($data, start) |$memo, $value| { ... }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nof the data structure's values in turn to the lambda's parameters. When the first\nargument is a hash, Puppet converts each of the hash's values to an array in the form\n`[key, value]`.\n\nIf you pass a start memo value, Puppet executes the lambda with the provided memo value\nand the data structure's first value. Otherwise, Puppet passes the structure's first two\nvalues to the lambda.\n\nPuppet calls the lambda for each of the data structure's remaining values. For each\ncall, it passes the result of the previous call as the first parameter ($memo in the\nabove examples) and the next value from the data structure as the second parameter\n($value).\n\nIf the structure has one value, Puppet returns the value and does not call the lambda.\n\n**Example**: Using the `reduce` function\n\n~~~ puppet\n# Reduce the array $data, returning the sum of all values in the array.\n$data = [1, 2, 3]\n$sum = $data.reduce |$memo, $value| { $memo + $value }\n# $sum contains 6\n\n# Reduce the array $data, returning the sum of a start memo value and all values in the\n# array.\n$data = [1, 2, 3]\n$sum = $data.reduce(4) |$memo, $value| { $memo + $value }\n# $sum contains 10\n\n# Reduce the hash $data, returning the sum of all values and concatenated string of all\n# keys.\n$data = {a => 1, b => 2, c => 3}\n$combine = $data.reduce |$memo, $value| {\n  $string = \"${memo[0]}${value[0]}\"\n  $number = $memo[1] + $value[1]\n  [$string, $number]\n}\n# $combine contains [abc, 6]\n~~~\n\n**Example**: Using the `reduce` function with a start memo and two-parameter lambda\n\n~~~ puppet\n# Reduce the array $data, returning the sum of all values in the array and starting\n# with $memo set to an arbitrary value instead of $data's first value.\n$data = [1, 2, 3]\n$sum = $data.reduce(4) |$memo, $value| { $memo + $value }\n# At the start of the lambda's first iteration, $memo contains 4 and $value contains 1.\n# After all iterations, $sum contains 10.\n\n# Reduce the hash $data, returning the sum of all values and concatenated string of\n# all keys, and starting with $memo set to an arbitrary array instead of $data's first\n# key-value pair.\n$data = {a => 1, b => 2, c => 3}\n$combine = $data.reduce( [d, 4] ) |$memo, $value| {\n  $string = \"${memo[0]}${value[0]}\"\n  $number = $memo[1] + $value[1]\n  [$string, $number]\n}\n# At the start of the lambda's first iteration, $memo contains [d, 4] and $value\n# contains [a, 1].\n# $combine contains [dabc, 10]\n~~~\n\n**Example**: Using the `reduce` function to reduce a hash of hashes\n\n~~~ puppet\n# Reduce a hash of hashes $data, merging defaults into the inner hashes.\n$data = {\n  'connection1' => {\n    'username' => 'user1',\n    'password' => 'pass1',\n  },\n  'connection_name2' => {\n    'username' => 'user2',\n    'password' => 'pass2',\n  },\n}\n\n$defaults = {\n  'maxActive' => '20',\n  'maxWait'   => '10000',\n  'username'  => 'defaultuser',\n  'password'  => 'defaultpass',\n}\n\n$merged = $data.reduce( {} ) |$memo, $x| {\n  $memo + { $x[0] => $defaults + $data[$x[0]] }\n}\n# At the start of the lambda's first iteration, $memo is set to {}, and $x is set to\n# the first [key, value] tuple. The key in $data is, therefore, given by $x[0]. In\n# subsequent rounds, $memo retains the value returned by the expression, i.e.\n# $memo + { $x[0] => $defaults + $data[$x[0]] }.\n~~~\n\n- Since 4.0.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('reduce')\nend"
    },
    {
      "name"=>"reduce",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/reduce.rb",
      "line"=>128,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"reduce(Iterable $enumerable, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"reduce(Iterable $enumerable, Any $memo, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"memo"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Applies a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nto every value in a data structure from the first argument, carrying over the returned\nvalue of each iteration, and returns the result of the lambda's final iteration. This\nlets you create a new value or data structure by combining values from the first\nargument's data structure.\n\nThis function takes two mandatory arguments, in this order:\n\n1. An array, hash, or other iterable object that the function will iterate over.\n2. A lambda, which the function calls for each element in the first argument. It takes\ntwo mandatory parameters:\n    1. A memo value that is overwritten after each iteration with the iteration's result.\n    2. A second value that is overwritten after each iteration with the next value in the\n    function's first argument.\n\n`$data.reduce |$memo, $value| { ... }`\n\nor\n\n`reduce($data) |$memo, $value| { ... }`\n\nYou can also pass an optional \"start memo\" value as an argument, such as `start` below:\n\n`$data.reduce(start) |$memo, $value| { ... }`\n\nor\n\n`reduce($data, start) |$memo, $value| { ... }`\n\nWhen the first argument (`$data` in the above example) is an array, Puppet passes each\nof the data structure's values in turn to the lambda's parameters. When the first\nargument is a hash, Puppet converts each of the hash's values to an array in the form\n`[key, value]`.\n\nIf you pass a start memo value, Puppet executes the lambda with the provided memo value\nand the data structure's first value. Otherwise, Puppet passes the structure's first two\nvalues to the lambda.\n\nPuppet calls the lambda for each of the data structure's remaining values. For each\ncall, it passes the result of the previous call as the first parameter (`$memo` in the\nabove examples) and the next value from the data structure as the second parameter\n(`$value`).\n\n```puppet\n# Reduce the array $data, returning the sum of all values in the array.\n$data = [1, 2, 3]\n$sum = $data.reduce |$memo, $value| { $memo + $value }\n# $sum contains 6\n\n# Reduce the array $data, returning the sum of a start memo value and all values in the\n# array.\n$data = [1, 2, 3]\n$sum = $data.reduce(4) |$memo, $value| { $memo + $value }\n# $sum contains 10\n\n# Reduce the hash $data, returning the sum of all values and concatenated string of all\n# keys.\n$data = {a => 1, b => 2, c => 3}\n$combine = $data.reduce |$memo, $value| {\n  $string = \"${memo[0]}${value[0]}\"\n  $number = $memo[1] + $value[1]\n  [$string, $number]\n}\n# $combine contains [abc, 6]\n```\n\n```puppet\n# Reduce the array $data, returning the sum of all values in the array and starting\n# with $memo set to an arbitrary value instead of $data's first value.\n$data = [1, 2, 3]\n$sum = $data.reduce(4) |$memo, $value| { $memo + $value }\n# At the start of the lambda's first iteration, $memo contains 4 and $value contains 1.\n# After all iterations, $sum contains 10.\n\n# Reduce the hash $data, returning the sum of all values and concatenated string of\n# all keys, and starting with $memo set to an arbitrary array instead of $data's first\n# key-value pair.\n$data = {a => 1, b => 2, c => 3}\n$combine = $data.reduce( [d, 4] ) |$memo, $value| {\n  $string = \"${memo[0]}${value[0]}\"\n  $number = $memo[1] + $value[1]\n  [$string, $number]\n}\n# At the start of the lambda's first iteration, $memo contains [d, 4] and $value\n# contains [a, 1].\n# $combine contains [dabc, 10]\n```\n\n```puppet\n# Reduce a hash of hashes $data, merging defaults into the inner hashes.\n$data = {\n  'connection1' => {\n    'username' => 'user1',\n    'password' => 'pass1',\n  },\n  'connection_name2' => {\n    'username' => 'user2',\n    'password' => 'pass2',\n  },\n}\n\n$defaults = {\n  'maxActive' => '20',\n  'maxWait'   => '10000',\n  'username'  => 'defaultuser',\n  'password'  => 'defaultpass',\n}\n\n$merged = $data.reduce( {} ) |$memo, $x| {\n  $memo + { $x[0] => $defaults + $data[$x[0]] }\n}\n# At the start of the lambda's first iteration, $memo is set to {}, and $x is set to\n# the first [key, value] tuple. The key in $data is, therefore, given by $x[0]. In\n# subsequent rounds, $memo retains the value returned by the expression, i.e.\n# $memo + { $x[0] => $defaults + $data[$x[0]] }.\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `reduce` function"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `reduce` function"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `reduce` function with a start memo and two-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `reduce` function to reduce a hash of hashes"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"reduce(Iterable $enumerable, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"reduce"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"reduce(Iterable $enumerable, Any $memo, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"memo"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"reduce"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:reduce) do\n\n  dispatch :reduce_without_memo do\n    param 'Iterable', :enumerable\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :reduce_with_memo do\n    param 'Iterable', :enumerable\n    param 'Any', :memo\n    block_param 'Callable[2,2]', :block\n  end\n\n  def reduce_without_memo(enumerable)\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n    enum.reduce do |memo, x|\n      begin\n        yield(memo, x)\n      rescue StopIteration\n        return memo\n      end\n    end\n  end\n\n  def reduce_with_memo(enumerable, given_memo)\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n    enum.reduce(given_memo) do |memo, x|\n      begin\n        yield(memo, x)\n      rescue StopIteration\n        return memo\n      end\n    end\n  end\nend"
    },
    {
      "name"=>"regsubst",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/regsubst.rb",
      "line"=>28,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"regsubst()",
          "docstring"=>{
            "text"=>"Perform regexp replacement on a string or array of strings.\n\n* *Parameters* (in order):\n    * _target_  The string or array of strings to operate on.  If an array, the replacement will be performed on each of the elements in the array, and the return value will be an array.\n    * _regexp_  The regular expression matching the target string.  If you want it anchored at the start and or end of the string, you must do that with ^ and $ yourself.\n    * _replacement_  Replacement string. Can contain backreferences to what was matched using \\\\0 (whole match), \\\\1 (first set of parentheses), and so on.\n    * _flags_  Optional. String of single letter flags for how the regexp is interpreted:\n        - *E*         Extended regexps\n        - *I*         Ignore case in regexps\n        - *M*         Multiline regexps\n        - *G*         Global replacement; all occurrences of the regexp in each target string will be replaced.  Without this, only the first occurrence will be replaced.\n    * _encoding_  Optional.  How to handle multibyte characters.  A single-character string with the following values:\n        - *N*         None\n        - *E*         EUC\n        - *S*         SJIS\n        - *U*         UTF-8\n\n* *Examples*\n\nGet the third octet from the node's IP address:\n\n    $i3 = regsubst($ipaddress,'^(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)$','\\\\3')\n\nPut angle brackets around each octet in the node's IP address:\n\n    $x = regsubst($ipaddress, '([0-9]+)', '<\\\\1>', 'G')",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Perform regexp replacement on a string or array of strings.\n\n* *Parameters* (in order):\n    * _target_  The string or array of strings to operate on.  If an array, the replacement will be performed on each of the elements in the array, and the return value will be an array.\n    * _regexp_  The regular expression matching the target string.  If you want it anchored at the start and or end of the string, you must do that with ^ and $ yourself.\n    * _replacement_  Replacement string. Can contain backreferences to what was matched using \\\\0 (whole match), \\\\1 (first set of parentheses), and so on.\n    * _flags_  Optional. String of single letter flags for how the regexp is interpreted:\n        - *E*         Extended regexps\n        - *I*         Ignore case in regexps\n        - *M*         Multiline regexps\n        - *G*         Global replacement; all occurrences of the regexp in each target string will be replaced.  Without this, only the first occurrence will be replaced.\n    * _encoding_  Optional.  How to handle multibyte characters.  A single-character string with the following values:\n        - *N*         None\n        - *E*         EUC\n        - *S*         SJIS\n        - *U*         UTF-8\n\n* *Examples*\n\nGet the third octet from the node's IP address:\n\n    $i3 = regsubst($ipaddress,'^(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)$','\\\\3')\n\nPut angle brackets around each octet in the node's IP address:\n\n    $x = regsubst($ipaddress, '([0-9]+)', '<\\\\1>', 'G')",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"newfunction(\n  :regsubst, :type => :rvalue,\n  :arity => -4,\n\n  :doc => \"\nPerform regexp replacement on a string or array of strings.\n\n* *Parameters* (in order):\n    * _target_  The string or array of strings to operate on.  If an array, the replacement will be performed on each of the elements in the array, and the return value will be an array.\n    * _regexp_  The regular expression matching the target string.  If you want it anchored at the start and or end of the string, you must do that with ^ and $ yourself.\n    * _replacement_  Replacement string. Can contain backreferences to what was matched using \\\\0 (whole match), \\\\1 (first set of parentheses), and so on.\n    * _flags_  Optional. String of single letter flags for how the regexp is interpreted:\n        - *E*         Extended regexps\n        - *I*         Ignore case in regexps\n        - *M*         Multiline regexps\n        - *G*         Global replacement; all occurrences of the regexp in each target string will be replaced.  Without this, only the first occurrence will be replaced.\n    * _encoding_  Optional.  How to handle multibyte characters.  A single-character string with the following values:\n        - *N*         None\n        - *E*         EUC\n        - *S*         SJIS\n        - *U*         UTF-8\n\n* *Examples*\n\nGet the third octet from the node's IP address:\n\n    $i3 = regsubst($ipaddress,'^(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)$','\\\\3')\n\nPut angle brackets around each octet in the node's IP address:\n\n    $x = regsubst($ipaddress, '([0-9]+)', '<\\\\1>', 'G')\n\") do |args|\n    Error.is4x('regsubst')\nend"
    },
    {
      "name"=>"regsubst",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/regsubst.rb",
      "line"=>2,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"regsubst(Variant[Array[String],String] $target, String $pattern, Variant[String,Hash[String,String]] $replacement, Optional[Optional[Pattern[/^[GEIM]*$/]]] $flags, Optional[Enum['N','E','S','U']] $encoding)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"```puppet\n$i3 = regsubst($ipaddress,'^(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)$','\\\\3')\n```",
                "name"=>"Get the third octet from the node's IP address:"
              },
              {
                "tag_name"=>"param",
                "text"=>"The string or array of strings to operate on.  If an array, the replacement will be\nperformed on each of the elements in the array, and the return value will be an array.",
                "types"=>[
                  "Variant[Array[String],String]"
                ],
                "name"=>"target"
              },
              {
                "tag_name"=>"param",
                "text"=>"The regular expression matching the target string.  If you want it anchored at the start\nand or end of the string, you must do that with ^ and $ yourself.",
                "types"=>[
                  "String"
                ],
                "name"=>"pattern"
              },
              {
                "tag_name"=>"param",
                "text"=>"Replacement string. Can contain backreferences to what was matched using \\\\0 (whole match),\n\\\\1 (first set of parentheses), and so on.\nIf the second argument is a Hash, and the matched text is one of its keys, the corresponding value is the replacement string.",
                "types"=>[
                  "Variant[String,Hash[String,String]]"
                ],
                "name"=>"replacement"
              },
              {
                "tag_name"=>"param",
                "text"=>"Optional. String of single letter flags for how the regexp is interpreted (E, I, and M cannot be used\nif pattern is a precompiled regexp):\n  - *E*         Extended regexps\n  - *I*         Ignore case in regexps\n  - *M*         Multiline regexps\n  - *G*         Global replacement; all occurrences of the regexp in each target string will be replaced.  Without this, only the first occurrence will be replaced.",
                "types"=>[
                  "Optional[Optional[Pattern[/^[GEIM]*$/]]]"
                ],
                "name"=>"flags"
              },
              {
                "tag_name"=>"param",
                "text"=>"Optional. How to handle multibyte characters when compiling the regexp (must not be used when pattern is a\nprecompiled regexp). A single-character string with the following values:\n  - *N*         None\n  - *E*         EUC\n  - *S*         SJIS\n  - *U*         UTF-8",
                "types"=>[
                  "Optional[Enum['N','E','S','U']]"
                ],
                "name"=>"encoding"
              },
              {
                "tag_name"=>"return",
                "text"=>"The result of the substitution. Result type is the same as for the target parameter.",
                "types"=>[
                  "Array[String]",
                  "String"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"regsubst(Variant[Array[String],String] $target, Variant[Regexp,Type[Regexp]] $pattern, Variant[String,Hash[String,String]] $replacement, Optional[Pattern[/^G?$/]] $flags)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"```puppet\n$x = regsubst($ipaddress, /([0-9]+)/, '<\\\\1>', 'G')\n```",
                "name"=>"Put angle brackets around each octet in the node's IP address:"
              },
              {
                "tag_name"=>"param",
                "text"=>"The string or array of strings to operate on.  If an array, the replacement will be\nperformed on each of the elements in the array, and the return value will be an array.",
                "types"=>[
                  "Variant[Array[String],String]"
                ],
                "name"=>"target"
              },
              {
                "tag_name"=>"param",
                "text"=>"The regular expression matching the target string.  If you want it anchored at the start\nand or end of the string, you must do that with ^ and $ yourself.",
                "types"=>[
                  "Variant[Regexp,Type[Regexp]]"
                ],
                "name"=>"pattern"
              },
              {
                "tag_name"=>"param",
                "text"=>"Replacement string. Can contain backreferences to what was matched using \\\\0 (whole match),\n\\\\1 (first set of parentheses), and so on.\nIf the second argument is a Hash, and the matched text is one of its keys, the corresponding value is the replacement string.",
                "types"=>[
                  "Variant[String,Hash[String,String]]"
                ],
                "name"=>"replacement"
              },
              {
                "tag_name"=>"param",
                "text"=>"Optional. String of single letter flags for how the regexp is interpreted (E, I, and M cannot be used\nif pattern is a precompiled regexp):\n  - *E*         Extended regexps\n  - *I*         Ignore case in regexps\n  - *M*         Multiline regexps\n  - *G*         Global replacement; all occurrences of the regexp in each target string will be replaced.  Without this, only the first occurrence will be replaced.",
                "types"=>[
                  "Optional[Pattern[/^G?$/]]"
                ],
                "name"=>"flags"
              },
              {
                "tag_name"=>"param",
                "text"=>"Optional. How to handle multibyte characters when compiling the regexp (must not be used when pattern is a\nprecompiled regexp). A single-character string with the following values:\n  - *N*         None\n  - *E*         EUC\n  - *S*         SJIS\n  - *U*         UTF-8",
                "types"=>[
                  "Enum['N','E','S','U']"
                ],
                "name"=>"encoding"
              },
              {
                "tag_name"=>"return",
                "text"=>"The result of the substitution. Result type is the same as for the target parameter.",
                "types"=>[
                  "Array[String]",
                  "String"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Performs regexp replacement on a string or array of strings.",
        "tags"=>[
          {
            "tag_name"=>"overload",
            "signature"=>"regsubst(Variant[Array[String],String] $target, String $pattern, Variant[String,Hash[String,String]] $replacement, Optional[Optional[Pattern[/^[GEIM]*$/]]] $flags, Optional[Enum['N','E','S','U']] $encoding)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"example",
                  "text"=>"```puppet\n$i3 = regsubst($ipaddress,'^(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)$','\\\\3')\n```",
                  "name"=>"Get the third octet from the node's IP address:"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"The string or array of strings to operate on.  If an array, the replacement will be\nperformed on each of the elements in the array, and the return value will be an array.",
                  "types"=>[
                    "Variant[Array[String],String]"
                  ],
                  "name"=>"target"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"The regular expression matching the target string.  If you want it anchored at the start\nand or end of the string, you must do that with ^ and $ yourself.",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"pattern"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"Replacement string. Can contain backreferences to what was matched using \\\\0 (whole match),\n\\\\1 (first set of parentheses), and so on.\nIf the second argument is a Hash, and the matched text is one of its keys, the corresponding value is the replacement string.",
                  "types"=>[
                    "Variant[String,Hash[String,String]]"
                  ],
                  "name"=>"replacement"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"Optional. String of single letter flags for how the regexp is interpreted (E, I, and M cannot be used\nif pattern is a precompiled regexp):\n  - *E*         Extended regexps\n  - *I*         Ignore case in regexps\n  - *M*         Multiline regexps\n  - *G*         Global replacement; all occurrences of the regexp in each target string will be replaced.  Without this, only the first occurrence will be replaced.",
                  "types"=>[
                    "Optional[Optional[Pattern[/^[GEIM]*$/]]]"
                  ],
                  "name"=>"flags"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"Optional. How to handle multibyte characters when compiling the regexp (must not be used when pattern is a\nprecompiled regexp). A single-character string with the following values:\n  - *N*         None\n  - *E*         EUC\n  - *S*         SJIS\n  - *U*         UTF-8",
                  "types"=>[
                    "Optional[Enum['N','E','S','U']]"
                  ],
                  "name"=>"encoding"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"The result of the substitution. Result type is the same as for the target parameter.",
                  "types"=>[
                    "Array[String]",
                    "String"
                  ]
                }
              ]
            },
            "name"=>"regsubst"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"regsubst(Variant[Array[String],String] $target, Variant[Regexp,Type[Regexp]] $pattern, Variant[String,Hash[String,String]] $replacement, Optional[Pattern[/^G?$/]] $flags)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"example",
                  "text"=>"```puppet\n$x = regsubst($ipaddress, /([0-9]+)/, '<\\\\1>', 'G')\n```",
                  "name"=>"Put angle brackets around each octet in the node's IP address:"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"The string or array of strings to operate on.  If an array, the replacement will be\nperformed on each of the elements in the array, and the return value will be an array.",
                  "types"=>[
                    "Variant[Array[String],String]"
                  ],
                  "name"=>"target"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"The regular expression matching the target string.  If you want it anchored at the start\nand or end of the string, you must do that with ^ and $ yourself.",
                  "types"=>[
                    "Variant[Regexp,Type[Regexp]]"
                  ],
                  "name"=>"pattern"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"Replacement string. Can contain backreferences to what was matched using \\\\0 (whole match),\n\\\\1 (first set of parentheses), and so on.\nIf the second argument is a Hash, and the matched text is one of its keys, the corresponding value is the replacement string.",
                  "types"=>[
                    "Variant[String,Hash[String,String]]"
                  ],
                  "name"=>"replacement"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"Optional. String of single letter flags for how the regexp is interpreted (E, I, and M cannot be used\nif pattern is a precompiled regexp):\n  - *E*         Extended regexps\n  - *I*         Ignore case in regexps\n  - *M*         Multiline regexps\n  - *G*         Global replacement; all occurrences of the regexp in each target string will be replaced.  Without this, only the first occurrence will be replaced.",
                  "types"=>[
                    "Optional[Pattern[/^G?$/]]"
                  ],
                  "name"=>"flags"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"Optional. How to handle multibyte characters when compiling the regexp (must not be used when pattern is a\nprecompiled regexp). A single-character string with the following values:\n  - *N*         None\n  - *E*         EUC\n  - *S*         SJIS\n  - *U*         UTF-8",
                  "types"=>[
                    "Enum['N','E','S','U']"
                  ],
                  "name"=>"encoding"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"The result of the substitution. Result type is the same as for the target parameter.",
                  "types"=>[
                    "Array[String]",
                    "String"
                  ]
                }
              ]
            },
            "name"=>"regsubst"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:regsubst) do\n  # @param target [String]\n  #      The string or array of strings to operate on.  If an array, the replacement will be\n  #      performed on each of the elements in the array, and the return value will be an array.\n  # @param pattern [String, Regexp, Type[Regexp]]\n  #      The regular expression matching the target string.  If you want it anchored at the start\n  #      and or end of the string, you must do that with ^ and $ yourself.\n  # @param replacement [String, Hash[String, String]]\n  #      Replacement string. Can contain backreferences to what was matched using \\\\0 (whole match),\n  #      \\\\1 (first set of parentheses), and so on.\n  #      If the second argument is a Hash, and the matched text is one of its keys, the corresponding value is the replacement string.\n  # @param flags [Optional[Pattern[/^[GEIM]*$/]], Pattern[/^G?$/]]\n  #      Optional. String of single letter flags for how the regexp is interpreted (E, I, and M cannot be used\n  #      if pattern is a precompiled regexp):\n  #        - *E*         Extended regexps\n  #        - *I*         Ignore case in regexps\n  #        - *M*         Multiline regexps\n  #        - *G*         Global replacement; all occurrences of the regexp in each target string will be replaced.  Without this, only the first occurrence will be replaced.\n  # @param encoding [Enum['N','E','S','U']]\n  #      Optional. How to handle multibyte characters when compiling the regexp (must not be used when pattern is a\n  #      precompiled regexp). A single-character string with the following values:\n  #        - *N*         None\n  #        - *E*         EUC\n  #        - *S*         SJIS\n  #        - *U*         UTF-8\n  # @return [Array[String], String] The result of the substitution. Result type is the same as for the target parameter.\n  # @example Get the third octet from the node's IP address:\n  #   ```puppet\n  #   $i3 = regsubst($ipaddress,'^(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)$','\\\\3')\n  #   ```\n  dispatch :regsubst_string do\n    param          'Variant[Array[String],String]',       :target\n    param          'String',                              :pattern\n    param          'Variant[String,Hash[String,String]]', :replacement\n    optional_param 'Optional[Pattern[/^[GEIM]*$/]]',      :flags\n    optional_param \"Enum['N','E','S','U']\",               :encoding\n  end\n\n  # @param target [String, Array[String]]\n  #      The string or array of strings to operate on.  If an array, the replacement will be\n  #      performed on each of the elements in the array, and the return value will be an array.\n  # @param pattern [Regexp, Type[Regexp]]\n  #      The regular expression matching the target string.  If you want it anchored at the start\n  #      and or end of the string, you must do that with ^ and $ yourself.\n  # @param replacement [String, Hash[String, String]]\n  #      Replacement string. Can contain backreferences to what was matched using \\\\0 (whole match),\n  #      \\\\1 (first set of parentheses), and so on.\n  #      If the second argument is a Hash, and the matched text is one of its keys, the corresponding value is the replacement string.\n  # @param flags [Optional[Pattern[/^[GEIM]*$/]], Pattern[/^G?$/]]\n  #      Optional. String of single letter flags for how the regexp is interpreted (E, I, and M cannot be used\n  #      if pattern is a precompiled regexp):\n  #        - *E*         Extended regexps\n  #        - *I*         Ignore case in regexps\n  #        - *M*         Multiline regexps\n  #        - *G*         Global replacement; all occurrences of the regexp in each target string will be replaced.  Without this, only the first occurrence will be replaced.\n  # @param encoding [Enum['N','E','S','U']]\n  #      Optional. How to handle multibyte characters when compiling the regexp (must not be used when pattern is a\n  #      precompiled regexp). A single-character string with the following values:\n  #        - *N*         None\n  #        - *E*         EUC\n  #        - *S*         SJIS\n  #        - *U*         UTF-8\n  # @return [Array[String], String] The result of the substitution. Result type is the same as for the target parameter.\n  # @example Put angle brackets around each octet in the node's IP address:\n  #   ```puppet\n  #   $x = regsubst($ipaddress, /([0-9]+)/, '<\\\\1>', 'G')\n  #   ```\n  dispatch :regsubst_regexp do\n    param          'Variant[Array[String],String]',       :target\n    param          'Variant[Regexp,Type[Regexp]]',        :pattern\n    param          'Variant[String,Hash[String,String]]', :replacement\n    optional_param 'Pattern[/^G?$/]',                     :flags\n  end\n\n  def regsubst_string(target, pattern, replacement, flags = nil, encoding = nil)\n    re_flags = 0\n    operation = :sub\n    if !flags.nil?\n      flags.split(//).each do |f|\n        case f\n        when 'G' then operation = :gsub\n        when 'E' then re_flags |= Regexp::EXTENDED\n        when 'I' then re_flags |= Regexp::IGNORECASE\n        when 'M' then re_flags |= Regexp::MULTILINE\n        end\n      end\n    end\n    inner_regsubst(target, Regexp.compile(pattern, re_flags, encoding), replacement, operation)\n  end\n\n  def regsubst_regexp(target, pattern, replacement, flags = nil)\n    pattern = (pattern.pattern || '') if pattern.is_a?(Puppet::Pops::Types::PRegexpType)\n    inner_regsubst(target, pattern, replacement, flags == 'G' ? :gsub : :sub)\n  end\n\n  def inner_regsubst(target, re, replacement, op)\n    target.respond_to?(op) ? target.send(op, re, replacement) : target.collect { |e| e.send(op, re, replacement) }\n  end\n  private :inner_regsubst\nend"
    },
    {
      "name"=>"require",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/require.rb",
      "line"=>37,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"require(Any *$names)",
          "docstring"=>{
            "text"=>"Requires the specified classes.\nEvaluate one or more classes, adding the required class as a dependency.\n\nThe relationship metaparameters work well for specifying relationships\nbetween individual resources, but they can be clumsy for specifying\nrelationships between classes.  This function is a superset of the\n'include' function, adding a class relationship so that the requiring\nclass depends on the required class.\n\nWarning: using require in place of include can lead to unwanted dependency cycles.\n\nFor instance the following manifest, with 'require' instead of 'include' would produce a nasty\ndependence cycle, because notify imposes a before between File[/foo] and Service[foo]:\n\n```puppet\nclass myservice {\n  service { foo: ensure => running }\n}\n\nclass otherstuff {\n   include myservice\n   file { '/foo': notify => Service[foo] }\n}\n```\n\nNote that this function only works with clients 0.25 and later, and it will\nfail if used with earlier clients.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use Class and Resource Type values that are produced when evaluating\nresource and relationship expressions.\n\n- Since 4.0.0 Class and Resource types, absolute names\n- Since 4.7.0 Returns an Array[Type[Class]] with references to the required classes",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"*names"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Requires the specified classes.\nEvaluate one or more classes, adding the required class as a dependency.\n\nThe relationship metaparameters work well for specifying relationships\nbetween individual resources, but they can be clumsy for specifying\nrelationships between classes.  This function is a superset of the\n'include' function, adding a class relationship so that the requiring\nclass depends on the required class.\n\nWarning: using require in place of include can lead to unwanted dependency cycles.\n\nFor instance the following manifest, with 'require' instead of 'include' would produce a nasty\ndependence cycle, because notify imposes a before between File[/foo] and Service[foo]:\n\n```puppet\nclass myservice {\n  service { foo: ensure => running }\n}\n\nclass otherstuff {\n   include myservice\n   file { '/foo': notify => Service[foo] }\n}\n```\n\nNote that this function only works with clients 0.25 and later, and it will\nfail if used with earlier clients.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use Class and Resource Type values that are produced when evaluating\nresource and relationship expressions.\n\n- Since 4.0.0 Class and Resource types, absolute names\n- Since 4.7.0 Returns an Array[Type[Class]] with references to the required classes",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Any"
            ],
            "name"=>"*names"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:require, Puppet::Functions::InternalFunction) do\n  dispatch :require_impl do\n    scope_param\n    # The function supports what the type system sees as Ruby runtime objects, and\n    # they cannot be parameterized to find what is actually valid instances.\n    # The validation is instead done in the function body itself via a call to\n    # `transform_and_assert_classnames` on the calling scope.\n    required_repeated_param 'Any', :names\n  end\n\n  def require_impl(scope, *classes)\n    if Puppet[:tasks]\n      raise Puppet::ParseErrorWithIssue.from_issue_and_stack(\n        Puppet::Pops::Issues::CATALOG_OPERATION_NOT_SUPPORTED_WHEN_SCRIPTING,\n        {:operation => 'require'})\n    end\n\n    # Make call patterns uniform and protected against nested arrays, also make\n    # names absolute if so desired.\n    classes = scope.transform_and_assert_classnames(classes.flatten)\n\n    result = classes.map {|name| Puppet::Pops::Types::TypeFactory.host_class(name) }\n\n    # This is the same as calling the include function (but faster) since it again\n    # would otherwise need to perform the optional absolute name transformation\n    # (for no reason since they are already made absolute here).\n    #\n    scope.compiler.evaluate_classes(classes, scope, false)\n    krt = scope.environment.known_resource_types\n\n    classes.each do |klass|\n      # lookup the class in the scopes\n      klass = (classobj = krt.find_hostclass(klass)) ? classobj.name : nil\n      raise Puppet::ParseError.new(_(\"Could not find class %{klass}\") % { klass: klass }) unless klass\n      ref = Puppet::Resource.new(:class, klass)\n      resource = scope.resource\n      resource.set_parameter(:require, [resource[:require]].flatten.compact << ref)\n    end\n    result\n  end\nend"
    },
    {
      "name"=>"require",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/require.rb",
      "line"=>3,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"require()",
          "docstring"=>{
            "text"=>"Evaluate one or more classes,  adding the required class as a dependency.\n\nThe relationship metaparameters work well for specifying relationships\nbetween individual resources, but they can be clumsy for specifying\nrelationships between classes.  This function is a superset of the\n'include' function, adding a class relationship so that the requiring\nclass depends on the required class.\n\nWarning: using require in place of include can lead to unwanted dependency cycles.\n\nFor instance the following manifest, with 'require' instead of 'include' would produce a nasty dependence cycle, because notify imposes a before between File[/foo] and Service[foo]:\n\n    class myservice {\n      service { foo: ensure => running }\n    }\n\n    class otherstuff {\n      include myservice\n      file { '/foo': notify => Service[foo] }\n    }\n\nNote that this function only works with clients 0.25 and later, and it will\nfail if used with earlier clients.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use Class and Resource Type values that are produced when evaluating\nresource and relationship expressions.\n\n- Since 4.0.0 Class and Resource types, absolute names\n- Since 4.7.0 Returns an Array[Type[Class]] with references to the required classes",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Evaluate one or more classes,  adding the required class as a dependency.\n\nThe relationship metaparameters work well for specifying relationships\nbetween individual resources, but they can be clumsy for specifying\nrelationships between classes.  This function is a superset of the\n'include' function, adding a class relationship so that the requiring\nclass depends on the required class.\n\nWarning: using require in place of include can lead to unwanted dependency cycles.\n\nFor instance the following manifest, with 'require' instead of 'include' would produce a nasty dependence cycle, because notify imposes a before between File[/foo] and Service[foo]:\n\n    class myservice {\n      service { foo: ensure => running }\n    }\n\n    class otherstuff {\n      include myservice\n      file { '/foo': notify => Service[foo] }\n    }\n\nNote that this function only works with clients 0.25 and later, and it will\nfail if used with earlier clients.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use Class and Resource Type values that are produced when evaluating\nresource and relationship expressions.\n\n- Since 4.0.0 Class and Resource types, absolute names\n- Since 4.7.0 Returns an Array[Type[Class]] with references to the required classes",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n    :require,\n    :arity => -2,\n    :doc =>\"Evaluate one or more classes,  adding the required class as a dependency.\n\nThe relationship metaparameters work well for specifying relationships\nbetween individual resources, but they can be clumsy for specifying\nrelationships between classes.  This function is a superset of the\n'include' function, adding a class relationship so that the requiring\nclass depends on the required class.\n\nWarning: using require in place of include can lead to unwanted dependency cycles.\n\nFor instance the following manifest, with 'require' instead of 'include' would produce a nasty dependence cycle, because notify imposes a before between File[/foo] and Service[foo]:\n\n    class myservice {\n      service { foo: ensure => running }\n    }\n\n    class otherstuff {\n      include myservice\n      file { '/foo': notify => Service[foo] }\n    }\n\nNote that this function only works with clients 0.25 and later, and it will\nfail if used with earlier clients.\n\nYou must use the class's full name;\nrelative names are not allowed. In addition to names in string form,\nyou may also directly use Class and Resource Type values that are produced when evaluating\nresource and relationship expressions.\n\n- Since 4.0.0 Class and Resource types, absolute names\n- Since 4.7.0 Returns an Array[Type[Class]] with references to the required classes\n\") do |classes|\n  call_function('require', classes)\n  Puppet.warn_once('deprecations', '3xfunction#require', _(\"Calling function_require via the Scope class is deprecated. Use Scope#call_function instead\"))\nend"
    },
    {
      "name"=>"return",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/return.rb",
      "line"=>6,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"return(Optional[Any] $value)",
          "docstring"=>{
            "text"=>"Makes iteration continue with the next value, optionally with a given value for this iteration.\nIf a value is not given it defaults to `undef`",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Any]"
                ],
                "name"=>"value"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Makes iteration continue with the next value, optionally with a given value for this iteration.\nIf a value is not given it defaults to `undef`",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Any]"
            ],
            "name"=>"value"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.7.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:return, Puppet::Functions::InternalFunction) do\n  dispatch :return_impl do\n    optional_param 'Any', :value\n  end\n\n  def return_impl(value = nil)\n    file, line = Puppet::Pops::PuppetStack.top_of_stack\n    raise Puppet::Pops::Evaluator::Return.new(value, file, line)\n  end\nend"
    },
    {
      "name"=>"return",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/return.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"return()",
          "docstring"=>{
            "text"=>"Immediately returns the given optional value from a function, class body or user defined type body.\nIf a value is not given, an `undef` value is returned. This function does not return to the immediate caller.\nIf this function is called from within a lambda, the return action is from the scope of the\nfunction containing the lambda (top scope), not the function accepting the lambda (local scope).\n\nThe signal produced to return a value bubbles up through\nthe call stack until reaching a function, class definition or\ndefinition of a user defined type at which point the value given to the function will\nbe produced as the result of that body of code. An error is raised\nif the signal to return a value reaches the end of the call stack.\n\n**Example:** Using `return`\n\n```puppet\nfunction example($x) {\n  # handle trivial cases first for better readability of\n  # what follows\n  if $x == undef or $x == [] or $x == '' {\n    return false\n  }\n  # complex logic to determine if value is true\n  true\n}\nnotice example([]) # would notice false\nnotice example(42) # would notice true\n```\n\n**Example:** Using `return` in a class\n\n```puppet\nclass example($x) {\n  # handle trivial cases first for better readability of\n  # what follows\n  if $x == undef or $x == [] or $x == '' {\n    # Do some default configuration of this class\n    notice 'foo'\n    return()\n  }\n  # complex logic configuring the class if something more interesting\n  # was given in $x\n  notice 'bar'\n}\n```\n\nWhen used like this:\n\n```puppet\nclass { example: x => [] }\n```\n\nThe code would notice `'foo'`, but not `'bar'`.\n\nWhen used like this:\n\n```puppet\nclass { example: x => [some_value] }\n```\n\nThe code would notice `'bar'` but not `'foo'`\n\nNote that the returned value is ignored if used in a class or user defined type.\n\n**Example:** Using `return` in a lambda\n\n```puppet\n# Concatenate three strings into a single string formatted as a list.\nfunction getFruit() {\n  with(\"apples\", \"oranges\", \"bananas\") |$x, $y, $z| {\n    return(\"${x}, ${y}, and ${z}\")\n  }\n  notice \"not reached\"\n}\n$fruit = getFruit()\nnotice $fruit\n\n# The output contains \"apples, oranges, and bananas\".\n# \"not reached\" is not output because the function returns its value within the\n# calling function's scope, which stops processing the calling function before\n# the `notice \"not reached\"` statement.\n# Using `return()` outside of a calling function results in an error.\n```\n\n* Also see functions `return` and `break`\n* Since 4.8.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Immediately returns the given optional value from a function, class body or user defined type body.\nIf a value is not given, an `undef` value is returned. This function does not return to the immediate caller.\nIf this function is called from within a lambda, the return action is from the scope of the\nfunction containing the lambda (top scope), not the function accepting the lambda (local scope).\n\nThe signal produced to return a value bubbles up through\nthe call stack until reaching a function, class definition or\ndefinition of a user defined type at which point the value given to the function will\nbe produced as the result of that body of code. An error is raised\nif the signal to return a value reaches the end of the call stack.\n\n**Example:** Using `return`\n\n```puppet\nfunction example($x) {\n  # handle trivial cases first for better readability of\n  # what follows\n  if $x == undef or $x == [] or $x == '' {\n    return false\n  }\n  # complex logic to determine if value is true\n  true\n}\nnotice example([]) # would notice false\nnotice example(42) # would notice true\n```\n\n**Example:** Using `return` in a class\n\n```puppet\nclass example($x) {\n  # handle trivial cases first for better readability of\n  # what follows\n  if $x == undef or $x == [] or $x == '' {\n    # Do some default configuration of this class\n    notice 'foo'\n    return()\n  }\n  # complex logic configuring the class if something more interesting\n  # was given in $x\n  notice 'bar'\n}\n```\n\nWhen used like this:\n\n```puppet\nclass { example: x => [] }\n```\n\nThe code would notice `'foo'`, but not `'bar'`.\n\nWhen used like this:\n\n```puppet\nclass { example: x => [some_value] }\n```\n\nThe code would notice `'bar'` but not `'foo'`\n\nNote that the returned value is ignored if used in a class or user defined type.\n\n**Example:** Using `return` in a lambda\n\n```puppet\n# Concatenate three strings into a single string formatted as a list.\nfunction getFruit() {\n  with(\"apples\", \"oranges\", \"bananas\") |$x, $y, $z| {\n    return(\"${x}, ${y}, and ${z}\")\n  }\n  notice \"not reached\"\n}\n$fruit = getFruit()\nnotice $fruit\n\n# The output contains \"apples, oranges, and bananas\".\n# \"not reached\" is not output because the function returns its value within the\n# calling function's scope, which stops processing the calling function before\n# the `notice \"not reached\"` statement.\n# Using `return()` outside of a calling function results in an error.\n```\n\n* Also see functions `return` and `break`\n* Since 4.8.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :return,\n  :arity => -2,\n  :doc => <<-DOC\nImmediately returns the given optional value from a function, class body or user defined type body.\nIf a value is not given, an `undef` value is returned. This function does not return to the immediate caller.\nIf this function is called from within a lambda, the return action is from the scope of the\nfunction containing the lambda (top scope), not the function accepting the lambda (local scope).\n\nThe signal produced to return a value bubbles up through\nthe call stack until reaching a function, class definition or\ndefinition of a user defined type at which point the value given to the function will\nbe produced as the result of that body of code. An error is raised\nif the signal to return a value reaches the end of the call stack.\n\n**Example:** Using `return`\n\n```puppet\nfunction example($x) {\n  # handle trivial cases first for better readability of\n  # what follows\n  if $x == undef or $x == [] or $x == '' {\n    return false\n  }\n  # complex logic to determine if value is true\n  true \n}\nnotice example([]) # would notice false\nnotice example(42) # would notice true\n```\n\n**Example:** Using `return` in a class\n\n```puppet\nclass example($x) {\n  # handle trivial cases first for better readability of\n  # what follows\n  if $x == undef or $x == [] or $x == '' {\n    # Do some default configuration of this class\n    notice 'foo'\n    return()\n  }\n  # complex logic configuring the class if something more interesting\n  # was given in $x\n  notice 'bar'\n}\n```\n\nWhen used like this:\n\n```puppet\nclass { example: x => [] }\n```\n\nThe code would notice `'foo'`, but not `'bar'`.\n\nWhen used like this:\n\n```puppet\nclass { example: x => [some_value] }\n```\n\nThe code would notice `'bar'` but not `'foo'`\n\nNote that the returned value is ignored if used in a class or user defined type.\n\n**Example:** Using `return` in a lambda\n\n```puppet\n# Concatenate three strings into a single string formatted as a list.\nfunction getFruit() {\n  with(\"apples\", \"oranges\", \"bananas\") |$x, $y, $z| {\n    return(\"${x}, ${y}, and ${z}\")\n  }\n  notice \"not reached\"\n}\n$fruit = getFruit()\nnotice $fruit\n\n# The output contains \"apples, oranges, and bananas\".\n# \"not reached\" is not output because the function returns its value within the\n# calling function's scope, which stops processing the calling function before\n# the `notice \"not reached\"` statement.\n# Using `return()` outside of a calling function results in an error.\n```\n\n* Also see functions `return` and `break`\n* Since 4.8.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('return')\nend"
    },
    {
      "name"=>"reverse_each",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/reverse_each.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"reverse_each()",
          "docstring"=>{
            "text"=>"Reverses the order of the elements of something that is iterable and optionally runs a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) for each\nelement.\n\nThis function takes one to two arguments:\n\n1. An `Iterable` that the function will iterate over.\n2. An optional lambda, which the function calls for each element in the first argument. It must\n   request one parameter.\n\n**Example:** Using the `reverse_each` function\n\n```puppet\n$data.reverse_each |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$reverse_data = $data.reverse_each\n```\n\nor\n\n```puppet\nreverse_each($data) |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$reverse_data = reverse_each($data)\n```\n\nWhen no second argument is present, Puppet returns an `Iterable` that represents the reverse\norder of its first argument. This allows methods on `Iterable` to be chained.\n\nWhen a lambda is given as the second argument, Puppet iterates the first argument in reverse\norder and passes each value in turn to the lambda, then returns `undef`.\n\n**Example:** Using the `reverse_each` function with an array and a one-parameter lambda\n\n``` puppet\n# Puppet will log a notice for each of the three items\n# in $data in reverse order.\n$data = [1,2,3]\n$data.reverse_each |$item| { notice($item) }\n```\n\nWhen no second argument is present, Puppet returns a new `Iterable` which allows it to\nbe directly chained into another function that takes an `Iterable` as an argument.\n\n**Example:** Using the `reverse_each` function chained with a `map` function.\n\n```puppet\n# For the array $data, return an array containing each\n# value multiplied by 10 in reverse order\n$data = [1,2,3]\n$transformed_data = $data.reverse_each.map |$item| { $item * 10 }\n# $transformed_data is set to [30,20,10]\n```\n\n**Example:** Using `reverse_each` function chained with a `map` in alternative syntax\n\n```puppet\n# For the array $data, return an array containing each\n# value multiplied by 10 in reverse order\n$data = [1,2,3]\n$transformed_data = map(reverse_each($data)) |$item| { $item * 10 }\n# $transformed_data is set to [30,20,10]\n```\n\n* Since 4.4.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Reverses the order of the elements of something that is iterable and optionally runs a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) for each\nelement.\n\nThis function takes one to two arguments:\n\n1. An `Iterable` that the function will iterate over.\n2. An optional lambda, which the function calls for each element in the first argument. It must\n   request one parameter.\n\n**Example:** Using the `reverse_each` function\n\n```puppet\n$data.reverse_each |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$reverse_data = $data.reverse_each\n```\n\nor\n\n```puppet\nreverse_each($data) |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$reverse_data = reverse_each($data)\n```\n\nWhen no second argument is present, Puppet returns an `Iterable` that represents the reverse\norder of its first argument. This allows methods on `Iterable` to be chained.\n\nWhen a lambda is given as the second argument, Puppet iterates the first argument in reverse\norder and passes each value in turn to the lambda, then returns `undef`.\n\n**Example:** Using the `reverse_each` function with an array and a one-parameter lambda\n\n``` puppet\n# Puppet will log a notice for each of the three items\n# in $data in reverse order.\n$data = [1,2,3]\n$data.reverse_each |$item| { notice($item) }\n```\n\nWhen no second argument is present, Puppet returns a new `Iterable` which allows it to\nbe directly chained into another function that takes an `Iterable` as an argument.\n\n**Example:** Using the `reverse_each` function chained with a `map` function.\n\n```puppet\n# For the array $data, return an array containing each\n# value multiplied by 10 in reverse order\n$data = [1,2,3]\n$transformed_data = $data.reverse_each.map |$item| { $item * 10 }\n# $transformed_data is set to [30,20,10]\n```\n\n**Example:** Using `reverse_each` function chained with a `map` in alternative syntax\n\n```puppet\n# For the array $data, return an array containing each\n# value multiplied by 10 in reverse order\n$data = [1,2,3]\n$transformed_data = map(reverse_each($data)) |$item| { $item * 10 }\n# $transformed_data is set to [30,20,10]\n```\n\n* Since 4.4.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :reverse_each,\n  :type => :rvalue,\n  :arity => -1,\n  :doc => <<-DOC\nReverses the order of the elements of something that is iterable and optionally runs a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) for each\nelement.\n\nThis function takes one to two arguments:\n\n1. An `Iterable` that the function will iterate over.\n2. An optional lambda, which the function calls for each element in the first argument. It must\n   request one parameter.\n\n**Example:** Using the `reverse_each` function\n\n```puppet\n$data.reverse_each |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$reverse_data = $data.reverse_each\n```\n\nor\n\n```puppet\nreverse_each($data) |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$reverse_data = reverse_each($data)\n```\n\nWhen no second argument is present, Puppet returns an `Iterable` that represents the reverse\norder of its first argument. This allows methods on `Iterable` to be chained.\n\nWhen a lambda is given as the second argument, Puppet iterates the first argument in reverse\norder and passes each value in turn to the lambda, then returns `undef`.\n\n**Example:** Using the `reverse_each` function with an array and a one-parameter lambda\n\n``` puppet\n# Puppet will log a notice for each of the three items\n# in $data in reverse order.\n$data = [1,2,3]\n$data.reverse_each |$item| { notice($item) }\n```\n\nWhen no second argument is present, Puppet returns a new `Iterable` which allows it to\nbe directly chained into another function that takes an `Iterable` as an argument.\n\n**Example:** Using the `reverse_each` function chained with a `map` function.\n\n```puppet\n# For the array $data, return an array containing each\n# value multiplied by 10 in reverse order\n$data = [1,2,3]\n$transformed_data = $data.reverse_each.map |$item| { $item * 10 }\n# $transformed_data is set to [30,20,10]\n```\n\n**Example:** Using `reverse_each` function chained with a `map` in alternative syntax\n\n```puppet\n# For the array $data, return an array containing each\n# value multiplied by 10 in reverse order\n$data = [1,2,3]\n$transformed_data = map(reverse_each($data)) |$item| { $item * 10 }\n# $transformed_data is set to [30,20,10]\n```\n\n* Since 4.4.0\n\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('reverse_each')\nend"
    },
    {
      "name"=>"reverse_each",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/reverse_each.rb",
      "line"=>75,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"reverse_each(Iterable $iterable)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"iterable"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"reverse_each(Iterable $iterable, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"iterable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Reverses the order of the elements of something that is iterable and optionally runs a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) for each\nelement.\n\nThis function takes one to two arguments:\n\n1. An `Iterable` that the function will iterate over.\n2. An optional lambda, which the function calls for each element in the first argument. It must\n   request one parameter.\n\n```puppet\n$data.reverse_each |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$reverse_data = $data.reverse_each\n```\n\nor\n\n```puppet\nreverse_each($data) |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$reverse_data = reverse_each($data)\n```\n\nWhen no second argument is present, Puppet returns an `Iterable` that represents the reverse\norder of its first argument. This allows methods on `Iterable` to be chained.\n\nWhen a lambda is given as the second argument, Puppet iterates the first argument in reverse\norder and passes each value in turn to the lambda, then returns `undef`.\n\n```puppet\n# Puppet will log a notice for each of the three items\n# in $data in reverse order.\n$data = [1,2,3]\n$data.reverse_each |$item| { notice($item) }\n```\n\nWhen no second argument is present, Puppet returns a new `Iterable` which allows it to\nbe directly chained into another function that takes an `Iterable` as an argument.\n\n```puppet\n# For the array $data, return an array containing each\n# value multiplied by 10 in reverse order\n$data = [1,2,3]\n$transformed_data = $data.reverse_each.map |$item| { $item * 10 }\n# $transformed_data is set to [30,20,10]\n```\n\n```puppet\n# For the array $data, return an array containing each\n# value multiplied by 10 in reverse order\n$data = [1,2,3]\n$transformed_data = map(reverse_each($data)) |$item| { $item * 10 }\n# $transformed_data is set to [30,20,10]\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `reverse_each` function"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `reverse_each` function with an array and a one-parameter lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `reverse_each` function chained with a `map` function."
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `reverse_each` function chained with a `map` in alternative syntax"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"reverse_each(Iterable $iterable)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"iterable"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"reverse_each"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"reverse_each(Iterable $iterable, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"iterable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"reverse_each"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.4.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:reverse_each) do\n  dispatch :reverse_each do\n    param 'Iterable', :iterable\n  end\n\n  dispatch :reverse_each_block do\n    param 'Iterable', :iterable\n    block_param 'Callable[1,1]', :block\n  end\n\n  def reverse_each(iterable)\n    # produces an Iterable\n    Puppet::Pops::Types::Iterable.asserted_iterable(self, iterable, true).reverse_each\n  end\n\n  def reverse_each_block(iterable, &block)\n    Puppet::Pops::Types::Iterable.asserted_iterable(self, iterable).reverse_each(&block)\n    nil\n  end\nend"
    },
    {
      "name"=>"round",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/round.rb",
      "line"=>12,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"round(Numeric $val)",
          "docstring"=>{
            "text"=>"Returns an `Integer` value rounded to the nearest value.\nTakes a single `Numeric` value as an argument.\n\n```puppet\nnotice(round(2.9)) # would notice 3\nnotice(round(2.1)) # would notice 2\nnotice(round(-2.9)) # would notice -3\n```",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"'rounding a value'"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"val"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns an `Integer` value rounded to the nearest value.\nTakes a single `Numeric` value as an argument.\n\n```puppet\nnotice(round(2.9)) # would notice 3\nnotice(round(2.1)) # would notice 2\nnotice(round(-2.9)) # would notice -3\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"'rounding a value'"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Numeric"
            ],
            "name"=>"val"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:round) do\n  dispatch :on_numeric do\n    param 'Numeric', :val\n  end\n\n  def on_numeric(x)\n    if x > 0\n      Integer(x + 0.5)\n    else\n      Integer(x - 0.5)\n    end\n  end\nend"
    },
    {
      "name"=>"rstrip",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/rstrip.rb",
      "line"=>27,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"rstrip(Numeric $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"rstrip(String $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"rstrip(Iterable[Variant[String, Numeric]] $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable[Variant[String, Numeric]]"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Strips trailing spaces from a String\n\nThis function is compatible with the stdlib function with the same name.\n\nThe function does the following:\n* For a `String` the conversion removes all trailing ASCII white space characters such as space, tab, newline, and return.\n  It does not remove other space-like characters like hard space (Unicode U+00A0). (Tip, `/^[[:space:]]/` regular expression\n  matches all space-like characters).\n* For an `Iterable[Variant[String, Numeric]]` (for example an `Array`) each value is processed and the conversion is not recursive.\n* If the value is `Numeric` it is simply returned (this is for backwards compatibility).\n* An error is raised for all other data types.\n\n```puppet\n\" hello\\n\\t\".rstrip()\nrstrip(\" hello\\n\\t\")\n```\nWould both result in `\"hello\"`\n\n```puppet\n[\" hello\\n\\t\", \" hi\\n\\t\"].rstrip()\nrstrip([\" hello\\n\\t\", \" hi\\n\\t\"])\n```\nWould both result in `['hello', 'hi']`",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Removing trailing space from a String"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Removing trailing space from strings in an Array"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"rstrip(Numeric $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"rstrip"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"rstrip(String $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"rstrip"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"rstrip(Iterable[Variant[String, Numeric]] $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable[Variant[String, Numeric]]"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"rstrip"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:rstrip) do\n\n  dispatch :on_numeric do\n    param 'Numeric', :arg\n  end\n\n  dispatch :on_string do\n    param 'String', :arg\n  end\n\n  dispatch :on_iterable do\n    param 'Iterable[Variant[String, Numeric]]', :arg\n  end\n\n  # unit function - since the old implementation skipped Numeric values\n  def on_numeric(n)\n    n\n  end\n\n  def on_string(s)\n    s.rstrip\n  end\n\n  def on_iterable(a)\n    a.map {|x| do_rstrip(x) }\n  end\n\n  def do_rstrip(x)\n    # x can only be a String or Numeric because type constraints have been automatically applied\n    x.is_a?(String) ? x.rstrip : x\n  end\nend"
    },
    {
      "name"=>"scanf",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/scanf.rb",
      "line"=>28,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"scanf(String $data, String $format, Optional[Callable] &$block)",
          "docstring"=>{
            "text"=>"Scans a string and returns an array of one or more converted values based on the given format string.\nSee the documentation of Ruby's String#scanf method for details about the supported formats (which\nare similar but not identical to the formats used in Puppet's `sprintf` function.)\n\nThis function takes two mandatory arguments: the first is the string to convert, and the second is\nthe format string. The result of the scan is an array, with each successfully scanned and transformed value.\nThe scanning stops if a scan is unsuccessful, and the scanned result up to that point is returned. If there\nwas no successful scan, the result is an empty array.\n\n   \"42\".scanf(\"%i\")\n\nYou can also optionally pass a lambda to scanf, to do additional validation or processing.\n\n\n    \"42\".scanf(\"%i\") |$x| {\n      unless $x[0] =~ Integer {\n        fail \"Expected a well formed integer value, got '$x[0]'\"\n      }\n      $x[0]\n    }",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"data"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"format"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Scans a string and returns an array of one or more converted values based on the given format string.\nSee the documentation of Ruby's String#scanf method for details about the supported formats (which\nare similar but not identical to the formats used in Puppet's `sprintf` function.)\n\nThis function takes two mandatory arguments: the first is the string to convert, and the second is\nthe format string. The result of the scan is an array, with each successfully scanned and transformed value.\nThe scanning stops if a scan is unsuccessful, and the scanned result up to that point is returned. If there\nwas no successful scan, the result is an empty array.\n\n   \"42\".scanf(\"%i\")\n\nYou can also optionally pass a lambda to scanf, to do additional validation or processing.\n\n\n    \"42\".scanf(\"%i\") |$x| {\n      unless $x[0] =~ Integer {\n        fail \"Expected a well formed integer value, got '$x[0]'\"\n      }\n      $x[0]\n    }",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "String"
            ],
            "name"=>"data"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "String"
            ],
            "name"=>"format"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Callable]"
            ],
            "name"=>"&block"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:scanf) do\n  require 'scanf'\n\n  dispatch :scanf do\n    param 'String', :data\n    param 'String', :format\n    optional_block_param\n  end\n\n  def scanf(data, format)\n    result = data.scanf(format)\n    if block_given?\n      result = yield(result)\n    end\n    result\n  end\nend"
    },
    {
      "name"=>"scanf",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/scanf.rb",
      "line"=>3,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"scanf()",
          "docstring"=>{
            "text"=>"Scans a string and returns an array of one or more converted values based on the given format string.\nSee the documentation of Ruby's String#scanf method for details about the supported formats (which\nare similar but not identical to the formats used in Puppet's `sprintf` function.)\n\nThis function takes two mandatory arguments: the first is the string to convert, and the second is\nthe format string. The result of the scan is an array, with each successfully scanned and transformed value.\nThe scanning stops if a scan is unsuccessful, and the scanned result up to that point is returned. If there\nwas no successful scan, the result is an empty array.\n\n```puppet\n\"42\".scanf(\"%i\")\n```\n\nYou can also optionally pass a lambda to scanf, to do additional validation or processing.\n\n```puppet\n\"42\".scanf(\"%i\") |$x| {\n  unless $x[0] =~ Integer {\n    fail \"Expected a well formed integer value, got '$x[0]'\"\n  }\n  $x[0]\n}\n```\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Scans a string and returns an array of one or more converted values based on the given format string.\nSee the documentation of Ruby's String#scanf method for details about the supported formats (which\nare similar but not identical to the formats used in Puppet's `sprintf` function.)\n\nThis function takes two mandatory arguments: the first is the string to convert, and the second is\nthe format string. The result of the scan is an array, with each successfully scanned and transformed value.\nThe scanning stops if a scan is unsuccessful, and the scanned result up to that point is returned. If there\nwas no successful scan, the result is an empty array.\n\n```puppet\n\"42\".scanf(\"%i\")\n```\n\nYou can also optionally pass a lambda to scanf, to do additional validation or processing.\n\n```puppet\n\"42\".scanf(\"%i\") |$x| {\n  unless $x[0] =~ Integer {\n    fail \"Expected a well formed integer value, got '$x[0]'\"\n  }\n  $x[0]\n}\n```\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :scanf,\n  :type => :rvalue,\n  :arity => 2,\n  :doc => <<-DOC\nScans a string and returns an array of one or more converted values based on the given format string.\nSee the documentation of Ruby's String#scanf method for details about the supported formats (which\nare similar but not identical to the formats used in Puppet's `sprintf` function.)\n\nThis function takes two mandatory arguments: the first is the string to convert, and the second is\nthe format string. The result of the scan is an array, with each successfully scanned and transformed value.\nThe scanning stops if a scan is unsuccessful, and the scanned result up to that point is returned. If there\nwas no successful scan, the result is an empty array.\n\n```puppet\n\"42\".scanf(\"%i\")\n```\n\nYou can also optionally pass a lambda to scanf, to do additional validation or processing.\n\n```puppet\n\"42\".scanf(\"%i\") |$x| {\n  unless $x[0] =~ Integer {\n    fail \"Expected a well formed integer value, got '$x[0]'\"\n  }\n  $x[0]\n}\n```\n\n- Since 4.0.0\nDOC\n) do |args|\n  data = args[0]\n  format = args[1]\n  data.scanf(format)\nend"
    },
    {
      "name"=>"sha1",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/sha1.rb",
      "line"=>3,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"sha1()",
          "docstring"=>{
            "text"=>"Returns a SHA1 hash value from a provided string.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns a SHA1 hash value from a provided string.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:sha1, :type => :rvalue, :arity => 1, :doc => \"Returns a SHA1 hash value from a provided string.\") do |args|\n      Digest::SHA1.hexdigest(args[0])\nend"
    },
    {
      "name"=>"sha256",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/sha256.rb",
      "line"=>3,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"sha256()",
          "docstring"=>{
            "text"=>"Returns a SHA256 hash value from a provided string.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns a SHA256 hash value from a provided string.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:sha256, :type => :rvalue, :arity => 1, :doc => \"Returns a SHA256 hash value from a provided string.\") do |args|\n  Digest::SHA256.hexdigest(args[0])\nend"
    },
    {
      "name"=>"shellquote",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/shellquote.rb",
      "line"=>27,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"shellquote()",
          "docstring"=>{
            "text"=>"\\\nQuote and concatenate arguments for use in Bourne shell.\n\nEach argument is quoted separately, and then all are concatenated\nwith spaces.  If an argument is an array, the elements of that\narray is interpolated within the rest of the arguments; this makes\nit possible to have an array of arguments and pass that array to\nshellquote instead of having to specify each argument\nindividually in the call.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"\\\nQuote and concatenate arguments for use in Bourne shell.\n\nEach argument is quoted separately, and then all are concatenated\nwith spaces.  If an argument is an array, the elements of that\narray is interpolated within the rest of the arguments; this makes\nit possible to have an array of arguments and pass that array to\nshellquote instead of having to specify each argument\nindividually in the call.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions.newfunction(:shellquote, :type => :rvalue, :arity => -1, :doc => \"\\\n    Quote and concatenate arguments for use in Bourne shell.\n\n    Each argument is quoted separately, and then all are concatenated\n    with spaces.  If an argument is an array, the elements of that\n    array is interpolated within the rest of the arguments; this makes\n    it possible to have an array of arguments and pass that array to\n    shellquote instead of having to specify each argument\n    individually in the call.\n    \") \\\ndo |args|\n  safe = 'a-zA-Z0-9@%_+=:,./-'    # Safe unquoted\n  dangerous = '!\"`$\\\\'            # Unsafe inside double quotes\n\n  result = []\n  args.flatten.each do |word|\n    if word.length != 0 and word.count(safe) == word.length\n      result << word\n    elsif word.count(dangerous) == 0\n      result << ('\"' + word + '\"')\n    elsif word.count(\"'\") == 0\n      result << (\"'\" + word + \"'\")\n    else\n      r = '\"'\n      word.each_byte do |c|\n        r += \"\\\\\" if dangerous.include?(c.chr)\n        r += c.chr\n      end\n      r += '\"'\n      result << r\n    end\n  end\n\n  return result.join(\" \")\nend"
    },
    {
      "name"=>"size",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/size.rb",
      "line"=>5,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"size(Variant[Collection, String, Binary] $arg)",
          "docstring"=>{
            "text"=>"The same as length() - returns the size of an Array, Hash, String, or Binary value.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Variant[Collection, String, Binary]"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"The same as length() - returns the size of an Array, Hash, String, or Binary value.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Variant[Collection, String, Binary]"
            ],
            "name"=>"arg"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"6.0.0 - also supporting Binary"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:size) do\n  dispatch :generic_size do\n    param 'Variant[Collection, String, Binary]', :arg\n  end\n\n\n  def generic_size(arg)\n    call_function('length', arg)\n  end\n\nend"
    },
    {
      "name"=>"slice",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/slice.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"slice()",
          "docstring"=>{
            "text"=>"This function takes two mandatory arguments: the first should be an array or hash, and the second specifies\nthe number of elements to include in each slice.\n\nWhen the first argument is a hash, each key value pair is counted as one. For example, a slice size of 2 will produce\nan array of two arrays with key, and value.\n\n    $a.slice(2) |$entry|          { notice \"first ${$entry[0]}, second ${$entry[1]}\" }\n    $a.slice(2) |$first, $second| { notice \"first ${first}, second ${second}\" }\n\nThe function produces a concatenated result of the slices.\n\n    slice([1,2,3,4,5,6], 2) # produces [[1,2], [3,4], [5,6]]\n    slice(Integer[1,6], 2)  # produces [[1,2], [3,4], [5,6]]\n    slice(4,2)              # produces [[0,1], [2,3]]\n    slice('hello',2)        # produces [[h, e], [l, l], [o]]\n\nYou can also optionally pass a lambda to slice.\n\n    $a.slice($n) |$x| { ... }\n    slice($a) |$x| { ... }\n\nThe lambda should have either one parameter (receiving an array with the slice), or the same number\nof parameters as specified by the slice size (each parameter receiving its part of the slice).\nIf there are fewer remaining elements than the slice size for the last slice, it will contain the remaining\nelements. If the lambda has multiple parameters, excess parameters are set to undef for an array, or\nto empty arrays for a hash.\n\n    $a.slice(2) |$first, $second| { ... }\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"This function takes two mandatory arguments: the first should be an array or hash, and the second specifies\nthe number of elements to include in each slice.\n\nWhen the first argument is a hash, each key value pair is counted as one. For example, a slice size of 2 will produce\nan array of two arrays with key, and value.\n\n    $a.slice(2) |$entry|          { notice \"first ${$entry[0]}, second ${$entry[1]}\" }\n    $a.slice(2) |$first, $second| { notice \"first ${first}, second ${second}\" }\n\nThe function produces a concatenated result of the slices.\n\n    slice([1,2,3,4,5,6], 2) # produces [[1,2], [3,4], [5,6]]\n    slice(Integer[1,6], 2)  # produces [[1,2], [3,4], [5,6]]\n    slice(4,2)              # produces [[0,1], [2,3]]\n    slice('hello',2)        # produces [[h, e], [l, l], [o]]\n\nYou can also optionally pass a lambda to slice.\n\n    $a.slice($n) |$x| { ... }\n    slice($a) |$x| { ... }\n\nThe lambda should have either one parameter (receiving an array with the slice), or the same number\nof parameters as specified by the slice size (each parameter receiving its part of the slice).\nIf there are fewer remaining elements than the slice size for the last slice, it will contain the remaining\nelements. If the lambda has multiple parameters, excess parameters are set to undef for an array, or\nto empty arrays for a hash.\n\n    $a.slice(2) |$first, $second| { ... }\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :slice,\n  :type => :rvalue,\n  :arity => -3,\n  :doc => <<-DOC\nThis function takes two mandatory arguments: the first should be an array or hash, and the second specifies\nthe number of elements to include in each slice.\n\nWhen the first argument is a hash, each key value pair is counted as one. For example, a slice size of 2 will produce\nan array of two arrays with key, and value.\n\n    $a.slice(2) |$entry|          { notice \"first ${$entry[0]}, second ${$entry[1]}\" }\n    $a.slice(2) |$first, $second| { notice \"first ${first}, second ${second}\" }\n\nThe function produces a concatenated result of the slices.\n\n    slice([1,2,3,4,5,6], 2) # produces [[1,2], [3,4], [5,6]]\n    slice(Integer[1,6], 2)  # produces [[1,2], [3,4], [5,6]]\n    slice(4,2)              # produces [[0,1], [2,3]]\n    slice('hello',2)        # produces [[h, e], [l, l], [o]]\n\nYou can also optionally pass a lambda to slice.\n\n    $a.slice($n) |$x| { ... }\n    slice($a) |$x| { ... }\n\nThe lambda should have either one parameter (receiving an array with the slice), or the same number\nof parameters as specified by the slice size (each parameter receiving its part of the slice).\nIf there are fewer remaining elements than the slice size for the last slice, it will contain the remaining\nelements. If the lambda has multiple parameters, excess parameters are set to undef for an array, or\nto empty arrays for a hash.\n\n    $a.slice(2) |$first, $second| { ... }\n\n- Since 4.0.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('slice')\nend"
    },
    {
      "name"=>"slice",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/slice.rb",
      "line"=>47,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"slice(Hash[Any, Any] $hash, Integer[1, default] $slice_size, Optional[Callable] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[Any, Any]"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Integer[1, default]"
                ],
                "name"=>"slice_size"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"slice(Iterable $enumerable, Integer[1, default] $slice_size, Optional[Callable] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"enumerable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Integer[1, default]"
                ],
                "name"=>"slice_size"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Slices an array or hash into pieces of a given size.\n\nThis function takes two mandatory arguments: the first should be an array or hash, and the second specifies\nthe number of elements to include in each slice.\n\nWhen the first argument is a hash, each key value pair is counted as one. For example, a slice size of 2 will produce\nan array of two arrays with key, and value.\n\n```puppet\n$a.slice(2) |$entry|          { notice \"first ${$entry[0]}, second ${$entry[1]}\" }\n$a.slice(2) |$first, $second| { notice \"first ${first}, second ${second}\" }\n```\nThe function produces a concatenated result of the slices.\n\n```puppet\nslice([1,2,3,4,5,6], 2) # produces [[1,2], [3,4], [5,6]]\nslice(Integer[1,6], 2)  # produces [[1,2], [3,4], [5,6]]\nslice(4,2)              # produces [[0,1], [2,3]]\nslice('hello',2)        # produces [[h, e], [l, l], [o]]\n```\n\n```puppet\n $a.slice($n) |$x| { ... }\n slice($a) |$x| { ... }\n```\n\nThe lambda should have either one parameter (receiving an array with the slice), or the same number\nof parameters as specified by the slice size (each parameter receiving its part of the slice).\nIf there are fewer remaining elements than the slice size for the last slice, it will contain the remaining\nelements. If the lambda has multiple parameters, excess parameters are set to undef for an array, or\nto empty arrays for a hash.\n\n```puppet\n    $a.slice(2) |$first, $second| { ... }\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Slicing a Hash"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Slicing an Array"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Passing a lambda to a slice (optional)"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Getting individual values of a slice"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"slice(Hash[Any, Any] $hash, Integer[1, default] $slice_size, Optional[Callable] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[Any, Any]"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Integer[1, default]"
                  ],
                  "name"=>"slice_size"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"slice"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"slice(Iterable $enumerable, Integer[1, default] $slice_size, Optional[Callable] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"enumerable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Integer[1, default]"
                  ],
                  "name"=>"slice_size"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"slice"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:slice) do\n  dispatch :slice_Hash do\n    param 'Hash[Any, Any]', :hash\n    param 'Integer[1, default]', :slice_size\n    optional_block_param\n  end\n\n  dispatch :slice_Enumerable do\n    param 'Iterable', :enumerable\n    param 'Integer[1, default]', :slice_size\n    optional_block_param\n  end\n\n  def slice_Hash(hash, slice_size, &pblock)\n    result = slice_Common(hash, slice_size, [], block_given? ? pblock : nil)\n    block_given? ? hash : result\n  end\n\n  def slice_Enumerable(enumerable, slice_size, &pblock)\n    enum = Puppet::Pops::Types::Iterable.asserted_iterable(self, enumerable)\n    result = slice_Common(enum, slice_size, nil, block_given? ? pblock : nil)\n    block_given? ? enumerable : result\n  end\n\n  def slice_Common(o, slice_size, filler, pblock)\n    serving_size = asserted_slice_serving_size(pblock, slice_size)\n\n    enumerator = o.each_slice(slice_size)\n    result = []\n    if serving_size == 1\n      begin\n        if pblock\n          loop do\n            pblock.call(enumerator.next)\n          end\n        else\n          loop do\n            result << enumerator.next\n          end\n        end\n      rescue StopIteration\n      end\n    else\n      begin\n        loop do\n          a = enumerator.next\n          if a.size < serving_size\n            a = a.dup.fill(filler, a.length...serving_size)\n          end\n          pblock.call(*a)\n        end\n      rescue StopIteration\n      end\n    end\n    if pblock\n      o\n    else\n      result\n    end\n  end\n\n  def asserted_slice_serving_size(pblock, slice_size)\n    if pblock\n      arity = pblock.arity\n      serving_size = arity < 0 ? slice_size : arity\n    else\n      serving_size = 1\n    end\n    if serving_size == 0\n      raise ArgumentError, _(\"slice(): block must define at least one parameter. Block has 0.\")\n    end\n    unless serving_size == 1 || serving_size == slice_size\n      raise ArgumentError, _(\"slice(): block must define one parameter, or the same number of parameters as the given size of the slice (%{slice_size}). Block has %{serving_size}; %{parameter_names}\") %\n          { slice_size: slice_size, serving_size: serving_size, parameter_names: pblock.parameter_names.join(', ') }\n    end\n    serving_size\n  end\nend"
    },
    {
      "name"=>"sort",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/sort.rb",
      "line"=>56,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"sort(String $string_value, Optional[Callable[2,2]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"string_value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[2,2]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"sort(Array $array_value, Optional[Callable[2,2]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array"
                ],
                "name"=>"array_value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[2,2]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Sorts an Array numerically or lexicographically or the characters of a String lexicographically.\nPlease note: This function is based on Ruby String comparison and as such may not be entirely UTF8 compatible.\nTo ensure compatibility please use this function with Ruby 2.4.0 or greater - https://bugs.ruby-lang.org/issues/10085.\n\nThis function is compatible with the function sort() in stdlib.\n* Comparison of characters in a string always uses a system locale and may not be what is expected for a particular locale\n* Sorting is based on Ruby's <=> operator unless a lambda is given that performs the comparison.\n  * comparison of strings is case dependent (use lambda with `compare($a,$b)` to ignore case)\n  * comparison of mixed data types raises an error (if there is the need to sort mixed data types use a lambda)\n\nAlso see the `compare()` function for information about comparable data types in general.\n\n```puppet\nnotice(sort(\"xadb\")) # notices 'abdx'\n```\n\n```puppet\nnotice(sort([3,6,2])) # notices [2, 3, 6]\n```\n\n```puppet\nnotice(sort([3,6,2]) |$a,$b| { compare($a, $b) }) # notices [2, 3, 6]\nnotice(sort([3,6,2]) |$a,$b| { compare($b, $a) }) # notices [6, 3, 2]\n```\n\n```puppet\nnotice(sort(['A','b','C']))                                    # notices ['A', 'C', 'b']\nnotice(sort(['A','b','C']) |$a,$b| { compare($a, $b) })        # notices ['A', 'b', 'C']\nnotice(sort(['A','b','C']) |$a,$b| { compare($a, $b, true) })  # notices ['A', 'b', 'C']\nnotice(sort(['A','b','C']) |$a,$b| { compare($a, $b, false) }) # notices ['A','C', 'b']\n```\n\n```puppet\nnotice(sort(['b', 3, 'a', 2]) |$a, $b| {\n  case [$a, $b] {\n    [String, Numeric] : { 1 }\n    [Numeric, String] : { -1 }\n    default:            { compare($a, $b) }\n  }\n})\n```\nWould notice [2,3,'a','b']",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Sorting a String"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Sorting an Array"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Sorting with a lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Case independent sorting with a lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Sorting Array with Numeric and String so that numbers are before strings"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"sort(String $string_value, Optional[Callable[2,2]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"string_value"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[2,2]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"sort"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"sort(Array $array_value, Optional[Callable[2,2]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array"
                  ],
                  "name"=>"array_value"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[2,2]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"sort"
          },
          {
            "tag_name"=>"since",
            "text"=>"6.0.0 - supporting a lambda to do compare"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:sort) do\n  dispatch :sort_string do\n    param 'String', :string_value\n    optional_block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :sort_array do\n    param 'Array', :array_value\n    optional_block_param 'Callable[2,2]', :block\n  end\n\n  def sort_string(s, &block)\n    sort_array(s.split(''), &block).join('')\n  end\n\n  def sort_array(a, &block)\n    a.sort(&block)\n  end\nend"
    },
    {
      "name"=>"split",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/split.rb",
      "line"=>3,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"split()",
          "docstring"=>{
            "text"=>"\\\nSplit a string variable into an array using the specified split regexp.\n\n*Example:*\n\n    $string     = 'v1.v2:v3.v4'\n    $array_var1 = split($string, ':')\n    $array_var2 = split($string, '[.]')\n    $array_var3 = split($string, Regexp['[.:]'])\n\n`$array_var1` now holds the result `['v1.v2', 'v3.v4']`,\nwhile `$array_var2` holds `['v1', 'v2:v3', 'v4']`, and\n`$array_var3` holds `['v1', 'v2', 'v3', 'v4']`.\n\nNote that in the second example, we split on a literal string that contains\na regexp meta-character (.), which must be escaped.  A simple\nway to do that for a single character is to enclose it in square\nbrackets; a backslash will also escape a single character.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"\\\nSplit a string variable into an array using the specified split regexp.\n\n*Example:*\n\n    $string     = 'v1.v2:v3.v4'\n    $array_var1 = split($string, ':')\n    $array_var2 = split($string, '[.]')\n    $array_var3 = split($string, Regexp['[.:]'])\n\n`$array_var1` now holds the result `['v1.v2', 'v3.v4']`,\nwhile `$array_var2` holds `['v1', 'v2:v3', 'v4']`, and\n`$array_var3` holds `['v1', 'v2', 'v3', 'v4']`.\n\nNote that in the second example, we split on a literal string that contains\na regexp meta-character (.), which must be escaped.  A simple\nway to do that for a single character is to enclose it in square\nbrackets; a backslash will also escape a single character.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"newfunction(\n:split, :type => :rvalue,\n:arity => 2,\n\n  :doc => \"\\\nSplit a string variable into an array using the specified split regexp.\n\n*Example:*\n\n  $string     = 'v1.v2:v3.v4'\n  $array_var1 = split($string, ':')\n  $array_var2 = split($string, '[.]')\n  $array_var3 = split($string, Regexp['[.:]'])\n\n`$array_var1` now holds the result `['v1.v2', 'v3.v4']`,\nwhile `$array_var2` holds `['v1', 'v2:v3', 'v4']`, and\n`$array_var3` holds `['v1', 'v2', 'v3', 'v4']`.\n\nNote that in the second example, we split on a literal string that contains\na regexp meta-character (.), which must be escaped.  A simple\nway to do that for a single character is to enclose it in square\nbrackets; a backslash will also escape a single character.\") do |args|\n\n  Error.is4x('split')\nend"
    },
    {
      "name"=>"split",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/split.rb",
      "line"=>22,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"split(String $str, String $pattern)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"str"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"pattern"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"split(String $str, Regexp $pattern)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"str"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Regexp"
                ],
                "name"=>"pattern"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"split(String $str, Type[Regexp] $pattern)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"str"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Type[Regexp]"
                ],
                "name"=>"pattern"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Splits a string into an array using a given pattern.\nThe pattern can be a string, regexp or regexp type.\n\n```puppet\n$string     = 'v1.v2:v3.v4'\n$array_var1 = split($string, /:/)\n$array_var2 = split($string, '[.]')\n$array_var3 = split($string, Regexp['[.:]'])\n\n#`$array_var1` now holds the result `['v1.v2', 'v3.v4']`,\n# while `$array_var2` holds `['v1', 'v2:v3', 'v4']`, and\n# `$array_var3` holds `['v1', 'v2', 'v3', 'v4']`.\n```\n\nNote that in the second example, we split on a literal string that contains\na regexp meta-character (`.`), which must be escaped.  A simple\nway to do that for a single character is to enclose it in square\nbrackets; a backslash will also escape a single character.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Splitting a String value"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"split(String $str, String $pattern)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"str"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"pattern"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"split"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"split(String $str, Regexp $pattern)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"str"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Regexp"
                  ],
                  "name"=>"pattern"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"split"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"split(String $str, Type[Regexp] $pattern)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"str"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Type[Regexp]"
                  ],
                  "name"=>"pattern"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"split"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:split) do\n  dispatch :split_String do\n    param 'String', :str\n    param 'String', :pattern\n  end\n\n  dispatch :split_Regexp do\n    param 'String', :str\n    param 'Regexp', :pattern\n  end\n\n  dispatch :split_RegexpType do\n    param 'String', :str\n    param 'Type[Regexp]', :pattern\n  end\n\n  def split_String(str, pattern)\n    str.split(Regexp.compile(pattern))\n  end\n\n  def split_Regexp(str, pattern)\n    str.split(pattern)\n  end\n\n  def split_RegexpType(str, pattern)\n    str.split(pattern.regexp)\n  end\nend"
    },
    {
      "name"=>"sprintf",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/sprintf.rb",
      "line"=>27,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"sprintf()",
          "docstring"=>{
            "text"=>"Perform printf-style formatting of text.\n\nThe first parameter is format string describing how the rest of the parameters should be formatted.\nSee the documentation for the [`Kernel::sprintf` function](https://ruby-doc.org/core/Kernel.html)\nin Ruby for details.\n\nTo use [named format](https://idiosyncratic-ruby.com/49-what-the-format.html) arguments, provide a\nhash containing the target string values as the argument to be formatted. For example:\n\n```puppet\nnotice sprintf(\\\"%<x>s : %<y>d\\\", { 'x' => 'value is', 'y' => 42 })\n```\n\nThis statement produces a notice of `value is : 42`.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Perform printf-style formatting of text.\n\nThe first parameter is format string describing how the rest of the parameters should be formatted.\nSee the documentation for the [`Kernel::sprintf` function](https://ruby-doc.org/core/Kernel.html)\nin Ruby for details.\n\nTo use [named format](https://idiosyncratic-ruby.com/49-what-the-format.html) arguments, provide a\nhash containing the target string values as the argument to be formatted. For example:\n\n```puppet\nnotice sprintf(\\\"%<x>s : %<y>d\\\", { 'x' => 'value is', 'y' => 42 })\n```\n\nThis statement produces a notice of `value is : 42`.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :sprintf, :type => :rvalue,\n  :arity => -2,\n  :doc => \"Perform printf-style formatting of text.\n\n  The first parameter is format string describing how the rest of the parameters should be formatted.\n  See the documentation for the [`Kernel::sprintf` function](https://ruby-doc.org/core/Kernel.html)\n  in Ruby for details.\n  \n  To use [named format](https://idiosyncratic-ruby.com/49-what-the-format.html) arguments, provide a\n  hash containing the target string values as the argument to be formatted. For example:\n\n  ```puppet\n  notice sprintf(\\\"%<x>s : %<y>d\\\", { 'x' => 'value is', 'y' => 42 })\n  ```\n\n  This statement produces a notice of `value is : 42`.\"\n\n) do |args|\n  fmt = args[0]\n  args = args[1..-1]\n  begin\n    return sprintf(fmt, *args)\n  rescue KeyError => e\n    if args.size == 1 && args[0].is_a?(Hash)\n      # map the single hash argument such that all top level string keys are symbols\n      # as that allows named arguments to be used in the format string.\n      #\n      result = {}\n      args[0].each_pair { |k,v| result[k.is_a?(String) ? k.to_sym : k] = v }\n      return sprintf(fmt, result)\n    end\n    raise e\n  end\nend"
    },
    {
      "name"=>"step",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/step.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"step()",
          "docstring"=>{
            "text"=>"Provides stepping with given interval over elements in an iterable and optionally runs a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) for each\nelement.\n\nThis function takes two to three arguments:\n\n1. An 'Iterable' that the function will iterate over.\n2. An `Integer` step factor. This must be a positive integer.\n3. An optional lambda, which the function calls for each element in the interval. It must\n   request one parameter.\n\n**Example:** Using the `step` function\n\n```puppet\n$data.step(<n>) |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$stepped_data = $data.step(<n>)\n```\n\nor\n```puppet\nstep($data, <n>) |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$stepped_data = step($data, <n>)\n```\n\nWhen no block is given, Puppet returns an `Iterable` that yields the first element and every nth successor\nelement, from its first argument. This allows functions on iterables to be chained.\nWhen a block is given, Puppet iterates and calls the block with the first element and then with\nevery nth successor element. It then returns `undef`.\n\n**Example:** Using the `step` function with an array, a step factor, and a one-parameter block\n\n```puppet\n# For the array $data, call a block with the first element and then with each 3rd successor element\n$data = [1,2,3,4,5,6,7,8]\n$data.step(3) |$item| {\n notice($item)\n}\n# Puppet notices the values '1', '4', '7'.\n```\n\nWhen no block is given, Puppet returns a new `Iterable` which allows it to be directly chained into\nanother function that takes an `Iterable` as an argument.\n\n**Example:** Using the `step` function chained with a `map` function.\n\n```puppet\n# For the array $data, return an array, set to the first element and each 5th successor element, in reverse\n# order multiplied by 10\n$data = Integer[0,20]\n$transformed_data = $data.step(5).map |$item| { $item * 10 }\n$transformed_data contains [0,50,100,150,200]\n```\n\n**Example:** The same example using `step` function chained with a `map` in alternative syntax\n\n```puppet\n# For the array $data, return an array, set to the first and each 5th\n# successor, in reverse order, multiplied by 10\n$data = Integer[0,20]\n$transformed_data = map(step($data, 5)) |$item| { $item * 10 }\n$transformed_data contains [0,50,100,150,200]\n```\n\n* Since 4.4.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Provides stepping with given interval over elements in an iterable and optionally runs a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) for each\nelement.\n\nThis function takes two to three arguments:\n\n1. An 'Iterable' that the function will iterate over.\n2. An `Integer` step factor. This must be a positive integer.\n3. An optional lambda, which the function calls for each element in the interval. It must\n   request one parameter.\n\n**Example:** Using the `step` function\n\n```puppet\n$data.step(<n>) |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$stepped_data = $data.step(<n>)\n```\n\nor\n```puppet\nstep($data, <n>) |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$stepped_data = step($data, <n>)\n```\n\nWhen no block is given, Puppet returns an `Iterable` that yields the first element and every nth successor\nelement, from its first argument. This allows functions on iterables to be chained.\nWhen a block is given, Puppet iterates and calls the block with the first element and then with\nevery nth successor element. It then returns `undef`.\n\n**Example:** Using the `step` function with an array, a step factor, and a one-parameter block\n\n```puppet\n# For the array $data, call a block with the first element and then with each 3rd successor element\n$data = [1,2,3,4,5,6,7,8]\n$data.step(3) |$item| {\n notice($item)\n}\n# Puppet notices the values '1', '4', '7'.\n```\n\nWhen no block is given, Puppet returns a new `Iterable` which allows it to be directly chained into\nanother function that takes an `Iterable` as an argument.\n\n**Example:** Using the `step` function chained with a `map` function.\n\n```puppet\n# For the array $data, return an array, set to the first element and each 5th successor element, in reverse\n# order multiplied by 10\n$data = Integer[0,20]\n$transformed_data = $data.step(5).map |$item| { $item * 10 }\n$transformed_data contains [0,50,100,150,200]\n```\n\n**Example:** The same example using `step` function chained with a `map` in alternative syntax\n\n```puppet\n# For the array $data, return an array, set to the first and each 5th\n# successor, in reverse order, multiplied by 10\n$data = Integer[0,20]\n$transformed_data = map(step($data, 5)) |$item| { $item * 10 }\n$transformed_data contains [0,50,100,150,200]\n```\n\n* Since 4.4.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :step,\n  :type => :rvalue,\n  :arity => -1,\n  :doc => <<-DOC\nProvides stepping with given interval over elements in an iterable and optionally runs a\n[lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html) for each\nelement.\n\nThis function takes two to three arguments:\n\n1. An 'Iterable' that the function will iterate over.\n2. An `Integer` step factor. This must be a positive integer.\n3. An optional lambda, which the function calls for each element in the interval. It must\n   request one parameter.\n\n**Example:** Using the `step` function\n\n```puppet\n$data.step(<n>) |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$stepped_data = $data.step(<n>)\n```\n\nor\n```puppet\nstep($data, <n>) |$parameter| { <PUPPET CODE BLOCK> }\n```\n\nor\n\n```puppet\n$stepped_data = step($data, <n>)\n```\n\nWhen no block is given, Puppet returns an `Iterable` that yields the first element and every nth successor\nelement, from its first argument. This allows functions on iterables to be chained.\nWhen a block is given, Puppet iterates and calls the block with the first element and then with\nevery nth successor element. It then returns `undef`.\n\n**Example:** Using the `step` function with an array, a step factor, and a one-parameter block\n\n```puppet\n# For the array $data, call a block with the first element and then with each 3rd successor element\n$data = [1,2,3,4,5,6,7,8]\n$data.step(3) |$item| {\n notice($item)\n}\n# Puppet notices the values '1', '4', '7'.\n```\n\nWhen no block is given, Puppet returns a new `Iterable` which allows it to be directly chained into\nanother function that takes an `Iterable` as an argument.\n\n**Example:** Using the `step` function chained with a `map` function.\n\n```puppet\n# For the array $data, return an array, set to the first element and each 5th successor element, in reverse\n# order multiplied by 10\n$data = Integer[0,20]\n$transformed_data = $data.step(5).map |$item| { $item * 10 }\n$transformed_data contains [0,50,100,150,200]\n```\n\n**Example:** The same example using `step` function chained with a `map` in alternative syntax\n\n```puppet\n# For the array $data, return an array, set to the first and each 5th\n# successor, in reverse order, multiplied by 10\n$data = Integer[0,20]\n$transformed_data = map(step($data, 5)) |$item| { $item * 10 }\n$transformed_data contains [0,50,100,150,200]\n```\n\n* Since 4.4.0\n\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('step')\nend"
    },
    {
      "name"=>"step",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/step.rb",
      "line"=>77,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"step(Iterable $iterable, Integer[1] $step)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"iterable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Integer[1]"
                ],
                "name"=>"step"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"step(Iterable $iterable, Integer[1] $step, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"iterable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Integer[1]"
                ],
                "name"=>"step"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"When no block is given, Puppet returns a new `Iterable` which allows it to be directly chained into\nanother function that takes an `Iterable` as an argument.\n\n```puppet\n# For the array $data, return an array, set to the first element and each 5th successor element, in reverse\n# order multiplied by 10\n$data = Integer[0,20]\n$transformed_data = $data.step(5).map |$item| { $item * 10 }\n$transformed_data contains [0,50,100,150,200]\n```\n\n```puppet\n# For the array $data, return an array, set to the first and each 5th\n# successor, in reverse order, multiplied by 10\n$data = Integer[0,20]\n$transformed_data = map(step($data, 5)) |$item| { $item * 10 }\n$transformed_data contains [0,50,100,150,200]\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `step` function chained with a `map` function."
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"The same example using `step` function chained with a `map` in alternative syntax"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"step(Iterable $iterable, Integer[1] $step)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"iterable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Integer[1]"
                  ],
                  "name"=>"step"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"step"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"step(Iterable $iterable, Integer[1] $step, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"iterable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Integer[1]"
                  ],
                  "name"=>"step"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"step"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.4.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:step) do\n  dispatch :step do\n    param 'Iterable', :iterable\n    param 'Integer[1]', :step\n  end\n\n  dispatch :step_block do\n    param 'Iterable', :iterable\n    param 'Integer[1]', :step\n    block_param 'Callable[1,1]', :block\n  end\n\n  def step(iterable, step)\n    # produces an Iterable\n    Puppet::Pops::Types::Iterable.asserted_iterable(self, iterable, true).step(step)\n  end\n\n  def step_block(iterable, step, &block)\n    Puppet::Pops::Types::Iterable.asserted_iterable(self, iterable).step(step, &block)\n    nil\n  end\nend"
    },
    {
      "name"=>"strftime",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/strftime.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"strftime()",
          "docstring"=>{
            "text"=>"Formats timestamp or timespan according to the directives in the given format string. The directives begins with a percent (%) character.\nAny text not listed as a directive will be passed through to the output string.\n\nA third optional timezone argument can be provided. The first argument will then be formatted to represent a local time in that\ntimezone. The timezone can be any timezone that is recognized when using the '%z' or '%Z' formats, or the word 'current', in which\ncase the current timezone of the evaluating process will be used. The timezone argument is case insensitive.\n\nThe default timezone, when no argument is provided, or when using the keyword `default`, is 'UTC'.\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n```\n%[Flags][Width]Conversion\n```\n\n### Flags that controls padding\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n\n### `Timestamp` specific flags\n\n| Flag  | Meaning\n| ----  | ---------------\n| #     | Change case\n| ^     | Use uppercase\n| :     | Use colons for %z\n\n### Format directives applicable to `Timestamp` (names and padding can be altered using flags):\n\n**Date (Year, Month, Day):**\n\n| Format | Meaning |\n| ------ | ------- |\n| Y | Year with century, zero-padded to at least 4 digits |\n| C | year / 100 (rounded down such as 20 in 2009) |\n| y | year % 100 (00..99) |\n| m | Month of the year, zero-padded (01..12) |\n| B | The full month name (\"January\") |\n| b | The abbreviated month name (\"Jan\") |\n| h | Equivalent to %b |\n| d | Day of the month, zero-padded (01..31) |\n| e | Day of the month, blank-padded ( 1..31) |\n| j | Day of the year (001..366) |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| H | Hour of the day, 24-hour clock, zero-padded (00..23) |\n| k | Hour of the day, 24-hour clock, blank-padded ( 0..23) |\n| I | Hour of the day, 12-hour clock, zero-padded (01..12) |\n| l | Hour of the day, 12-hour clock, blank-padded ( 1..12) |\n| P | Meridian indicator, lowercase (\"am\" or \"pm\") |\n| p | Meridian indicator, uppercase (\"AM\" or \"PM\") |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..60) |\n| L | Millisecond of the second (000..999). Digits under millisecond are truncated to not produce 1000 |\n| N | Fractional seconds digits, default is 9 digits (nanosecond). Digits under a specified width are truncated to avoid carry up |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| z   | Time zone as hour and minute offset from UTC (e.g. +0900) |\n| :z  | hour and minute offset from UTC with a colon (e.g. +09:00) |\n| ::z | hour, minute and second offset from UTC (e.g. +09:00:00) |\n| Z   | Abbreviated time zone name or similar information.  (OS dependent) |\n\n**Weekday:**\n\n| Format | Meaning |\n| ------ | ------- |\n| A | The full weekday name (\"Sunday\") |\n| a | The abbreviated name (\"Sun\") |\n| u | Day of the week (Monday is 1, 1..7) |\n| w | Day of the week (Sunday is 0, 0..6) |\n\n**ISO 8601 week-based year and week number:**\n\nThe first week of YYYY starts with a Monday and includes YYYY-01-04.\nThe days in the year before the first week are in the last week of\nthe previous year.\n\n| Format | Meaning |\n| ------ | ------- |\n| G | The week-based year |\n| g | The last 2 digits of the week-based year (00..99) |\n| V | Week number of the week-based year (01..53) |\n\n**Week number:**\n\nThe first week of YYYY that starts with a Sunday or Monday (according to %U\nor %W). The days in the year before the first week are in week 0.\n\n| Format | Meaning |\n| ------ | ------- |\n| U | Week number of the year. The week starts with Sunday. (00..53) |\n| W | Week number of the year. The week starts with Monday. (00..53) |\n\n**Seconds since the Epoch:**\n\n| Format | Meaning |\n| s | Number of seconds since 1970-01-01 00:00:00 UTC. |\n\n**Literal string:**\n\n| Format | Meaning |\n| ------ | ------- |\n| n | Newline character (\\n) |\n| t | Tab character (\\t) |\n| % | Literal \"%\" character |\n\n**Combination:**\n\n| Format | Meaning |\n| ------ | ------- |\n| c | date and time (%a %b %e %T %Y) |\n| D | Date (%m/%d/%y) |\n| F | The ISO 8601 date format (%Y-%m-%d) |\n| v | VMS date (%e-%^b-%4Y) |\n| x | Same as %D |\n| X | Same as %T |\n| r | 12-hour time (%I:%M:%S %p) |\n| R | 24-hour time (%H:%M) |\n| T | 24-hour time (%H:%M:%S) |\n\n**Example**: Using `strftime` with a `Timestamp`:\n\n~~~ puppet\n$timestamp = Timestamp('2016-08-24T12:13:14')\n\n# Notice the timestamp using a format that notices the ISO 8601 date format\nnotice($timestamp.strftime('%F')) # outputs '2016-08-24'\n\n# Notice the timestamp using a format that notices weekday, month, day, time (as UTC), and year\nnotice($timestamp.strftime('%c')) # outputs 'Wed Aug 24 12:13:14 2016'\n\n# Notice the timestamp using a specific timezone\nnotice($timestamp.strftime('%F %T %z', 'PST')) # outputs '2016-08-24 04:13:14 -0800'\n\n# Notice the timestamp using timezone that is current for the evaluating process\nnotice($timestamp.strftime('%F %T', 'current')) # outputs the timestamp using the timezone for the current process\n~~~\n\n### Format directives applicable to `Timespan`:\n\n| Format | Meaning |\n| ------ | ------- |\n| D | Number of Days |\n| H | Hour of the day, 24-hour clock |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..59) |\n| L | Millisecond of the second (000..999). Digits under millisecond are truncated to not produce 1000. |\n| N | Fractional seconds digits, default is 9 digits (nanosecond). Digits under a specified length are truncated to avoid carry up |\n\nThe format directive that represents the highest magnitude in the format will be allowed to overflow.\nI.e. if no \"%D\" is used but a \"%H\" is present, then the hours will be more than 23 in case the\ntimespan reflects more than a day.\n\n**Example**: Using `strftime` with a Timespan and a format\n\n~~~ puppet\n$duration = Timespan({ hours => 3, minutes => 20, seconds => 30 })\n\n# Notice the duration using a format that outputs <hours>:<minutes>:<seconds>\nnotice($duration.strftime('%H:%M:%S')) # outputs '03:20:30'\n\n# Notice the duration using a format that outputs <minutes>:<seconds>\nnotice($duration.strftime('%M:%S')) # outputs '200:30'\n~~~\n\n- Since 4.8.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Formats timestamp or timespan according to the directives in the given format string. The directives begins with a percent (%) character.\nAny text not listed as a directive will be passed through to the output string.\n\nA third optional timezone argument can be provided. The first argument will then be formatted to represent a local time in that\ntimezone. The timezone can be any timezone that is recognized when using the '%z' or '%Z' formats, or the word 'current', in which\ncase the current timezone of the evaluating process will be used. The timezone argument is case insensitive.\n\nThe default timezone, when no argument is provided, or when using the keyword `default`, is 'UTC'.\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n```\n%[Flags][Width]Conversion\n```\n\n### Flags that controls padding\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n\n### `Timestamp` specific flags\n\n| Flag  | Meaning\n| ----  | ---------------\n| #     | Change case\n| ^     | Use uppercase\n| :     | Use colons for %z\n\n### Format directives applicable to `Timestamp` (names and padding can be altered using flags):\n\n**Date (Year, Month, Day):**\n\n| Format | Meaning |\n| ------ | ------- |\n| Y | Year with century, zero-padded to at least 4 digits |\n| C | year / 100 (rounded down such as 20 in 2009) |\n| y | year % 100 (00..99) |\n| m | Month of the year, zero-padded (01..12) |\n| B | The full month name (\"January\") |\n| b | The abbreviated month name (\"Jan\") |\n| h | Equivalent to %b |\n| d | Day of the month, zero-padded (01..31) |\n| e | Day of the month, blank-padded ( 1..31) |\n| j | Day of the year (001..366) |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| H | Hour of the day, 24-hour clock, zero-padded (00..23) |\n| k | Hour of the day, 24-hour clock, blank-padded ( 0..23) |\n| I | Hour of the day, 12-hour clock, zero-padded (01..12) |\n| l | Hour of the day, 12-hour clock, blank-padded ( 1..12) |\n| P | Meridian indicator, lowercase (\"am\" or \"pm\") |\n| p | Meridian indicator, uppercase (\"AM\" or \"PM\") |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..60) |\n| L | Millisecond of the second (000..999). Digits under millisecond are truncated to not produce 1000 |\n| N | Fractional seconds digits, default is 9 digits (nanosecond). Digits under a specified width are truncated to avoid carry up |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| z   | Time zone as hour and minute offset from UTC (e.g. +0900) |\n| :z  | hour and minute offset from UTC with a colon (e.g. +09:00) |\n| ::z | hour, minute and second offset from UTC (e.g. +09:00:00) |\n| Z   | Abbreviated time zone name or similar information.  (OS dependent) |\n\n**Weekday:**\n\n| Format | Meaning |\n| ------ | ------- |\n| A | The full weekday name (\"Sunday\") |\n| a | The abbreviated name (\"Sun\") |\n| u | Day of the week (Monday is 1, 1..7) |\n| w | Day of the week (Sunday is 0, 0..6) |\n\n**ISO 8601 week-based year and week number:**\n\nThe first week of YYYY starts with a Monday and includes YYYY-01-04.\nThe days in the year before the first week are in the last week of\nthe previous year.\n\n| Format | Meaning |\n| ------ | ------- |\n| G | The week-based year |\n| g | The last 2 digits of the week-based year (00..99) |\n| V | Week number of the week-based year (01..53) |\n\n**Week number:**\n\nThe first week of YYYY that starts with a Sunday or Monday (according to %U\nor %W). The days in the year before the first week are in week 0.\n\n| Format | Meaning |\n| ------ | ------- |\n| U | Week number of the year. The week starts with Sunday. (00..53) |\n| W | Week number of the year. The week starts with Monday. (00..53) |\n\n**Seconds since the Epoch:**\n\n| Format | Meaning |\n| s | Number of seconds since 1970-01-01 00:00:00 UTC. |\n\n**Literal string:**\n\n| Format | Meaning |\n| ------ | ------- |\n| n | Newline character (\\n) |\n| t | Tab character (\\t) |\n| % | Literal \"%\" character |\n\n**Combination:**\n\n| Format | Meaning |\n| ------ | ------- |\n| c | date and time (%a %b %e %T %Y) |\n| D | Date (%m/%d/%y) |\n| F | The ISO 8601 date format (%Y-%m-%d) |\n| v | VMS date (%e-%^b-%4Y) |\n| x | Same as %D |\n| X | Same as %T |\n| r | 12-hour time (%I:%M:%S %p) |\n| R | 24-hour time (%H:%M) |\n| T | 24-hour time (%H:%M:%S) |\n\n**Example**: Using `strftime` with a `Timestamp`:\n\n~~~ puppet\n$timestamp = Timestamp('2016-08-24T12:13:14')\n\n# Notice the timestamp using a format that notices the ISO 8601 date format\nnotice($timestamp.strftime('%F')) # outputs '2016-08-24'\n\n# Notice the timestamp using a format that notices weekday, month, day, time (as UTC), and year\nnotice($timestamp.strftime('%c')) # outputs 'Wed Aug 24 12:13:14 2016'\n\n# Notice the timestamp using a specific timezone\nnotice($timestamp.strftime('%F %T %z', 'PST')) # outputs '2016-08-24 04:13:14 -0800'\n\n# Notice the timestamp using timezone that is current for the evaluating process\nnotice($timestamp.strftime('%F %T', 'current')) # outputs the timestamp using the timezone for the current process\n~~~\n\n### Format directives applicable to `Timespan`:\n\n| Format | Meaning |\n| ------ | ------- |\n| D | Number of Days |\n| H | Hour of the day, 24-hour clock |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..59) |\n| L | Millisecond of the second (000..999). Digits under millisecond are truncated to not produce 1000. |\n| N | Fractional seconds digits, default is 9 digits (nanosecond). Digits under a specified length are truncated to avoid carry up |\n\nThe format directive that represents the highest magnitude in the format will be allowed to overflow.\nI.e. if no \"%D\" is used but a \"%H\" is present, then the hours will be more than 23 in case the\ntimespan reflects more than a day.\n\n**Example**: Using `strftime` with a Timespan and a format\n\n~~~ puppet\n$duration = Timespan({ hours => 3, minutes => 20, seconds => 30 })\n\n# Notice the duration using a format that outputs <hours>:<minutes>:<seconds>\nnotice($duration.strftime('%H:%M:%S')) # outputs '03:20:30'\n\n# Notice the duration using a format that outputs <minutes>:<seconds>\nnotice($duration.strftime('%M:%S')) # outputs '200:30'\n~~~\n\n- Since 4.8.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :strftime,\n  :type => :rvalue,\n  :arity => -3,\n  :doc => <<DOC\nFormats timestamp or timespan according to the directives in the given format string. The directives begins with a percent (%) character.\nAny text not listed as a directive will be passed through to the output string.\n\nA third optional timezone argument can be provided. The first argument will then be formatted to represent a local time in that\ntimezone. The timezone can be any timezone that is recognized when using the '%z' or '%Z' formats, or the word 'current', in which\ncase the current timezone of the evaluating process will be used. The timezone argument is case insensitive.\n\nThe default timezone, when no argument is provided, or when using the keyword `default`, is 'UTC'.\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n```\n%[Flags][Width]Conversion\n```\n\n### Flags that controls padding\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n\n### `Timestamp` specific flags\n\n| Flag  | Meaning\n| ----  | ---------------\n| #     | Change case\n| ^     | Use uppercase\n| :     | Use colons for %z\n\n### Format directives applicable to `Timestamp` (names and padding can be altered using flags):\n\n**Date (Year, Month, Day):**\n\n| Format | Meaning |\n| ------ | ------- |\n| Y | Year with century, zero-padded to at least 4 digits |\n| C | year / 100 (rounded down such as 20 in 2009) |\n| y | year % 100 (00..99) |\n| m | Month of the year, zero-padded (01..12) |\n| B | The full month name (\"January\") |\n| b | The abbreviated month name (\"Jan\") |\n| h | Equivalent to %b |\n| d | Day of the month, zero-padded (01..31) |\n| e | Day of the month, blank-padded ( 1..31) |\n| j | Day of the year (001..366) |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| H | Hour of the day, 24-hour clock, zero-padded (00..23) |\n| k | Hour of the day, 24-hour clock, blank-padded ( 0..23) |\n| I | Hour of the day, 12-hour clock, zero-padded (01..12) |\n| l | Hour of the day, 12-hour clock, blank-padded ( 1..12) |\n| P | Meridian indicator, lowercase (\"am\" or \"pm\") |\n| p | Meridian indicator, uppercase (\"AM\" or \"PM\") |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..60) |\n| L | Millisecond of the second (000..999). Digits under millisecond are truncated to not produce 1000 |\n| N | Fractional seconds digits, default is 9 digits (nanosecond). Digits under a specified width are truncated to avoid carry up |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| z   | Time zone as hour and minute offset from UTC (e.g. +0900) |\n| :z  | hour and minute offset from UTC with a colon (e.g. +09:00) |\n| ::z | hour, minute and second offset from UTC (e.g. +09:00:00) |\n| Z   | Abbreviated time zone name or similar information.  (OS dependent) |\n\n**Weekday:**\n\n| Format | Meaning |\n| ------ | ------- |\n| A | The full weekday name (\"Sunday\") |\n| a | The abbreviated name (\"Sun\") |\n| u | Day of the week (Monday is 1, 1..7) |\n| w | Day of the week (Sunday is 0, 0..6) |\n\n**ISO 8601 week-based year and week number:**\n\nThe first week of YYYY starts with a Monday and includes YYYY-01-04.\nThe days in the year before the first week are in the last week of\nthe previous year.\n\n| Format | Meaning |\n| ------ | ------- |\n| G | The week-based year |\n| g | The last 2 digits of the week-based year (00..99) |\n| V | Week number of the week-based year (01..53) |\n\n**Week number:**\n\nThe first week of YYYY that starts with a Sunday or Monday (according to %U\nor %W). The days in the year before the first week are in week 0.\n\n| Format | Meaning |\n| ------ | ------- |\n| U | Week number of the year. The week starts with Sunday. (00..53) |\n| W | Week number of the year. The week starts with Monday. (00..53) |\n\n**Seconds since the Epoch:**\n\n| Format | Meaning |\n| s | Number of seconds since 1970-01-01 00:00:00 UTC. |\n\n**Literal string:**\n\n| Format | Meaning |\n| ------ | ------- |\n| n | Newline character (\\n) |\n| t | Tab character (\\t) |\n| % | Literal \"%\" character |\n\n**Combination:**\n\n| Format | Meaning |\n| ------ | ------- |\n| c | date and time (%a %b %e %T %Y) |\n| D | Date (%m/%d/%y) |\n| F | The ISO 8601 date format (%Y-%m-%d) |\n| v | VMS date (%e-%^b-%4Y) |\n| x | Same as %D |\n| X | Same as %T |\n| r | 12-hour time (%I:%M:%S %p) |\n| R | 24-hour time (%H:%M) |\n| T | 24-hour time (%H:%M:%S) |\n\n**Example**: Using `strftime` with a `Timestamp`:\n\n~~~ puppet\n$timestamp = Timestamp('2016-08-24T12:13:14')\n\n# Notice the timestamp using a format that notices the ISO 8601 date format\nnotice($timestamp.strftime('%F')) # outputs '2016-08-24'\n\n# Notice the timestamp using a format that notices weekday, month, day, time (as UTC), and year\nnotice($timestamp.strftime('%c')) # outputs 'Wed Aug 24 12:13:14 2016'\n\n# Notice the timestamp using a specific timezone\nnotice($timestamp.strftime('%F %T %z', 'PST')) # outputs '2016-08-24 04:13:14 -0800'\n\n# Notice the timestamp using timezone that is current for the evaluating process\nnotice($timestamp.strftime('%F %T', 'current')) # outputs the timestamp using the timezone for the current process\n~~~\n\n### Format directives applicable to `Timespan`:\n\n| Format | Meaning |\n| ------ | ------- |\n| D | Number of Days |\n| H | Hour of the day, 24-hour clock |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..59) |\n| L | Millisecond of the second (000..999). Digits under millisecond are truncated to not produce 1000. |\n| N | Fractional seconds digits, default is 9 digits (nanosecond). Digits under a specified length are truncated to avoid carry up |\n\nThe format directive that represents the highest magnitude in the format will be allowed to overflow.\nI.e. if no \"%D\" is used but a \"%H\" is present, then the hours will be more than 23 in case the\ntimespan reflects more than a day.\n\n**Example**: Using `strftime` with a Timespan and a format\n\n~~~ puppet\n$duration = Timespan({ hours => 3, minutes => 20, seconds => 30 })\n\n# Notice the duration using a format that outputs <hours>:<minutes>:<seconds>\nnotice($duration.strftime('%H:%M:%S')) # outputs '03:20:30'\n\n# Notice the duration using a format that outputs <minutes>:<seconds>\nnotice($duration.strftime('%M:%S')) # outputs '200:30'\n~~~\n\n- Since 4.8.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('strftime')\nend"
    },
    {
      "name"=>"strftime",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/strftime.rb",
      "line"=>179,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"strftime(Timespan $time_object, String $format)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Timespan"
                ],
                "name"=>"time_object"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"format"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"strftime(Timestamp $time_object, String $format, Optional[String] $timezone)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Timestamp"
                ],
                "name"=>"time_object"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"format"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[String]"
                ],
                "name"=>"timezone"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"strftime(String $format, Optional[String] $timezone)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"format"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[String]"
                ],
                "name"=>"timezone"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Formats timestamp or timespan according to the directives in the given format string. The directives begins with a percent (%) character.\nAny text not listed as a directive will be passed through to the output string.\n\nA third optional timezone argument can be provided. The first argument will then be formatted to represent a local time in that\ntimezone. The timezone can be any timezone that is recognized when using the '%z' or '%Z' formats, or the word 'current', in which\ncase the current timezone of the evaluating process will be used. The timezone argument is case insensitive.\n\nThe default timezone, when no argument is provided, or when using the keyword `default`, is 'UTC'.\n\nThe directive consists of a percent (%) character, zero or more flags, optional minimum field width and\na conversion specifier as follows:\n\n```\n%[Flags][Width]Conversion\n```\n\n### Flags that controls padding\n\n| Flag  | Meaning\n| ----  | ---------------\n| -     | Don't pad numerical output\n| _     | Use spaces for padding\n| 0     | Use zeros for padding\n\n### `Timestamp` specific flags\n\n| Flag  | Meaning\n| ----  | ---------------\n| #     | Change case\n| ^     | Use uppercase\n| :     | Use colons for %z\n\n### Format directives applicable to `Timestamp` (names and padding can be altered using flags):\n\n**Date (Year, Month, Day):**\n\n| Format | Meaning |\n| ------ | ------- |\n| Y | Year with century, zero-padded to at least 4 digits |\n| C | year / 100 (rounded down such as 20 in 2009) |\n| y | year % 100 (00..99) |\n| m | Month of the year, zero-padded (01..12) |\n| B | The full month name (\"January\") |\n| b | The abbreviated month name (\"Jan\") |\n| h | Equivalent to %b |\n| d | Day of the month, zero-padded (01..31) |\n| e | Day of the month, blank-padded ( 1..31) |\n| j | Day of the year (001..366) |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| H | Hour of the day, 24-hour clock, zero-padded (00..23) |\n| k | Hour of the day, 24-hour clock, blank-padded ( 0..23) |\n| I | Hour of the day, 12-hour clock, zero-padded (01..12) |\n| l | Hour of the day, 12-hour clock, blank-padded ( 1..12) |\n| P | Meridian indicator, lowercase (\"am\" or \"pm\") |\n| p | Meridian indicator, uppercase (\"AM\" or \"PM\") |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..60) |\n| L | Millisecond of the second (000..999). Digits under millisecond are truncated to not produce 1000 |\n| N | Fractional seconds digits, default is 9 digits (nanosecond). Digits under a specified width are truncated to avoid carry up |\n\n**Time (Hour, Minute, Second, Subsecond):**\n\n| Format | Meaning |\n| ------ | ------- |\n| z   | Time zone as hour and minute offset from UTC (e.g. +0900) |\n| :z  | hour and minute offset from UTC with a colon (e.g. +09:00) |\n| ::z | hour, minute and second offset from UTC (e.g. +09:00:00) |\n| Z   | Abbreviated time zone name or similar information.  (OS dependent) |\n\n**Weekday:**\n\n| Format | Meaning |\n| ------ | ------- |\n| A | The full weekday name (\"Sunday\") |\n| a | The abbreviated name (\"Sun\") |\n| u | Day of the week (Monday is 1, 1..7) |\n| w | Day of the week (Sunday is 0, 0..6) |\n\n**ISO 8601 week-based year and week number:**\n\nThe first week of YYYY starts with a Monday and includes YYYY-01-04.\nThe days in the year before the first week are in the last week of\nthe previous year.\n\n| Format | Meaning |\n| ------ | ------- |\n| G | The week-based year |\n| g | The last 2 digits of the week-based year (00..99) |\n| V | Week number of the week-based year (01..53) |\n\n**Week number:**\n\nThe first week of YYYY that starts with a Sunday or Monday (according to %U\nor %W). The days in the year before the first week are in week 0.\n\n| Format | Meaning |\n| ------ | ------- |\n| U | Week number of the year. The week starts with Sunday. (00..53) |\n| W | Week number of the year. The week starts with Monday. (00..53) |\n\n**Seconds since the Epoch:**\n\n| Format | Meaning |\n| s | Number of seconds since 1970-01-01 00:00:00 UTC. |\n\n**Literal string:**\n\n| Format | Meaning |\n| ------ | ------- |\n| n | Newline character (\\n) |\n| t | Tab character (\\t) |\n| % | Literal \"%\" character |\n\n**Combination:**\n\n| Format | Meaning |\n| ------ | ------- |\n| c | date and time (%a %b %e %T %Y) |\n| D | Date (%m/%d/%y) |\n| F | The ISO 8601 date format (%Y-%m-%d) |\n| v | VMS date (%e-%^b-%4Y) |\n| x | Same as %D |\n| X | Same as %T |\n| r | 12-hour time (%I:%M:%S %p) |\n| R | 24-hour time (%H:%M) |\n| T | 24-hour time (%H:%M:%S) |\n\n```puppet\n$timestamp = Timestamp('2016-08-24T12:13:14')\n\n# Notice the timestamp using a format that notices the ISO 8601 date format\nnotice($timestamp.strftime('%F')) # outputs '2016-08-24'\n\n# Notice the timestamp using a format that notices weekday, month, day, time (as UTC), and year\nnotice($timestamp.strftime('%c')) # outputs 'Wed Aug 24 12:13:14 2016'\n\n# Notice the timestamp using a specific timezone\nnotice($timestamp.strftime('%F %T %z', 'PST')) # outputs '2016-08-24 04:13:14 -0800'\n\n# Notice the timestamp using timezone that is current for the evaluating process\nnotice($timestamp.strftime('%F %T', 'current')) # outputs the timestamp using the timezone for the current process\n```\n\n### Format directives applicable to `Timespan`:\n\n| Format | Meaning |\n| ------ | ------- |\n| D | Number of Days |\n| H | Hour of the day, 24-hour clock |\n| M | Minute of the hour (00..59) |\n| S | Second of the minute (00..59) |\n| L | Millisecond of the second (000..999). Digits under millisecond are truncated to not produce 1000. |\n| N | Fractional seconds digits, default is 9 digits (nanosecond). Digits under a specified length are truncated to avoid carry up |\n\nThe format directive that represents the highest magnitude in the format will be allowed to overflow.\nI.e. if no \"%D\" is used but a \"%H\" is present, then the hours will be more than 23 in case the\ntimespan reflects more than a day.\n\n```puppet\n$duration = Timespan({ hours => 3, minutes => 20, seconds => 30 })\n\n# Notice the duration using a format that outputs <hours>:<minutes>:<seconds>\nnotice($duration.strftime('%H:%M:%S')) # outputs '03:20:30'\n\n# Notice the duration using a format that outputs <minutes>:<seconds>\nnotice($duration.strftime('%M:%S')) # outputs '200:30'\n```\n\n- Since 4.8.0",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `strftime` with a `Timestamp`:"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `strftime` with a Timespan and a format"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"strftime(Timespan $time_object, String $format)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Timespan"
                  ],
                  "name"=>"time_object"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"format"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"strftime"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"strftime(Timestamp $time_object, String $format, Optional[String] $timezone)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Timestamp"
                  ],
                  "name"=>"time_object"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"format"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[String]"
                  ],
                  "name"=>"timezone"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"strftime"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"strftime(String $format, Optional[String] $timezone)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"format"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[String]"
                  ],
                  "name"=>"timezone"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"strftime"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:strftime) do\n  dispatch :format_timespan do\n    param 'Timespan', :time_object\n    param 'String', :format\n  end\n\n  dispatch :format_timestamp do\n    param 'Timestamp', :time_object\n    param 'String', :format\n    optional_param 'String', :timezone\n  end\n\n  dispatch :legacy_strftime do\n    param 'String', :format\n    optional_param 'String', :timezone\n  end\n\n  def format_timespan(time_object, format)\n    time_object.format(format)\n  end\n\n  def format_timestamp(time_object, format, timezone = nil)\n    time_object.format(format, timezone)\n  end\n\n  def legacy_strftime(format, timezone = nil)\n    file, line = Puppet::Pops::PuppetStack.top_of_stack\n    Puppet.warn_once('deprecations', 'legacy#strftime',\n      _('The argument signature (String format, [String timezone]) is deprecated for #strftime. See #strftime documentation and Timespan type for more info'),\n      file, line)\n    Puppet::Pops::Time::Timestamp.format_time(format, Time.now.utc, timezone)\n  end\nend"
    },
    {
      "name"=>"strip",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/strip.rb",
      "line"=>27,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"strip(Numeric $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"strip(String $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"strip(Iterable[Variant[String, Numeric]] $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable[Variant[String, Numeric]]"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Strips leading and trailing spaces from a String\n\nThis function is compatible with the stdlib function with the same name.\n\nThe function does the following:\n* For a `String` the conversion removes all leading and trailing ASCII white space characters such as space, tab, newline, and return.\n  It does not remove other space-like characters like hard space (Unicode U+00A0). (Tip, `/^[[:space:]]/` regular expression\n  matches all space-like characters).\n* For an `Iterable[Variant[String, Numeric]]` (for example an `Array`) each value is processed and the conversion is not recursive.\n* If the value is `Numeric` it is simply returned (this is for backwards compatibility).\n* An error is raised for all other data types.\n\n```puppet\n\" hello\\n\\t\".strip()\nstrip(\" hello\\n\\t\")\n```\nWould both result in `\"hello\"`\n\n```puppet\n[\" hello\\n\\t\", \" hi\\n\\t\"].strip()\nstrip([\" hello\\n\\t\", \" hi\\n\\t\"])\n```\nWould both result in `['hello', 'hi']`",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Removing leading and trailing space from a String"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Removing trailing space from strings in an Array"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"strip(Numeric $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"strip"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"strip(String $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"strip"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"strip(Iterable[Variant[String, Numeric]] $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable[Variant[String, Numeric]]"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"strip"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:strip) do\n\n  dispatch :on_numeric do\n    param 'Numeric', :arg\n  end\n\n  dispatch :on_string do\n    param 'String', :arg\n  end\n\n  dispatch :on_iterable do\n    param 'Iterable[Variant[String, Numeric]]', :arg\n  end\n\n  # unit function - since the old implementation skipped Numeric values\n  def on_numeric(n)\n    n\n  end\n\n  def on_string(s)\n    s.strip\n  end\n\n  def on_iterable(a)\n    a.map {|x| do_strip(x) }\n  end\n\n  def do_strip(x)\n    # x can only be a String or Numeric because type constraints have been automatically applied\n    x.is_a?(String) ? x.strip : x\n  end\nend"
    },
    {
      "name"=>"tag",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/tag.rb",
      "line"=>2,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"tag()",
          "docstring"=>{
            "text"=>"Add the specified tags to the containing class\nor definition.  All contained objects will then acquire that tag, also.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Add the specified tags to the containing class\nor definition.  All contained objects will then acquire that tag, also.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:tag, :arity => -2, :doc => \"Add the specified tags to the containing class\n  or definition.  All contained objects will then acquire that tag, also.\n  \") do |vals|\n    if Puppet[:tasks]\n      raise Puppet::ParseErrorWithIssue.from_issue_and_stack(\n        Puppet::Pops::Issues::CATALOG_OPERATION_NOT_SUPPORTED_WHEN_SCRIPTING,\n        {:operation => 'tag'})\n    end\n\n    self.resource.tag(*vals)\nend"
    },
    {
      "name"=>"tagged",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/tagged.rb",
      "line"=>2,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"tagged()",
          "docstring"=>{
            "text"=>"A boolean function that\ntells you whether the current container is tagged with the specified tags.\nThe tags are ANDed, so that all of the specified tags must be included for\nthe function to return true.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"A boolean function that\ntells you whether the current container is tagged with the specified tags.\nThe tags are ANDed, so that all of the specified tags must be included for\nthe function to return true.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:tagged, :type => :rvalue, :arity => -2, :doc => \"A boolean function that\n  tells you whether the current container is tagged with the specified tags.\n  The tags are ANDed, so that all of the specified tags must be included for\n  the function to return true.\") do |vals|\n    if Puppet[:tasks]\n      raise Puppet::ParseErrorWithIssue.from_issue_and_stack(\n        Puppet::Pops::Issues::CATALOG_OPERATION_NOT_SUPPORTED_WHEN_SCRIPTING,\n        {:operation => 'tagged'})\n    end\n\n    retval = true\n    vals.each do |val|\n      unless compiler.catalog.tagged?(val) or resource.tagged?(val)\n        retval = false\n        break\n      end\n    end\n\n    return retval\nend"
    },
    {
      "name"=>"template",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/template.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"template()",
          "docstring"=>{
            "text"=>"Loads an ERB template from a module, evaluates it, and returns the resulting\nvalue as a string.\n\nThe argument to this function should be a `<MODULE NAME>/<TEMPLATE FILE>`\nreference, which will load `<TEMPLATE FILE>` from a module's `templates`\ndirectory. (For example, the reference `apache/vhost.conf.erb` will load the\nfile `<MODULES DIRECTORY>/apache/templates/vhost.conf.erb`.)\n\nThis function can also accept:\n\n* An absolute path, which can load a template file from anywhere on disk.\n* Multiple arguments, which will evaluate all of the specified templates and\nreturn their outputs concatenated into a single string.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Loads an ERB template from a module, evaluates it, and returns the resulting\nvalue as a string.\n\nThe argument to this function should be a `<MODULE NAME>/<TEMPLATE FILE>`\nreference, which will load `<TEMPLATE FILE>` from a module's `templates`\ndirectory. (For example, the reference `apache/vhost.conf.erb` will load the\nfile `<MODULES DIRECTORY>/apache/templates/vhost.conf.erb`.)\n\nThis function can also accept:\n\n* An absolute path, which can load a template file from anywhere on disk.\n* Multiple arguments, which will evaluate all of the specified templates and\nreturn their outputs concatenated into a single string.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(:template, :type => :rvalue, :arity => -2, :doc =>\n  \"Loads an ERB template from a module, evaluates it, and returns the resulting\n  value as a string.\n\n  The argument to this function should be a `<MODULE NAME>/<TEMPLATE FILE>`\n  reference, which will load `<TEMPLATE FILE>` from a module's `templates`\n  directory. (For example, the reference `apache/vhost.conf.erb` will load the\n  file `<MODULES DIRECTORY>/apache/templates/vhost.conf.erb`.)\n\n  This function can also accept:\n\n  * An absolute path, which can load a template file from anywhere on disk.\n  * Multiple arguments, which will evaluate all of the specified templates and\n  return their outputs concatenated into a single string.\") do |vals|\n    if Puppet[:tasks]\n      raise Puppet::ParseErrorWithIssue.from_issue_and_stack(\n        Puppet::Pops::Issues::FEATURE_NOT_SUPPORTED_WHEN_SCRIPTING,\n        {:feature => 'ERB template'})\n    end\n    vals.collect do |file|\n      # Use a wrapper, so the template can't get access to the full\n      # Scope object.\n      debug \"Retrieving template \#{file}\"\n\n      wrapper = Puppet::Parser::TemplateWrapper.new(self)\n      wrapper.file = file\n      begin\n        wrapper.result\n      rescue => detail\n        info = detail.backtrace.first.split(':')\n        message = []\n        message << _(\"Failed to parse template %{file}:\") % { file: file }\n        message << _(\"  Filepath: %{file_path}\") % { file_path: info[0] }\n        message << _(\"  Line: %{line}\") % { line: info[1] }\n        message << _(\"  Detail: %{detail}\") % { detail: detail }\n        raise Puppet::ParseError, message.join(\"\\n\") + \"\\n\"\n      end\n    end.join(\"\")\nend"
    },
    {
      "name"=>"then",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/then.rb",
      "line"=>67,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"then(Any $arg, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"Calls a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nwith the given argument unless the argument is `undef`.\nReturns `undef` if the argument is `undef`, and otherwise the result of giving the\nargument to the lambda.\n\nThis is useful to process a sequence of operations where an intermediate\nresult may be `undef` (which makes the entire sequence `undef`).\nThe `then` function is especially useful with the function `dig` which\nperforms in a similar way \"digging out\" a value in a complex structure.\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {x => 100, y => 200}]}}\nnotice $data.dig(a, b, 1, x).then |$x| { $x * 2 }\n```\n\nWould notice the value 200\n\nContrast this with:\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {not_x => 100, why => 200}]}}\nnotice $data.dig(a, b, 1, x).then |$x| { $x * 2 }\n```\n\nWhich would notice `undef` since the last lookup of 'x' results in `undef` which\nis returned (without calling the lambda given to the `then` function).\n\nAs a result there is no need for conditional logic or a temporary (non local)\nvariable as the result is now either the wanted value (`x`) multiplied\nby 2 or `undef`.\n\nCalls to `then` can be chained. In the next example, a structure is using an offset based on\nusing 1 as the index to the first element (instead of 0 which is used in the language).\nWe are not sure if user input actually contains an index at all, or if it is\noutside the range of available names.args.\n\n```puppet\n# Names to choose from\n$names = ['Ringo', 'Paul', 'George', 'John']\n\n# Structure where 'beatle 2' is wanted (but where the number refers\n# to 'Paul' because input comes from a source using 1 for the first\n# element).\n\n$data = ['singer', { beatle => 2 }]\n$picked = assert_type(String,\n  # the data we are interested in is the second in the array,\n  # a hash, where we want the value of the key 'beatle'\n  $data.dig(1, 'beatle')\n    # and we want the index in $names before the given index\n    .then |$x| { $names[$x-1] }\n    # so we can construct a string with that beatle's name\n    .then |$x| { \"Picked Beatle '${x}'\" }\n)\nnotice $picked\n```\n\nWould notice \"Picked Beatle 'Paul'\", and would raise an error if the result\nwas not a String.\n\n* Since 4.5.0",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `dig` and `then`"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Chaining calls to the `then` function"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Calls a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nwith the given argument unless the argument is `undef`.\nReturns `undef` if the argument is `undef`, and otherwise the result of giving the\nargument to the lambda.\n\nThis is useful to process a sequence of operations where an intermediate\nresult may be `undef` (which makes the entire sequence `undef`).\nThe `then` function is especially useful with the function `dig` which\nperforms in a similar way \"digging out\" a value in a complex structure.\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {x => 100, y => 200}]}}\nnotice $data.dig(a, b, 1, x).then |$x| { $x * 2 }\n```\n\nWould notice the value 200\n\nContrast this with:\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {not_x => 100, why => 200}]}}\nnotice $data.dig(a, b, 1, x).then |$x| { $x * 2 }\n```\n\nWhich would notice `undef` since the last lookup of 'x' results in `undef` which\nis returned (without calling the lambda given to the `then` function).\n\nAs a result there is no need for conditional logic or a temporary (non local)\nvariable as the result is now either the wanted value (`x`) multiplied\nby 2 or `undef`.\n\nCalls to `then` can be chained. In the next example, a structure is using an offset based on\nusing 1 as the index to the first element (instead of 0 which is used in the language).\nWe are not sure if user input actually contains an index at all, or if it is\noutside the range of available names.args.\n\n```puppet\n# Names to choose from\n$names = ['Ringo', 'Paul', 'George', 'John']\n\n# Structure where 'beatle 2' is wanted (but where the number refers\n# to 'Paul' because input comes from a source using 1 for the first\n# element).\n\n$data = ['singer', { beatle => 2 }]\n$picked = assert_type(String,\n  # the data we are interested in is the second in the array,\n  # a hash, where we want the value of the key 'beatle'\n  $data.dig(1, 'beatle')\n    # and we want the index in $names before the given index\n    .then |$x| { $names[$x-1] }\n    # so we can construct a string with that beatle's name\n    .then |$x| { \"Picked Beatle '${x}'\" }\n)\nnotice $picked\n```\n\nWould notice \"Picked Beatle 'Paul'\", and would raise an error if the result\nwas not a String.\n\n* Since 4.5.0",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `dig` and `then`"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Chaining calls to the `then` function"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Any"
            ],
            "name"=>"arg"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Callable[1,1]"
            ],
            "name"=>"&block"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:then) do\n  dispatch :then do\n    param 'Any', :arg\n    block_param 'Callable[1,1]', :block\n  end\n\n  def then(arg)\n    return nil if arg.nil?\n    yield(arg)\n  end\nend"
    },
    {
      "name"=>"then",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/then.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"then()",
          "docstring"=>{
            "text"=>"Call a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nwith the given argument unless the argument is undef. Return `undef` if argument is\n`undef`, and otherwise the result of giving the argument to the lambda.\n\nThis is useful to process a sequence of operations where an intermediate\nresult may be `undef` (which makes the entire sequence `undef`).\nThe `then` function is especially useful with the function `dig` which\nperforms in a similar way \"digging out\" a value in a complex structure.\n\n**Example:** Using `dig` and `then`\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {x => 100, y => 200}]}}\nnotice $data.dig(a, b, 1, x).then |$x| { $x * 2 }\n```\n\nWould notice the value 200\n\nContrast this with:\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {ex => 100, why => 200}]}}\nnotice $data.dig(a, b, 1, x).then |$x| { $x * 2 }\n```\n\nWhich would notice `undef` since the last lookup of 'x' results in `undef` which\nis returned (without calling the lambda given to the `then` function).\n\nAs a result there is no need for conditional logic or a temporary (non local)\nvariable as the result is now either the wanted value (`x`) multiplied\nby 2 or `undef`.\n\nCalls to `then` can be chained. In the next example, a structure is using an offset based on\nusing 1 as the index to the first element (instead of 0 which is used in the language).\nWe are not sure if user input actually contains an index at all, or if it is\noutside the range of available names.args.\n\n**Example:** Chaining calls to the `then` function\n\n```puppet\n# Names to choose from\n$names = ['Ringo', 'Paul', 'George', 'John']\n\n# Structure where 'beatle 2' is wanted (but where the number refers\n# to 'Paul' because input comes from a source using 1 for the first\n# element).\n\n$data = ['singer', { beatle => 2 }]\n$picked = assert_type(String,\n  # the data we are interested in is the second in the array,\n  # a hash, where we want the value of the key 'beatle'\n  $data.dig(1, 'beatle')\n    # and we want the index in $names before the given index\n    .then |$x| { $names[$x-1] }\n    # so we can construct a string with that beatle's name\n    .then |$x| { \"Picked Beatle '${x}'\" }\n)\n```\n\nWould notice \"Picked Beatle 'Paul'\", and would raise an error if the result\nwas not a String.\n\n* Since 4.5.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Call a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nwith the given argument unless the argument is undef. Return `undef` if argument is\n`undef`, and otherwise the result of giving the argument to the lambda.\n\nThis is useful to process a sequence of operations where an intermediate\nresult may be `undef` (which makes the entire sequence `undef`).\nThe `then` function is especially useful with the function `dig` which\nperforms in a similar way \"digging out\" a value in a complex structure.\n\n**Example:** Using `dig` and `then`\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {x => 100, y => 200}]}}\nnotice $data.dig(a, b, 1, x).then |$x| { $x * 2 }\n```\n\nWould notice the value 200\n\nContrast this with:\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {ex => 100, why => 200}]}}\nnotice $data.dig(a, b, 1, x).then |$x| { $x * 2 }\n```\n\nWhich would notice `undef` since the last lookup of 'x' results in `undef` which\nis returned (without calling the lambda given to the `then` function).\n\nAs a result there is no need for conditional logic or a temporary (non local)\nvariable as the result is now either the wanted value (`x`) multiplied\nby 2 or `undef`.\n\nCalls to `then` can be chained. In the next example, a structure is using an offset based on\nusing 1 as the index to the first element (instead of 0 which is used in the language).\nWe are not sure if user input actually contains an index at all, or if it is\noutside the range of available names.args.\n\n**Example:** Chaining calls to the `then` function\n\n```puppet\n# Names to choose from\n$names = ['Ringo', 'Paul', 'George', 'John']\n\n# Structure where 'beatle 2' is wanted (but where the number refers\n# to 'Paul' because input comes from a source using 1 for the first\n# element).\n\n$data = ['singer', { beatle => 2 }]\n$picked = assert_type(String,\n  # the data we are interested in is the second in the array,\n  # a hash, where we want the value of the key 'beatle'\n  $data.dig(1, 'beatle')\n    # and we want the index in $names before the given index\n    .then |$x| { $names[$x-1] }\n    # so we can construct a string with that beatle's name\n    .then |$x| { \"Picked Beatle '${x}'\" }\n)\n```\n\nWould notice \"Picked Beatle 'Paul'\", and would raise an error if the result\nwas not a String.\n\n* Since 4.5.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :then,\n  :type => :rvalue,\n  :arity => -2,\n  :doc => <<-DOC\nCall a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nwith the given argument unless the argument is undef. Return `undef` if argument is\n`undef`, and otherwise the result of giving the argument to the lambda.\n\nThis is useful to process a sequence of operations where an intermediate\nresult may be `undef` (which makes the entire sequence `undef`).\nThe `then` function is especially useful with the function `dig` which\nperforms in a similar way \"digging out\" a value in a complex structure.\n\n**Example:** Using `dig` and `then`\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {x => 100, y => 200}]}}\nnotice $data.dig(a, b, 1, x).then |$x| { $x * 2 }\n```\n\nWould notice the value 200\n\nContrast this with:\n\n```puppet\n$data = {a => { b => [{x => 10, y => 20}, {ex => 100, why => 200}]}}\nnotice $data.dig(a, b, 1, x).then |$x| { $x * 2 }\n```\n\nWhich would notice `undef` since the last lookup of 'x' results in `undef` which\nis returned (without calling the lambda given to the `then` function).\n\nAs a result there is no need for conditional logic or a temporary (non local)\nvariable as the result is now either the wanted value (`x`) multiplied\nby 2 or `undef`.\n\nCalls to `then` can be chained. In the next example, a structure is using an offset based on\nusing 1 as the index to the first element (instead of 0 which is used in the language).\nWe are not sure if user input actually contains an index at all, or if it is\noutside the range of available names.args.\n\n**Example:** Chaining calls to the `then` function\n\n```puppet\n# Names to choose from\n$names = ['Ringo', 'Paul', 'George', 'John']\n\n# Structure where 'beatle 2' is wanted (but where the number refers\n# to 'Paul' because input comes from a source using 1 for the first\n# element).\n\n$data = ['singer', { beatle => 2 }]\n$picked = assert_type(String,\n  # the data we are interested in is the second in the array,\n  # a hash, where we want the value of the key 'beatle'\n  $data.dig(1, 'beatle')\n    # and we want the index in $names before the given index\n    .then |$x| { $names[$x-1] }\n    # so we can construct a string with that beatle's name\n    .then |$x| { \"Picked Beatle '${x}'\" }\n)\n```\n\nWould notice \"Picked Beatle 'Paul'\", and would raise an error if the result\nwas not a String.\n\n* Since 4.5.0\n\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('then')\nend"
    },
    {
      "name"=>"tree_each",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/tree_each.rb",
      "line"=>145,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"tree_each(Variant[Iterator, Array, Hash, Object] $tree, Optional[OptionsType] $options, Callable[2,2] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Variant[Iterator, Array, Hash, Object]"
                ],
                "name"=>"tree"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[OptionsType]"
                ],
                "name"=>"options"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[2,2]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"tree_each(Variant[Iterator, Array, Hash, Object] $tree, Optional[OptionsType] $options, Callable[1,1] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Variant[Iterator, Array, Hash, Object]"
                ],
                "name"=>"tree"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[OptionsType]"
                ],
                "name"=>"options"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable[1,1]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"tree_each(Variant[Iterator, Array, Hash, Object] $tree, Optional[OptionsType] $options)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Variant[Iterator, Array, Hash, Object]"
                ],
                "name"=>"tree"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[OptionsType]"
                ],
                "name"=>"options"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Runs a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nrecursively and repeatedly using values from a data structure, then returns the unchanged data structure, or if\na lambda is not given, returns an `Iterator` for the tree.\n\nThis function takes one mandatory argument, one optional, and an optional block in this order:\n\n1. An `Array`, `Hash`, `Iterator`, or `Object` that the function will iterate over.\n2. An optional hash with the options:\n   * `include_containers` => `Optional[Boolean]` # default true - if containers should be given to the lambda\n   * `include_values` => `Optional[Boolean]` # default true - if non containers should be given to the lambda\n   * `include_root` => `Optional[Boolean]` # default true - if the root container should be given to the lambda\n   * `container_type` => `Optional[Type[Variant[Array, Hash, Object]]]` # a type that determines what a container is - can only\n      be set to a type that matches the default `Variant[Array, Hash, Object]`.\n   * `order` => `Enum[depth_first, breadth_first]` # default ´depth_first`, the order in which elements are visited\n   * `include_refs` => Optional[Boolean] # default `false`, if attributes in objects marked as bing of `reference` kind\n      should be included.\n3. An optional lambda, which the function calls for each element in the first argument. It must\n   accept one or two arguments; either `$path`, and `$value`, or just `$value`.\n\n`$data.tree_each |$path, $value| { <PUPPET CODE BLOCK> }`\n`$data.tree_each |$value| { <PUPPET CODE BLOCK> }`\n\nor\n\n`tree_each($data) |$path, $value| { <PUPPET CODE BLOCK> }`\n`tree_each($data) |$value| { <PUPPET CODE BLOCK> }`\n\nThe parameter `$path` is always given as an `Array` containing the path that when applied to\nthe tree as `$data.dig(*$path) yields the `$value`.\nThe `$value` is the value at that path.\n\nFor `Array` values, the path will contain `Integer` entries with the array index,\nand for `Hash` values, the path will contain the hash key, which may be `Any` value.\nFor `Object` containers, the entry is the name of the attribute (a `String`).\n\nThe tree is walked in either depth-first order, or in breadth-first order under the control of the\n`order` option, yielding each `Array`, `Hash`, `Object`, and each entry/attribute.\nThe default is `depth_first` which means that children are processed before siblings.\nAn order of `breadth_first` means that siblings are processed before children.\n\n```puppet\n[1, [2, 3], 4]\n```\n\nResults in:\n\nIf containers are skipped:\n\n* `depth_first` order `1`, `2`, `3`, `4`\n* `breadth_first` order `1`, `4`,`2`, `3`\n\nIf containers and root, are included:\n\n* `depth_first` order `[1, [2, 3], 4]`, `1`, `[2, 3]`, `2`, `3`, `4`\n* `breadth_first` order `[1, [2, 3], 4]`, `1`, `[2, 3]`, `4`, `2`, `3`\n\nTypical use of the `tree_each` function include:\n* a more efficient way to iterate over a tree than first using `flatten` on an array\n  as that requires a new (potentially very large) array to be created\n* when a tree needs to be transformed and 'pretty printed' in a template\n* avoiding having to write a special recursive function when tree contains hashes (flatten does\n  not work on hashes)\n\n```puppet\n$data = [1, 2, [3, [4, 5]]]\n$data.tree_each({include_containers => false}) |$v| { notice \"$v\" }\n```\n\nThis would call the lambda 5 times with with the following values in sequence: `1`, `2`, `3`, `4`, `5`\n\n```puppet\n$data = [1, 2, [3, [4, 5]]]\n$data.tree_each |$v| { notice \"$v\" }\n```\n\nThis would call the lambda 7 times with the following values in sequence:\n`1`, `2`, `[3, [4, 5]]`, `3`, `[4, 5]`, `4`, `5`\n\n```puppet\n$data = [1, 2, [3, [4, 5]]]\n$data.tree_each({include_values => false, include_root => false}) |$v| { notice \"$v\" }\n```\n\nThis would call the lambda 2 times with the following values in sequence:\n`[3, [4, 5]]`, `[4, 5]`\n\nAny Puppet Type system data type can be used to filter what is\nconsidered to be a container, but it must be a narrower type than one of\nthe default Array, Hash, Object types - for example it is not possible to make a\n`String` be a container type.\n\n```puppet\n$data = [1, {a => 'hello', b => [100, 200]}, [3, [4, 5]]]\n$data.tree_each({container_type => Array, include_containers => false} |$v| { notice \"$v\" }\n```\n\nWould call the lambda 5 times with `1`, `{a => 'hello', b => [100, 200]}`, `3`, `4`, `5`\n\n**Chaining** When calling `tree_each` without a lambda the function produces an `Iterator`\nthat can be chained into another iteration. Thus it is easy to use one of:\n\n* `reverse_each` - get \"leaves before root\"\n* `filter` - prune the tree\n* `map` - transform each element\n* `reduce` - produce something else\n\nNote than when chaining, the value passed on is a `Tuple` with `[path, value]`.\n\n```puppet\n# A tree of some complexity (here very simple for readability)\n$tree = [\n { name => 'user1', status => 'inactive', id => '10'},\n { name => 'user2', status => 'active', id => '20'}\n]\nnotice $tree.tree_each.filter |$v| {\n $value = $v[1]\n $value =~ Hash and $value[status] == active\n}\n```\n\nWould notice `[[[1], {name => user2, status => active, id => 20}]]`, which can then be processed\nfurther as each filtered result appears as a `Tuple` with `[path, value]`.\n\n\nFor general examples that demonstrates iteration see the Puppet\n[iteration](https://puppet.com/docs/puppet/latest/lang_iteration.html)\ndocumentation.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using the `tree_each` function"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"depth- or breadth-first order"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"A flattened iteration over a tree excluding Collections"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"A flattened iteration over a tree (including containers by default)"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"A flattened iteration over a tree (including only non root containers)"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Only `Array` as container type"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Pruning a tree"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"tree_each(Variant[Iterator, Array, Hash, Object] $tree, Optional[OptionsType] $options, Callable[2,2] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Variant[Iterator, Array, Hash, Object]"
                  ],
                  "name"=>"tree"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[OptionsType]"
                  ],
                  "name"=>"options"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[2,2]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"tree_each"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"tree_each(Variant[Iterator, Array, Hash, Object] $tree, Optional[OptionsType] $options, Callable[1,1] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Variant[Iterator, Array, Hash, Object]"
                  ],
                  "name"=>"tree"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[OptionsType]"
                  ],
                  "name"=>"options"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Callable[1,1]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"tree_each"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"tree_each(Variant[Iterator, Array, Hash, Object] $tree, Optional[OptionsType] $options)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Variant[Iterator, Array, Hash, Object]"
                  ],
                  "name"=>"tree"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[OptionsType]"
                  ],
                  "name"=>"options"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"tree_each"
          },
          {
            "tag_name"=>"since",
            "text"=>"5.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:tree_each) do\n\n  local_types do\n    type \"OptionsType  = Struct[{\\\n      container_type => Optional[Type],\\\n      include_root   => Optional[Boolean],\n      include_containers => Optional[Boolean],\\\n      include_values => Optional[Boolean],\\\n      order => Optional[Enum[depth_first, breadth_first]],\\\n      include_refs   => Optional[Boolean]\\\n    }]\"\n  end\n\n  dispatch :tree_Enumerable2 do\n    param 'Variant[Iterator, Array, Hash, Object]', :tree\n    optional_param 'OptionsType', :options\n    block_param 'Callable[2,2]', :block\n  end\n\n  dispatch :tree_Enumerable1 do\n    param 'Variant[Iterator, Array, Hash, Object]', :tree\n    optional_param 'OptionsType', :options\n    block_param 'Callable[1,1]', :block\n  end\n\n  dispatch :tree_Iterable do\n    param 'Variant[Iterator, Array, Hash, Object]', :tree\n    optional_param 'OptionsType', :options\n  end\n\n  def tree_Enumerable1(enum, options = {}, &block)\n    iterator(enum, options).each {|_, v| yield(v) }\n    enum\n  end\n\n  def tree_Enumerable2(enum, options = {}, &block)\n    iterator(enum, options).each {|path, v| yield(path, v) }\n    enum\n  end\n\n  def tree_Iterable(enum, options = {}, &block)\n    Puppet::Pops::Types::Iterable.on(iterator(enum, options))\n  end\n\n  def iterator(enum, options)\n    if depth_first?(options)\n      Puppet::Pops::Types::Iterable::DepthFirstTreeIterator.new(enum, options)\n    else\n      Puppet::Pops::Types::Iterable::BreadthFirstTreeIterator.new(enum, options)\n    end\n  end\n\n  def depth_first?(options)\n    (order = options['order']).nil? ? true : order == 'depth_first'\n  end\nend"
    },
    {
      "name"=>"type",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/type.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"type()",
          "docstring"=>{
            "text"=>"Returns the data type of a given value with a given degree of generality.\n\n```puppet\ntype InferenceFidelity = Enum[generalized, reduced, detailed]\n\nfunction type(Any $value, InferenceFidelity $fidelity = 'detailed') # returns Type\n```\n\n **Example:** Using `type`\n\n ``` puppet\n notice type(42) =~ Type[Integer]\n ```\n\n Would notice `true`.\n\n By default, the best possible inference is made where all details are retained.\n This is good when the type is used for further type calculations but is overwhelmingly\n rich in information if it is used in a error message.\n\n The optional argument `$fidelity` may be given as (from lowest to highest fidelity):\n\n * `generalized` - reduces to common type and drops size constraints\n * `reduced` - reduces to common type in collections\n * `detailed` - (default) all details about inferred types is retained\n\n **Example:** Using `type()` with different inference fidelity:\n\n ``` puppet\n notice type([3.14, 42], 'generalized')\n notice type([3.14, 42], 'reduced'')\n notice type([3.14, 42], 'detailed')\n notice type([3.14, 42])\n ```\n\n Would notice the four values:\n\n 1. 'Array[Numeric]'\n 2. 'Array[Numeric, 2, 2]'\n 3. 'Tuple[Float[3.14], Integer[42,42]]]'\n 4. 'Tuple[Float[3.14], Integer[42,42]]]'\n\n * Since 4.4.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns the data type of a given value with a given degree of generality.\n\n```puppet\ntype InferenceFidelity = Enum[generalized, reduced, detailed]\n\nfunction type(Any $value, InferenceFidelity $fidelity = 'detailed') # returns Type\n```\n\n **Example:** Using `type`\n\n ``` puppet\n notice type(42) =~ Type[Integer]\n ```\n\n Would notice `true`.\n\n By default, the best possible inference is made where all details are retained.\n This is good when the type is used for further type calculations but is overwhelmingly\n rich in information if it is used in a error message.\n\n The optional argument `$fidelity` may be given as (from lowest to highest fidelity):\n\n * `generalized` - reduces to common type and drops size constraints\n * `reduced` - reduces to common type in collections\n * `detailed` - (default) all details about inferred types is retained\n\n **Example:** Using `type()` with different inference fidelity:\n\n ``` puppet\n notice type([3.14, 42], 'generalized')\n notice type([3.14, 42], 'reduced'')\n notice type([3.14, 42], 'detailed')\n notice type([3.14, 42])\n ```\n\n Would notice the four values:\n\n 1. 'Array[Numeric]'\n 2. 'Array[Numeric, 2, 2]'\n 3. 'Tuple[Float[3.14], Integer[42,42]]]'\n 4. 'Tuple[Float[3.14], Integer[42,42]]]'\n\n * Since 4.4.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :type,\n  :type => :rvalue,\n  :arity => -1,\n  :doc => <<-DOC\nReturns the data type of a given value with a given degree of generality.\n\n```puppet\ntype InferenceFidelity = Enum[generalized, reduced, detailed]\n\nfunction type(Any $value, InferenceFidelity $fidelity = 'detailed') # returns Type\n```\n\n **Example:** Using `type`\n\n ``` puppet\n notice type(42) =~ Type[Integer]\n ```\n\n Would notice `true`.\n\n By default, the best possible inference is made where all details are retained.\n This is good when the type is used for further type calculations but is overwhelmingly\n rich in information if it is used in a error message.\n\n The optional argument `$fidelity` may be given as (from lowest to highest fidelity):\n\n * `generalized` - reduces to common type and drops size constraints\n * `reduced` - reduces to common type in collections\n * `detailed` - (default) all details about inferred types is retained\n\n **Example:** Using `type()` with different inference fidelity:\n\n ``` puppet\n notice type([3.14, 42], 'generalized')\n notice type([3.14, 42], 'reduced'')\n notice type([3.14, 42], 'detailed')\n notice type([3.14, 42])\n ```\n\n Would notice the four values:\n\n 1. 'Array[Numeric]'\n 2. 'Array[Numeric, 2, 2]'\n 3. 'Tuple[Float[3.14], Integer[42,42]]]'\n 4. 'Tuple[Float[3.14], Integer[42,42]]]'\n\n * Since 4.4.0\n\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('type')\nend"
    },
    {
      "name"=>"type",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/type.rb",
      "line"=>45,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"type(Any $value, Optional[Enum[detailed]] $inference_method)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Enum[detailed]]"
                ],
                "name"=>"inference_method"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"type(Any $value, Enum[reduced] $inference_method)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Enum[reduced]"
                ],
                "name"=>"inference_method"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"type(Any $value, Enum[generalized] $inference_method)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"value"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Enum[generalized]"
                ],
                "name"=>"inference_method"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns the data type of a given value with a given degree of generality.\n\n```puppet\ntype InferenceFidelity = Enum[generalized, reduced, detailed]\n\nfunction type(Any $value, InferenceFidelity $fidelity = 'detailed') # returns Type\n```\n\n``` puppet\nnotice type(42) =~ Type[Integer]\n```\n\nWould notice `true`.\n\nBy default, the best possible inference is made where all details are retained.\nThis is good when the type is used for further type calculations but is overwhelmingly\nrich in information if it is used in a error message.\n\nThe optional argument `$fidelity` may be given as (from lowest to highest fidelity):\n\n* `generalized` - reduces to common type and drops size constraints\n* `reduced` - reduces to common type in collections\n* `detailed` - (default) all details about inferred types is retained\n\n``` puppet\nnotice type([3.14, 42], 'generalized')\nnotice type([3.14, 42], 'reduced'')\nnotice type([3.14, 42], 'detailed')\nnotice type([3.14, 42])\n```\n\nWould notice the four values:\n\n1. 'Array[Numeric]'\n2. 'Array[Numeric, 2, 2]'\n3. 'Tuple[Float[3.14], Integer[42,42]]]'\n4. 'Tuple[Float[3.14], Integer[42,42]]]'",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `type`"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `type()` with different inference fidelity:"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"type(Any $value, Optional[Enum[detailed]] $inference_method)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"value"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Enum[detailed]]"
                  ],
                  "name"=>"inference_method"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"type"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"type(Any $value, Enum[reduced] $inference_method)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"value"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Enum[reduced]"
                  ],
                  "name"=>"inference_method"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"type"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"type(Any $value, Enum[generalized] $inference_method)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ],
                  "name"=>"value"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Enum[generalized]"
                  ],
                  "name"=>"inference_method"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"type"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.4.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:type) do\n  dispatch :type_detailed do\n    param 'Any', :value\n    optional_param 'Enum[detailed]', :inference_method\n  end\n\n  dispatch :type_parameterized do\n    param 'Any', :value\n    param 'Enum[reduced]', :inference_method\n  end\n\n  dispatch :type_generalized do\n    param 'Any', :value\n    param 'Enum[generalized]', :inference_method\n  end\n\n  def type_detailed(value, _ = nil)\n    Puppet::Pops::Types::TypeCalculator.infer_set(value)\n  end\n\n  def type_parameterized(value, _)\n    Puppet::Pops::Types::TypeCalculator.infer(value)\n  end\n\n  def type_generalized(value, _)\n    Puppet::Pops::Types::TypeCalculator.infer(value).generalize\n  end\nend"
    },
    {
      "name"=>"unique",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/unique.rb",
      "line"=>86,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"unique(String $string, Optional[Callable[String]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"string"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[String]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"unique(Hash $hash, Optional[Callable[Any]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash"
                ],
                "name"=>"hash"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[Any]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"unique(Array $array, Optional[Callable[Any]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array"
                ],
                "name"=>"array"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[Any]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"unique(Iterable $iterable, Optional[Callable[Any]] &$block)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Iterable"
                ],
                "name"=>"iterable"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable[Any]]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Produces a unique set of values from an `Iterable` argument.\n\n* If the argument is a `String`, the unique set of characters are returned as a new `String`.\n* If the argument is a `Hash`, the resulting hash associates a set of keys with a set of unique values.\n* For all other types of `Iterable` (`Array`, `Iterator`) the result is an `Array` with\n  a unique set of entries.\n* Comparison of all `String` values are case sensitive.\n* An optional code block can be given - if present it is given each candidate value and its return is used instead of the given value. This\n  enables transformation of the value before comparison. The result of the lambda is only used for comparison.\n* The optional code block when used with a hash is given each value (not the keys).\n\n```puppet\n# will produce 'abc'\n\"abcaabb\".unique\n```\n\n```puppet\n# will produce ['a', 'b', 'c']\n['a', 'b', 'c', 'a', 'a', 'b'].unique\n```\n\n```puppet\n# will produce { ['a', 'b'] => [10], ['c'] => [20]}\n{'a' => 10, 'b' => 10, 'c' => 20}.unique\n\n# will produce { 'a' => 10, 'c' => 20 } (use first key with first value)\nHash.new({'a' => 10, 'b' => 10, 'c' => 20}.unique.map |$k, $v| { [ $k[0] , $v[0]] })\n\n# will produce { 'b' => 10, 'c' => 20 } (use last key with first value)\nHash.new({'a' => 10, 'b' => 10, 'c' => 20}.unique.map |$k, $v| { [ $k[-1] , $v[0]] })\n```\n\n```\n# will produce [3, 2, 1]\n[1,2,2,3,3].reverse_each.unique\n```\n\n```puppet\n# will produce [['sam', 'smith'], ['sue', 'smith']]\n[['sam', 'smith'], ['sam', 'brown'], ['sue', 'smith']].unique |$x| { $x[0] }\n\n# will produce [['sam', 'smith'], ['sam', 'brown']]\n[['sam', 'smith'], ['sam', 'brown'], ['sue', 'smith']].unique |$x| { $x[1] }\n\n# will produce ['aBc', 'bbb'] (using a lambda to make comparison using downcased (%d) strings)\n['aBc', 'AbC', 'bbb'].unique |$x| { String($x,'%d') }\n\n# will produce {[a] => [10], [b, c, d, e] => [11, 12, 100]}\n{a => 10, b => 11, c => 12, d => 100, e => 11}.unique |$v| { if $v > 10 { big } else { $v } } \n```\n\nNote that for `Hash` the result is slightly different than for the other data types. For those the result contains the\n*first-found* unique value, but for `Hash` it contains associations from a set of keys to the set of values clustered by the\nequality lambda (or the default value equality if no lambda was given). This makes the `unique` function more versatile for hashes\nin general, while requiring that the simple computation of \"hash's unique set of values\" is performed as `$hsh.map |$k, $v| { $v }.unique`.\n(A unique set of hash keys is in general meaningless (since they are unique by definition) - although if processed with a different\nlambda for equality that would be different. First map the hash to an array of its keys if such a unique computation is wanted). \nIf the more advanced clustering is wanted for one of the other data types, simply transform it into a `Hash` as shown in the\nfollowing example.\n\n```puppet\n# Array ['a', 'b', 'c'] to Hash with index results in\n# {0 => 'a', 1 => 'b', 2 => 'c'}\nHash(['a', 'b', 'c'].map |$i, $v| { [$i, $v]})\n\n# String \"abc\" to Hash with index results in\n# {0 => 'a', 1 => 'b', 2 => 'c'}\nHash(Array(\"abc\").map |$i,$v| { [$i, $v]})\n\"abc\".to(Array).map |$i,$v| { [$i, $v]}.to(Hash)\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using unique with a String"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using unique with an Array"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using unique with a Hash"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using unique with an Iterable"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using unique with a lambda"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"turning a string or array into a hash with index keys"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"unique(String $string, Optional[Callable[String]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"string"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[String]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"unique"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"unique(Hash $hash, Optional[Callable[Any]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash"
                  ],
                  "name"=>"hash"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[Any]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"unique"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"unique(Array $array, Optional[Callable[Any]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array"
                  ],
                  "name"=>"array"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[Any]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"unique"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"unique(Iterable $iterable, Optional[Callable[Any]] &$block)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Iterable"
                  ],
                  "name"=>"iterable"
                },
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Optional[Callable[Any]]"
                  ],
                  "name"=>"&block"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"unique"
          },
          {
            "tag_name"=>"since",
            "text"=>"Puppet 5.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:unique) do\n  dispatch :unique_string do\n    param 'String', :string\n    optional_block_param 'Callable[String]', :block\n  end\n\n  dispatch :unique_hash do\n    param 'Hash', :hash\n    optional_block_param 'Callable[Any]', :block\n  end\n\n  dispatch :unique_array do\n    param 'Array', :array\n    optional_block_param 'Callable[Any]', :block\n  end\n\n  dispatch :unique_iterable do\n    param 'Iterable', :iterable\n    optional_block_param 'Callable[Any]', :block\n  end\n\n  def unique_string(string, &block)\n    string.split('').uniq(&block).join('')\n  end\n\n  def unique_hash(hash, &block)\n    block = lambda {|v| v } unless block_given?\n    result = Hash.new {|h, k| h[k] = {:keys =>[], :values =>[]} }\n    hash.each_pair do |k,v|\n      rc = result[ block.call(v) ]\n      rc[:keys] << k\n      rc[:values] << v\n    end\n    # reduce the set of possibly duplicated value entries\n    inverted = {}\n    result.each_pair {|k,v| inverted[v[:keys]] = v[:values].uniq }\n    inverted\n  end\n\n  def unique_array(array,&block)\n    array.uniq(&block)\n  end\n\n  def unique_iterable(iterable, &block)\n    Puppet::Pops::Types::Iterable.on(iterable).uniq(&block)\n  end\nend"
    },
    {
      "name"=>"unwrap",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/unwrap.rb",
      "line"=>30,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"unwrap(Sensitive $arg, Optional[Callable] &$block)",
          "docstring"=>{
            "text"=>"Unwraps a Sensitive value and returns the wrapped object.\n\n```puppet\n$plaintext = 'hunter2'\n$pw = Sensitive.new($plaintext)\nnotice(\"Wrapped object is $pw\") #=> Prints \"Wrapped object is Sensitive [value redacted]\"\n$unwrapped = $pw.unwrap\nnotice(\"Unwrapped object is $unwrapped\") #=> Prints \"Unwrapped object is hunter2\"\n```\n\nYou can optionally pass a block to unwrap in order to limit the scope where the\nunwrapped value is visible.\n\n```puppet\n$pw = Sensitive.new('hunter2')\nnotice(\"Wrapped object is $pw\") #=> Prints \"Wrapped object is Sensitive [value redacted]\"\n$pw.unwrap |$unwrapped| {\n  $conf = inline_template(\"password: ${unwrapped}\\n\")\n  Sensitive.new($conf)\n} #=> Returns a new Sensitive object containing an interpolated config file\n# $unwrapped is now out of scope\n```",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Usage of unwrap"
              },
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Unwrapping with a block of code"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Sensitive"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Optional[Callable]"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Unwraps a Sensitive value and returns the wrapped object.\n\n```puppet\n$plaintext = 'hunter2'\n$pw = Sensitive.new($plaintext)\nnotice(\"Wrapped object is $pw\") #=> Prints \"Wrapped object is Sensitive [value redacted]\"\n$unwrapped = $pw.unwrap\nnotice(\"Unwrapped object is $unwrapped\") #=> Prints \"Unwrapped object is hunter2\"\n```\n\nYou can optionally pass a block to unwrap in order to limit the scope where the\nunwrapped value is visible.\n\n```puppet\n$pw = Sensitive.new('hunter2')\nnotice(\"Wrapped object is $pw\") #=> Prints \"Wrapped object is Sensitive [value redacted]\"\n$pw.unwrap |$unwrapped| {\n  $conf = inline_template(\"password: ${unwrapped}\\n\")\n  Sensitive.new($conf)\n} #=> Returns a new Sensitive object containing an interpolated config file\n# $unwrapped is now out of scope\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Usage of unwrap"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Unwrapping with a block of code"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Sensitive"
            ],
            "name"=>"arg"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Optional[Callable]"
            ],
            "name"=>"&block"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:unwrap) do\n  dispatch :unwrap do\n    param 'Sensitive', :arg\n    optional_block_param\n  end\n\n  def unwrap(arg)\n    unwrapped = arg.unwrap\n    if block_given?\n      yield(unwrapped)\n    else\n      unwrapped\n    end\n  end\nend"
    },
    {
      "name"=>"upcase",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/upcase.rb",
      "line"=>46,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"upcase(Numeric $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Numeric"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"upcase(String $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"upcase(Array[StringData] $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Array[StringData]"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        },
        {
          "signature"=>"upcase(Hash[StringData, StringData] $arg)",
          "docstring"=>{
            "text"=>"",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash[StringData, StringData]"
                ],
                "name"=>"arg"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Converts a String, Array or Hash (recursively) into upper case.\n\nThis function is compatible with the stdlib function with the same name.\n\nThe function does the following:\n* For a `String`, its upper case version is returned. This is done using Ruby system locale which handles some, but not all\n  special international up-casing rules (for example German double-s ß is upcased to \"SS\", whereas upper case double-s\n  is downcased to ß).\n* For `Array` and `Hash` the conversion to upper case is recursive and each key and value must be convertible by\n  this function.\n* When a `Hash` is converted, some keys could result in the same key - in those cases, the\n  latest key-value wins. For example if keys \"aBC\", and \"abC\" where both present, after upcase there would only be one\n  key \"ABC\".\n* If the value is `Numeric` it is simply returned (this is for backwards compatibility).\n* An error is raised for all other data types.\n\nPlease note: This function relies directly on Ruby's String implementation and as such may not be entirely UTF8 compatible.\nTo ensure best compatibility please use this function with Ruby 2.4.0 or greater - https://bugs.ruby-lang.org/issues/10085.\n\n```puppet\n'hello'.upcase()\nupcase('hello')\n```\nWould both result in \"HELLO\"\n\n```puppet\n['a', 'b'].upcase()\nupcase(['a', 'b'])\n```\nWould both result in ['A', 'B']\n\n```puppet\n{'a' => 'hello', 'b' => 'goodbye'}.upcase()\n```\nWould result in `{'A' => 'HELLO', 'B' => 'GOODBYE'}`\n\n```puppet\n['a', 'b', ['c', ['d']], {'x' => 'y'}].upcase\n```\nWould result in `['A', 'B', ['C', ['D']], {'X' => 'Y'}]`",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Converting a String to upper case"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Converting an Array to upper case"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Converting a Hash to upper case"
          },
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Converting a recursive structure"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"upcase(Numeric $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Numeric"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"upcase"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"upcase(String $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "String"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"upcase"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"upcase(Array[StringData] $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Array[StringData]"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"upcase"
          },
          {
            "tag_name"=>"overload",
            "signature"=>"upcase(Hash[StringData, StringData] $arg)",
            "docstring"=>{
              "text"=>"",
              "tags"=>[
                {
                  "tag_name"=>"param",
                  "text"=>"",
                  "types"=>[
                    "Hash[StringData, StringData]"
                  ],
                  "name"=>"arg"
                },
                {
                  "tag_name"=>"return",
                  "text"=>"",
                  "types"=>[
                    "Any"
                  ]
                }
              ]
            },
            "name"=>"upcase"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:upcase) do\n  local_types do\n    type 'StringData = Variant[String, Numeric, Array[StringData], Hash[StringData, StringData]]'\n  end\n\n  dispatch :on_numeric do\n    param 'Numeric', :arg\n  end\n\n  dispatch :on_string do\n    param 'String', :arg\n  end\n\n  dispatch :on_array do\n    param 'Array[StringData]', :arg\n  end\n\n  dispatch :on_hash do\n    param 'Hash[StringData, StringData]', :arg\n  end\n\n  # unit function - since the old implementation skipped Numeric values\n  def on_numeric(n)\n    n\n  end\n\n  def on_string(s)\n    s.upcase\n  end\n\n  def on_array(a)\n    a.map {|x| do_upcase(x) }\n  end\n\n  def on_hash(h)\n    result = {}\n    h.each_pair {|k,v| result[do_upcase(k)] = do_upcase(v) }\n    result\n  end\n\n  def do_upcase(x)\n    x.is_a?(String) ? x.upcase : call_function('upcase', x)\n  end\nend"
    },
    {
      "name"=>"values",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/values.rb",
      "line"=>17,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"values(Hash $hsh)",
          "docstring"=>{
            "text"=>"Returns the values of a hash as an Array\n\n```puppet\n$hsh = {\"apples\" => 3, \"oranges\" => 4 }\n$hsh.values()\nvalues($hsh)\n# both results in the array [3, 4]\n```\n\n* Note that a hash in the puppet language accepts any data value (including `undef`) unless\n  it is constrained with a `Hash` data type that narrows the allowed data types.\n* For an empty hash, an empty array is returned.\n* The order of the values is the same as the order in the hash (typically the order in which they were added).",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `values`"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Hash"
                ],
                "name"=>"hsh"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Returns the values of a hash as an Array\n\n```puppet\n$hsh = {\"apples\" => 3, \"oranges\" => 4 }\n$hsh.values()\nvalues($hsh)\n# both results in the array [3, 4]\n```\n\n* Note that a hash in the puppet language accepts any data value (including `undef`) unless\n  it is constrained with a `Hash` data type that narrows the allowed data types.\n* For an empty hash, an empty array is returned.\n* The order of the values is the same as the order in the hash (typically the order in which they were added).",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `values`"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Hash"
            ],
            "name"=>"hsh"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:values) do\n  dispatch :values do\n    param 'Hash', :hsh\n  end\n\n  def values(hsh)\n    hsh.values\n  end\nend"
    },
    {
      "name"=>"versioncmp",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/versioncmp.rb",
      "line"=>3,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"versioncmp()",
          "docstring"=>{
            "text"=>"Compares two version numbers.\n\nPrototype:\n\n    \\$result = versioncmp(a, b)\n\nWhere a and b are arbitrary version strings.\n\nThis function returns:\n\n* `1` if version a is greater than version b\n* `0` if the versions are equal\n* `-1` if version a is less than version b\n\nExample:\n\n    if versioncmp('2.6-1', '2.4.5') > 0 {\n        notice('2.6-1 is > than 2.4.5')\n    }\n\nThis function uses the same version comparison algorithm used by Puppet's\n`package` type.",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Compares two version numbers.\n\nPrototype:\n\n    \\$result = versioncmp(a, b)\n\nWhere a and b are arbitrary version strings.\n\nThis function returns:\n\n* `1` if version a is greater than version b\n* `0` if the versions are equal\n* `-1` if version a is less than version b\n\nExample:\n\n    if versioncmp('2.6-1', '2.4.5') > 0 {\n        notice('2.6-1 is > than 2.4.5')\n    }\n\nThis function uses the same version comparison algorithm used by Puppet's\n`package` type.",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction( :versioncmp, :type => :rvalue, :arity => 2, :doc =>\n\"Compares two version numbers.\n\nPrototype:\n\n    \\$result = versioncmp(a, b)\n\nWhere a and b are arbitrary version strings.\n\nThis function returns:\n\n* `1` if version a is greater than version b\n* `0` if the versions are equal\n* `-1` if version a is less than version b\n\nExample:\n\n    if versioncmp('2.6-1', '2.4.5') > 0 {\n        notice('2.6-1 is > than 2.4.5')\n    }\n\nThis function uses the same version comparison algorithm used by Puppet's\n`package` type.\n\n\") do |args|\n\n  return Puppet::Util::Package.versioncmp(args[0], args[1])\nend"
    },
    {
      "name"=>"versioncmp",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/versioncmp.rb",
      "line"=>26,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"versioncmp(String $a, String $b)",
          "docstring"=>{
            "text"=>"Compares two version numbers.\n\nPrototype:\n\n    \\$result = versioncmp(a, b)\n\nWhere a and b are arbitrary version strings.\n\nThis function returns:\n\n* `1` if version a is greater than version b\n* `0` if the versions are equal\n* `-1` if version a is less than version b\n\nThis function uses the same version comparison algorithm used by Puppet's\n`package` type.",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"\nif versioncmp('2.6-1', '2.4.5') > 0 {\n    notice('2.6-1 is > than 2.4.5')\n}",
                "name"=>"Using versioncmp"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"a"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "String"
                ],
                "name"=>"b"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Compares two version numbers.\n\nPrototype:\n\n    \\$result = versioncmp(a, b)\n\nWhere a and b are arbitrary version strings.\n\nThis function returns:\n\n* `1` if version a is greater than version b\n* `0` if the versions are equal\n* `-1` if version a is less than version b\n\nThis function uses the same version comparison algorithm used by Puppet's\n`package` type.",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"\nif versioncmp('2.6-1', '2.4.5') > 0 {\n    notice('2.6-1 is > than 2.4.5')\n}",
            "name"=>"Using versioncmp"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "String"
            ],
            "name"=>"a"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "String"
            ],
            "name"=>"b"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:versioncmp) do\n\n  dispatch :versioncmp do\n    param 'String', :a\n    param 'String', :b\n  end\n\n  def versioncmp(a, b)\n    Puppet::Util::Package.versioncmp(a, b)\n  end\nend"
    },
    {
      "name"=>"warning",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/warning.rb",
      "line"=>2,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"warning(Any *$values)",
          "docstring"=>{
            "text"=>"Logs a message on the server at level `warning`.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"The values to log.",
                "types"=>[
                  "Any"
                ],
                "name"=>"*values"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Undef"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Logs a message on the server at level `warning`.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"The values to log.",
            "types"=>[
              "Any"
            ],
            "name"=>"*values"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Undef"
            ]
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:warning, Puppet::Functions::InternalFunction) do\n  # @param values The values to log.\n  # @return [Undef]\n  dispatch :warning do\n    scope_param\n    repeated_param 'Any', :values\n    return_type 'Undef'\n  end\n\n  def warning(scope, *values)\n    Puppet::Util::Log.log_func(scope, :warning, values)\n  end\nend"
    },
    {
      "name"=>"with",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/with.rb",
      "line"=>23,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"with(Any *$arg, Callable &$block)",
          "docstring"=>{
            "text"=>"Calls a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nwith the given arguments and returns the result.\n\nSince a lambda's scope is\n[local](https://puppet.com/docs/puppet/latest/lang_lambdas.html#lambda-scope)\nto the lambda, you can use the `with` function to create private blocks of code within a\nclass using variables whose values cannot be accessed outside of the lambda.\n\n```puppet\n# Concatenate three strings into a single string formatted as a list.\n$fruit = with(\"apples\", \"oranges\", \"bananas\") |$x, $y, $z| {\n  \"${x}, ${y}, and ${z}\"\n}\n$check_var = $x\n# $fruit contains \"apples, oranges, and bananas\"\n# $check_var is undefined, as the value of $x is local to the lambda.\n```",
            "tags"=>[
              {
                "tag_name"=>"example",
                "text"=>"",
                "name"=>"Using `with`"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Any"
                ],
                "name"=>"*arg"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Callable"
                ],
                "name"=>"&block"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Calls a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nwith the given arguments and returns the result.\n\nSince a lambda's scope is\n[local](https://puppet.com/docs/puppet/latest/lang_lambdas.html#lambda-scope)\nto the lambda, you can use the `with` function to create private blocks of code within a\nclass using variables whose values cannot be accessed outside of the lambda.\n\n```puppet\n# Concatenate three strings into a single string formatted as a list.\n$fruit = with(\"apples\", \"oranges\", \"bananas\") |$x, $y, $z| {\n  \"${x}, ${y}, and ${z}\"\n}\n$check_var = $x\n# $fruit contains \"apples, oranges, and bananas\"\n# $check_var is undefined, as the value of $x is local to the lambda.\n```",
        "tags"=>[
          {
            "tag_name"=>"example",
            "text"=>"",
            "name"=>"Using `with`"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Any"
            ],
            "name"=>"*arg"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Callable"
            ],
            "name"=>"&block"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.0.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:with) do\n  dispatch :with do\n    repeated_param 'Any', :arg\n    block_param\n  end\n\n  def with(*args)\n    yield(*args)\n  end\nend"
    },
    {
      "name"=>"with",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/parser/functions/with.rb",
      "line"=>1,
      "type"=>"ruby3x",
      "signatures"=>[
        {
          "signature"=>"with()",
          "docstring"=>{
            "text"=>"Call a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nwith the given arguments and return the result. Since a lambda's scope is\nlocal to the lambda, you can use the `with` function to create private blocks\nof code within a class using variables whose values cannot be accessed outside\nof the lambda.\n\n**Example**: Using `with`\n\n~~~ puppet\n# Concatenate three strings into a single string formatted as a list.\n$fruit = with(\"apples\", \"oranges\", \"bananas\") |$x, $y, $z| {\n  \"${x}, ${y}, and ${z}\"\n}\n$check_var = $x\n# $fruit contains \"apples, oranges, and bananas\"\n# $check_var is undefined, as the value of $x is local to the lambda.\n~~~\n\n- Since 4.0.0",
            "tags"=>[
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"Call a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nwith the given arguments and return the result. Since a lambda's scope is\nlocal to the lambda, you can use the `with` function to create private blocks\nof code within a class using variables whose values cannot be accessed outside\nof the lambda.\n\n**Example**: Using `with`\n\n~~~ puppet\n# Concatenate three strings into a single string formatted as a list.\n$fruit = with(\"apples\", \"oranges\", \"bananas\") |$x, $y, $z| {\n  \"${x}, ${y}, and ${z}\"\n}\n$check_var = $x\n# $fruit contains \"apples, oranges, and bananas\"\n# $check_var is undefined, as the value of $x is local to the lambda.\n~~~\n\n- Since 4.0.0",
        "tags"=>[
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          }
        ]
      },
      "source"=>"Puppet::Parser::Functions::newfunction(\n  :with,\n  :type => :rvalue,\n  :arity => -1,\n  :doc => <<-DOC\nCall a [lambda](https://puppet.com/docs/puppet/latest/lang_lambdas.html)\nwith the given arguments and return the result. Since a lambda's scope is\nlocal to the lambda, you can use the `with` function to create private blocks\nof code within a class using variables whose values cannot be accessed outside\nof the lambda.\n\n**Example**: Using `with`\n\n~~~ puppet\n# Concatenate three strings into a single string formatted as a list.\n$fruit = with(\"apples\", \"oranges\", \"bananas\") |$x, $y, $z| {\n  \"${x}, ${y}, and ${z}\"\n}\n$check_var = $x\n# $fruit contains \"apples, oranges, and bananas\"\n# $check_var is undefined, as the value of $x is local to the lambda.\n~~~\n\n- Since 4.0.0\nDOC\n) do |args|\n  Puppet::Parser::Functions::Error.is4x('with')\nend"
    },
    {
      "name"=>"yaml_data",
      "file"=>"/Users/heston.hoffman/repos/puppet-docs/vendor/puppet/lib/puppet/functions/yaml_data.rb",
      "line"=>9,
      "type"=>"ruby4x",
      "signatures"=>[
        {
          "signature"=>"yaml_data(Struct[{path=>String[1]}] $options, Puppet::LookupContext $context)",
          "docstring"=>{
            "text"=>"The `yaml_data` is a hiera 5 `data_hash` data provider function.\nSee [the configuration guide documentation](https://puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#configuring-a-hierarchy-level-built-in-backends) for\nhow to use this function.",
            "tags"=>[
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Struct[{path=>String[1]}]"
                ],
                "name"=>"options"
              },
              {
                "tag_name"=>"param",
                "text"=>"",
                "types"=>[
                  "Puppet::LookupContext"
                ],
                "name"=>"context"
              },
              {
                "tag_name"=>"return",
                "text"=>"",
                "types"=>[
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring"=>{
        "text"=>"The `yaml_data` is a hiera 5 `data_hash` data provider function.\nSee [the configuration guide documentation](https://puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#configuring-a-hierarchy-level-built-in-backends) for\nhow to use this function.",
        "tags"=>[
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Struct[{path=>String[1]}]"
            ],
            "name"=>"options"
          },
          {
            "tag_name"=>"param",
            "text"=>"",
            "types"=>[
              "Puppet::LookupContext"
            ],
            "name"=>"context"
          },
          {
            "tag_name"=>"return",
            "text"=>"",
            "types"=>[
              "Any"
            ]
          },
          {
            "tag_name"=>"since",
            "text"=>"4.8.0"
          },
          {
            "tag_name"=>"since",
            "text"=>"4.8.0"
          }
        ]
      },
      "source"=>"Puppet::Functions.create_function(:yaml_data) do\n  # @since 4.8.0\n  dispatch :yaml_data do\n    param 'Struct[{path=>String[1]}]', :options\n    param 'Puppet::LookupContext', :context\n  end\n\n  argument_mismatch :missing_path do\n    param 'Hash', :options\n    param 'Puppet::LookupContext', :context\n  end\n\n  def yaml_data(options, context)\n    path = options['path']\n    context.cached_file_data(path) do |content|\n      begin\n        data = Puppet::Util::Yaml.safe_load(content, [Symbol], path)\n        if data.is_a?(Hash)\n          Puppet::Pops::Lookup::HieraConfig.symkeys_to_string(data)\n        else\n          msg = _(\"%{path}: file does not contain a valid yaml hash\" % { path: path })\n          raise Puppet::DataBinding::LookupError, msg if Puppet[:strict] == :error && data != false\n          Puppet.warning(msg)\n          {}\n        end\n      rescue Puppet::Util::Yaml::YamlLoadError => ex\n        # YamlLoadErrors include the absolute path to the file, so no need to add that\n        raise Puppet::DataBinding::LookupError, _(\"Unable to parse %{message}\") % { message: ex.message }\n      end\n    end\n  end\n\n  def missing_path(options, context)\n    \"one of 'path', 'paths' 'glob', 'globs' or 'mapped_paths' must be declared in hiera.yaml when using this data_hash function\"\n  end\nend"
    }
  ],
  "puppet_tasks"=>[],
  "puppet_plans"=>[]
}